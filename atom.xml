<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DongWei&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wei-dong.top/"/>
  <updated>2020-08-26T15:03:57.653Z</updated>
  <id>http://www.wei-dong.top/</id>
  
  <author>
    <name>Mr-Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试二三事之我想杯喝水</title>
    <link href="http://www.wei-dong.top/2020/08/26/%E9%9D%A2%E8%AF%95%E4%BA%8C%E4%B8%89%E4%BA%8B%E4%B9%8B%E6%88%91%E6%83%B3%E5%96%9D%E6%9D%AF%E6%B0%B4/"/>
    <id>http://www.wei-dong.top/2020/08/26/面试二三事之我想喝杯水/</id>
    <published>2020-08-26T13:37:23.000Z</published>
    <updated>2020-08-26T15:03:57.653Z</updated>
    
    <content type="html"><![CDATA[<p>深圳这时候的天气，出趟门衣服就得汗湿透。然而这周已经出去面试了四个公司了。<br>我想记录的是在这几次面试过程中我的一些感受和经历。有吐槽也有欣喜。</p>
<p>周一上午去中通快递，离我住的地儿18公里左右。随着公交车窗外的风景变得越来越萧条，我后悔的心情也随之加重。在我的印象中中通也是一个大厂了，到了办公楼之后我否定了我的印象。面试通知上写的是在3A层，我心想应该是三楼，然后在整个三楼没找到A的房间。后来才知道四楼不能叫做四楼，有忌讳，所以叫3A。我好像发现什么秘密似的跑到了四楼，终于找到他们的办公室。昏暗的灯光，低矮的楼层，有点让我喘不上气来。格子间内安安静静，似乎每个人都在忙自己的东西。人事带我进一个狭小的会议室，桌子旁边还放着一个机房服务器，嗡嗡的风扇声让会议室的温度上升了很多，我局促不安地站在那里，想着人事会不会给我倒杯水，毕竟外面天气还是挺热的。然后一个穿着拖鞋的看似沉默寡言的技术大佬进来，一通常规不常规的技术问题输出，全程盯着简历上百十来个字，没有任何眼神交流。最后问我要多少钱，我说出了我的期望他有所变化，然后象征性地问我还有什么问题，在我正准备提问的时候他马上说既然没什么问题今天就先到这里，要不你先回去吧，然后一个人默默地离开了会议室，顺便还把会议室的灯关了。我坐在椅子上突然觉得这里的空调好像不怎么制冷，昏暗的房间里我感受到孤独在慢慢袭来，然后我缓缓起身，环顾四周，默默走出大门，回头看了他们一眼，他们好像确实是那么忙，没人说话，昏暗的灯光，逼仄的格子间以及低矮的楼层…走出办公楼，11点的太阳晒地我脑门出汗，我赶紧加快了脚步。还得去吃午饭呢。</p>
<p>随之而来的是下午的小公司。地址离我住的地儿很近，10分钟的车程。科兴科学园是深圳加班最晚的地方，令所有程序员闻风丧胆。我抱着忐忑的情绪进去了。同一楼层其他公司都有前台有门脸儿，这个小公司没得。办公室在一个犄角旮旯处，我像在迷宫里寻找出路一样找到的。按了门铃一个面无表情的小菇凉给我打开了门，然后领我去一个小会议室，让我在这里先等着。会议室桌子上摆了盆绿植，不知道为什么我喜欢坐在绿植旁边。可能是我看到绿植盆里有水吧。会议室外面有工人在装修，有几个工人举着水杯一饮而尽，看到这里我不禁抿了抿嘴角。要是这时候有瓶快乐水该有多好呀。实在不行一杯冰水也行呀。接着一个很壮的大哥进来了，一看就是广东人。他没有准备我的简历，问我带了没，我回答没有，然后他似乎想去找行政打印，我说我带了个pad你用我pad看，凑合一下吧。接着就随便聊了技术问题，有些我是真没答上，不过我也觉得他问的方式不是很合理。但是我觉得挑战还是很大，也能遇见会很难受。不知会不会给机会。出了写字楼，下午4点的太阳是真毒，我的眼睛都不太敢睁开了。今天流了几斤汗，很渴了，得赶紧回去喝杯冰可乐。</p>
<p>第二天的面试不算太远，车程大概半小时。这个写字楼很高端，第一次见到电梯选楼层是在电梯外面的。办公室在19楼，我开始以为是9楼，然后上去发现没找到。最后核实后继续按19楼，死活显示楼层错误。随后我灵机一动，要不我一层一层的试吧，这样最多需要再按10下就一定能到19楼了。事实上最多能输入11，因为我到了11楼后再输入上面的楼层都提示错误。那时候我就瞬间明白了，我真是个天才。到了19楼前台让我填个表格，各种信息都让你写完。坐在休闲区里望着窗外，我陷入了沉思。当时外面的风景是这样的<img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/%E5%86%99%E5%AD%97%E6%A5%BC.jpg" alt="钢铁森林">。</p>
<p>不知道什么时候起，我开始厌倦这样的写字楼。或者是说我厌倦的仅仅是这里的写字楼而已。外面一片荒凉，除了门前的八车道以及来来往往的大货车之外，似乎也见不到什么活物在活动。身处在这样的钢铁森林里我顿时感到喘不过气来。虽然这里的装修很互联网，但我却没有任何向往，我觉得很压抑，甚至后悔过来。不知道过去了多久，前台问我写完了没有，接着就领着我去一个小会议室，他们给会议室取名都是用深圳的地名如小梅沙，华侨城之类的。我记得云集是用的星座比如白羊座，水瓶座。那个小会议室的灯光我觉得让人觉得很不舒服，给人一种特别暧昧的感觉。椅子上红色的。墙壁在灯光的映射下是粉色的。如果这时候能给我倒杯水，我心里可能会好受很多，但是并没有。我在那样的房间里等了差不多五分钟，来了个看似很厉害的面试官，照着我简历圈圈点点，但是并没有问到一些技术上的东西。随着就让我等一下，几分钟后前台打开会议室门告诉我我让我先回去。那时候我内心似乎有好几匹草泥马在散步。这样的场景下，我可能会觉得在筛选简历的时候他们都没做到认真筛选，把我这样的根本不符合招聘要求的都约进来了。出了写字楼大门，我回头看了一眼，哇这楼是真高，阳光也特别刺眼，我也是真的有点渴了。去公交站台的时候还遇到个大妈问路，我给她用手机导航指了指，她高兴地对我说谢谢了靓仔。那时候我心里特别高兴，之前压抑的情绪一下子就消失了。原来帮助别人是多么快乐的事情呀。</p>
<p>今天下午去顺丰，有俩面试官，其中有个女技术。看上去做技术很多年了，从谈吐上都能体现出技术水准和涵养都很高，另外一个是小伙，在沟通的过程中他会和你有眼神交流。这让我感受到了尊重，最主要的是这小伙一开始给我倒了杯水，他说看你出了这么多汗给你倒杯水吧，我高兴地连胜答谢。就这样愉快的聊了一个多小时，我喝了好几杯水。至于聊什么都不重要了，毕竟我终于喝到了水。</p>
<p>这天气出去面试也很辛苦，最后总结是出门面试可能有不给你倒水喝风险，请随身携带饮用水。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深圳这时候的天气，出趟门衣服就得汗湿透。然而这周已经出去面试了四个公司了。&lt;br&gt;我想记录的是在这几次面试过程中我的一些感受和经历。有吐槽也有欣喜。&lt;/p&gt;
&lt;p&gt;周一上午去中通快递，离我住的地儿18公里左右。随着公交车窗外的风景变得越来越萧条，我后悔的心情也随之加重。在我
    
    </summary>
    
      <category term="BEYOND CODING" scheme="http://www.wei-dong.top/categories/BEYOND-CODING/"/>
    
    
      <category term="编码之外，碎碎念" scheme="http://www.wei-dong.top/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96%EF%BC%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Java中的“锁”事之ReentrantLock</title>
    <link href="http://www.wei-dong.top/2020/07/12/Java%E4%B8%AD%E7%9A%84%E2%80%9C%E9%94%81%E2%80%9D%E4%BA%8B%E4%B9%8BReentrantLock/"/>
    <id>http://www.wei-dong.top/2020/07/12/Java中的“锁”事之ReentrantLock/</id>
    <published>2020-07-12T04:37:23.000Z</published>
    <updated>2020-07-12T04:31:56.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈“锁”"><a href="#谈谈“锁”" class="headerlink" title="谈谈“锁”"></a>谈谈“锁”</h2><p>说起Java的锁，脑袋里第一反应就是关键字<code>synchronized</code>.这是Java提供的基于语言级别的锁，底层是通过cup指令来实现的。对于使用者来说非常简单，容易上手。然而也有一些小缺陷。在早期的jvm中<code>synchronized</code>性能不是太好，而且加锁和释放锁不是很灵活，比如只能在程序正常执行完成和抛出异常时释放锁，对锁的持有很“执着”，获取锁的时候没法设置超时时间等。</p>
<p>除了jvm层面实现的锁之外，JDK中也提供了另外的锁实现。下面从一个例子说起。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">boolean</span> b = lock.hasQueuedThreads();</div><div class="line">            System.out.println(<span class="string">"t1"</span>+ b);</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"t1 start working..."</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    System.out.println(<span class="string">"t1 do working..."</span>);</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">boolean</span> b = lock.hasQueuedThreads();</div><div class="line">            System.out.println(<span class="string">"t2"</span>+ b);</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"t2 start working..."</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                    System.out.println(<span class="string">"t2 do working... "</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line"></div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">boolean</span> b = lock.hasQueuedThreads();</div><div class="line">            System.out.println(<span class="string">"t3"</span>+ b);</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"t3 start working..."</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                    System.out.println(<span class="string">"t3 do working... "</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">        t3.join();</div><div class="line">        System.out.println(<span class="string">"++++finished++++"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>很容易看出，demo中使用了<code>ReentrantLock</code>来作为锁来对三个线程进行协调，确保三个线程顺序执行。使用方式也很简单：在需要保护的代码前后使用<code>lock</code>和<code>unlock</code>即可。</p>
<p>既然<code>ReentrantLock</code>能提供和<code>synchronized</code>一样的锁机制，那必须得看看到底这个“锁”有什么黑魔法。</p>
<h2 id="ReentrantLock和AbstractQueuedSynchronizer之加锁"><a href="#ReentrantLock和AbstractQueuedSynchronizer之加锁" class="headerlink" title="ReentrantLock和AbstractQueuedSynchronizer之加锁"></a>ReentrantLock和AbstractQueuedSynchronizer之加锁</h2><p>加锁其实是一个很容易理解的过程，其中我认为有点绕的是node结点之间链的摘除和建立，毕竟数据结构的基础还是比较弱，稍微多绕几圈就被整蒙圈了。<br>在研究AQS锁实现之前得聊一下什么是“公平”和“非公平”锁。所谓公平锁遵循先来的先获得锁，翻译成白话就是大家都是在排队的；而非公平锁则反之，只要有获取锁的机会，那就不顾一切去抢，不排队。</p>
<p><code>ReentrantLock</code>默认的实现为非公平锁。理论上来说非公平锁比公平锁效率更高。当然也可以通过指定参数来区分是否使用公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">// ReentrantLock中的lock方法其实</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">else</span></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NonfairSync</code>作为内部类继承自<code>Sync</code>,而<code>Sync</code>继承自<code>AbstractQueuedSynchronizer</code>。<br>说白了其实就是个模版方法，AQS提供基础实现，子类根据自己需要去自定义不同的逻辑。</p>
<p>接下来根据demo中的几个关于锁的基本操作（lock）来看看其实现细节。</p>
<p>首先lock方法中的<code>compareAndSetState(0, 1)</code>语义是如果当前的值为0，那就更新为1.这是一个基于cpu指令的原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The synchronization state.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * The current owner of exclusive mode synchronization.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">    exclusiveOwnerThread = thread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果更新成功，那就返回true。而这个原子更新的字段为AQS的<code>state</code>。这个字段简单理解为获取锁的标志，整个锁的核心都是围绕着这个字段来完成的。<br>如果更新成功，那么将当前线程置为<code>exclusiveOwnerThread</code>。这个变量表示当前持有锁的线程。<br>完整的语义即：当某个线程中的逻辑调用lock方法后，lock对象中的state字段由0更新为1，当前线程持有锁。<br>那这个线程没执行完操作，还没释放掉锁，后续的线程怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS中的实现 必须得由子类重写</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"><span class="comment">// NonfairSync中的重写</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Performs non-fair tryLock.  tryAcquire is implemented in</div><div class="line"> * subclasses, but both need nonfair try for trylock method.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在某个线程获取到了锁之后还没释放，其他线程也执行到lock方法，这时候由于lock对象中state为1，因此没办法更新，所以执行<code>acquire</code>逻辑。而<code>acquire</code>调用<code>nonfairTryAcquire</code>方法。<br>首先获取state的值，在我们的demo中由于之前的线程没有释放掉锁，这里的c的值为1，而当前线程和lock对象中持有的线程不一样（getExclusiveOwnerThread返回之前持有锁的线程对象）因此这里直接返回false。<br>当线程中执行的任务很短的时候，短到几纳秒，获取到锁的线程马上释放掉了。这个state值从1变成了0，这里其他线程就有机会再次去“争夺”一次锁，同样使用cas操作将state值从0到1，同时将当前线程置为lock对象的<code>exclusiveOwnerThread</code>字段。最后返回true，表示获取到了锁。<br>还有一种情形，一个线程多次去lock，这里lock对象中持有的线程锁同一个线程，因此进入到<code>current==getExclusiveOwnerThread()</code>逻辑。做法也很简单，将state再加1即可,这个线程依旧能获取到锁。这就是所谓的可重入（Reentrant），即可以多次获取一个锁。</p>
<p>当<code>tryAcquire</code>方法返回为真时，表示当前线程成功获取到了锁，整个lock逻辑已经完成，后面的<code>acquireQueued</code>方法就直接忽略掉。<br>这里小结一下：</p>
<ul>
<li>AQS使用state变量来标记锁是否被线程获取，使用变量<code>exclusiveOwnerThread</code>标记获取锁的线程；</li>
<li>锁可以被多次获取，这样的锁叫做可重入锁（Reentrant），通过state标记获取锁的次数，同理锁被获取多少次就得释放多少次，不然锁不会被释放；</li>
</ul>
<p>接下来看看<code>acquireQueued</code>方法的实现。上面说道，当尝试获取锁成功的时候，lock方法就结束了，如果尝试获取锁失败呢？如果失败就进入到<code>acquireQueued</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这里是两个方法<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，先调用<code>addWaiter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里，出现了新的数据结构<code>Node</code>，为了更加方便理解，现在不得不对这个数据结构进行说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * waitStatus value to indicate the next acquireShared should</div><div class="line">         * unconditionally propagate</div><div class="line">         */</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div><div class="line"></div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line">        </div><div class="line">        <span class="keyword">volatile</span> Node prev;</div><div class="line"></div><div class="line">        <span class="keyword">volatile</span> Node next;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The thread that enqueued this node.  Initialized on</div><div class="line">         * construction and nulled out after use.</div><div class="line">         */</div><div class="line">        <span class="keyword">volatile</span> Thread thread;</div><div class="line"></div><div class="line">        Node nextWaiter;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns true if node is waiting in shared mode.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</div><div class="line">            Node p = prev;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></div><div class="line">            <span class="keyword">this</span>.nextWaiter = mode;</div><div class="line">            <span class="keyword">this</span>.thread = thread;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></div><div class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</div><div class="line">            <span class="keyword">this</span>.thread = thread;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先是俩静态变量，这个变量仅仅是一个标记，并没有实际用途：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line"><span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<p>因为AQS有两种模式：独占和共享。独占模式例如demo中的<code>ReentrantLock</code>，而共享模式如并发工具包中的<code>CountDownLatch</code>。接着就是<code>waitStatus</code>变量，同时指定了几个枚举。然后就是<code>thread</code>当前线程，以及前驱后继结点。不难看出这是一个双端链表结构。<code>nextWaiter</code>字段暂时按下不表。</p>
<p>继续看<code>addWaiter</code>方法，由于传入的mode为<code>Node.EXCLUSIVE</code>，因此这里创建的node的<code>nextWaiter</code>字段的值为<code>null</code>，将当前要获取锁的线程也放进node里，然后尝试去“操作”这个node。实际上就是看这个AQS中node队列除了当前创建的还有没有别的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Head of the wait queue, lazily initialized.  Except for</div><div class="line"> * initialization, it is modified only via method setHead.  Note:</div><div class="line"> * If head exists, its waitStatus is guaranteed not to be</div><div class="line"> * CANCELLED.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Tail of the wait queue, lazily initialized.  Modified only via</div><div class="line"> * method enq to add new wait node.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的<code>tail</code>和<code>head</code>都是AQS中的变量，用于操控node链表。他们的更新都是使用cas实现的，保证原子性。如果AQS中没有node链表（没有形成），head和tail都是null，直接走<code>enq</code>逻辑，然后将新创建的这个node返回，如果AQS中有结点存在呢，那就直接将创建的node变成tail。<code>compareAndSetTail(pred, node)</code>的语义为，如果当前tail的值为pred，那么将其更新为node。然后修改后继指针，返回node结点。</p>
<p>再看看AQS中的结点为空的时候：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑很清晰，这里进一步判断了一下tail是否为空，如果是真为空，那就新建一个node结点作为头结点，同时将tail指向头结点。这时候头结点就是尾结点，且结点内没有数据，只是作为一个标志而已。然而并没有返回，因为是个死循环，头尾结点初始化成功之后，继续走else逻辑，同理将新创建的结点的前驱指向刚才新建的空结点，然后把tail指向自己（<code>Node node = new Node(Thread.currentThread(), mode);</code>）的结点。最后修改后继指针并返回。这个逻辑看起来比较绕，尤其是指针的操作让人眼花缭乱，通过画图会更容易理解。总结一句话就是：创建node链表，初始化tail和head指针，且head指针指向的是一个空node（仅仅有意义的事waitStatus=0，因为没给值，默认就是0）。而返回的新创建的node作为<code>acquireQueued</code>参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心逻辑又是一个死循环，首先获取刚才创建的node结点的前驱结点，如果前驱结点为head结点（空的结点），可以再给这个线程一次机会，尝试获取锁。<code>tryAcquire</code>之前说过，这里不赘述。如果运气好，获取到了（state从0到1）返回true，将当前结点设置为head，同时摘除链表关系，也就是那个空结点被释放了，这个时候head结点可不是空结点了，而是<code>Node node = new Node(Thread.currentThread(), mode);</code>创建出来的。最后返回false，获取锁成功。为什么要来这一出呢？因为如果之前获取锁的线程执行任务的时候，其他线程在尝试着排队的时候还是有机会去抢一下的，说不定哪一瞬间任务结束释放了锁其他线程刚好抢到了呢？当然这也是有前提的，当线程决定去排队，且是排第一个的时候才能有多一次机会去抢锁。这里有疑问了，这个不是非公平的么？为啥还得排第一个才能抢？其实并不矛盾，因为每个线程都至少有一次机会去抢锁，通过<code>tryAcquire</code>。只有没抢到的，打算排队的，排到第一个的线程有第二次机会。当然，就算某个线程排第一，多一次抢锁机会，也不一定必然抢到呀，因为别的线程依旧和这个线程一样，同样是通过<code>tryAcquire</code>来抢的，因此是公平的，严格来说不公平，因为排第一的线程多了一次机会。</p>
<p>如果这个排第一的倒霉鬼还是没获取到锁，那就很难受了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们先考虑前驱结点为空结点的情况，之前提到，空结点的<code>waitStatus</code>没有赋值，默认为0，因此这里直接走<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</code>逻辑，将其置为-1；最后返回false，然而for死循环的逻辑还没结束，还会继续尝试获取一下锁，如果还是没获取到，那就再次进入到<code>shouldParkAfterFailedAcquire</code>中，因为第一次循环中将其<code>waitStatus</code>从0设置为了-1，因此这里直接返回true，所以，当在ASQ内部中“排队”的线程数第一个，是有两次次额外的获取锁的机会的。<br>接着就是<code>parkAndCheckInterrupt</code>逻辑了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>park为停车的意思，这里理解为挂起也没太大毛病。说白了就等着呗，等到什么时候为止呢？那就得从unlock说起了。</p>
<h2 id="ReentrantLock和AbstractQueuedSynchronizer之释放锁"><a href="#ReentrantLock和AbstractQueuedSynchronizer之释放锁" class="headerlink" title="ReentrantLock和AbstractQueuedSynchronizer之释放锁"></a>ReentrantLock和AbstractQueuedSynchronizer之释放锁</h2><p>demo中的解锁方法<code>unlock</code>对应的实现逻辑为<code>release</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Releases in exclusive mode.  Implemented by unblocking one or</div><div class="line"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</div><div class="line"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</div><div class="line"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</div><div class="line"> *        can represent anything you like.</div><div class="line"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类似地，先尝试去释放一下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先把state值减回去，判断一下当前的线程是不是AQS中锁持有的线程，如果不是那就说明有问题。如果当state还原为0了说明锁被释放掉了，同时将当前AQS持有的线程置为空。最后将当前state值更新（更新为减1后的，这里并不一定是0）。正如上文提到过，如果加多次锁，那么也得释放多次。如果没获释放掉，那就说明当前锁依旧被持有。</p>
<p>如果更新state成功，那么还需要做的一件事就是处理node结点。如果AQS中的头结点不为空，且状态不是默认的初始化的0，那么就去唤醒后继结点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Wakes up node's successor, if one exists.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> node the node</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里逻辑也十分清晰，先更新结点的waitStatus，将其置为0.然后找到后面的结点，如果不是空，那就将其唤醒，和之前是park一一对应。这里还多了一段判断锁被取消的情况，注释中也写得很清晰，意思就是从node链表的尾部开始找，一直找到符合要求的结点将其唤醒。</p>
<p>唤醒了还没完，因为等待锁的线程被park了后还得继续执行后续的逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 锁释放之后 这里会继续执行</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>parkAndCheckInterrupt</code>返回的值为当前线程的中断状态，如果当前（获取锁的）线程被设置了中断标记，那么这个方法就直接返回true。即<code>interrupted=true</code>。<br>由于是死循环，同样的当前线程（被唤醒的）获取一下锁，因为AQS中的state已经还原了，所以这里能拿到，将当前结点设置为头结点，获取锁完成。由于可能存在当前获取锁的线程由于某种情况被设置了中断标记，那么就将其中断（也只是设置中断标记）。</p>
<p>相比获取锁的操作，释放锁容易很多。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文基于<code>ReentrantLock</code>锁的基础实现，对AQS的大致原理进行了比较粗略的分析。如AQS的底层结构，核心的API等。通过锁的基础操作，如加锁和释放锁背后的逻辑进行了详细解读。当然还有很多没有涉及到的地方，如条件队列，共享模式的实现，公平和非公平的体现等。当知道了AQS的原理之后，去理解这些主题也是非常轻松的。总的来说，AQS的代码量不算太多，读起来不是很吃力。</p>
<p>PS:在云笔记中发现18年的时候也写过一篇AQS的文章，现在居然一点印象都没有了，时间啊，是真残酷。<a href="http://note.youdao.com/s/dlp3lGS4" target="_blank" rel="external">2年前的笔记</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1yJ411v7er?p=11" target="_blank" rel="external">Java并发锁框架AQS(AbstractQueuedSynchronizer)原理从理论到源码透彻解析</a></p>
<p><a href="https://www.zhihu.com/question/41048032" target="_blank" rel="external">Java里一个线程调用了Thread.interrupt()到底意味着什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;谈谈“锁”&quot;&gt;&lt;a href=&quot;#谈谈“锁”&quot; class=&quot;headerlink&quot; title=&quot;谈谈“锁”&quot;&gt;&lt;/a&gt;谈谈“锁”&lt;/h2&gt;&lt;p&gt;说起Java的锁，脑袋里第一反应就是关键字&lt;code&gt;synchronized&lt;/code&gt;.这是Java提供的基于
    
    </summary>
    
      <category term="AQS 笔记" scheme="http://www.wei-dong.top/categories/AQS-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="源码" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="JDK" scheme="http://www.wei-dong.top/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>池技术实现-commons-pool2</title>
    <link href="http://www.wei-dong.top/2020/07/06/%E6%B1%A0%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0-commons-pool2/"/>
    <id>http://www.wei-dong.top/2020/07/06/池技术实现-commons-pool2/</id>
    <published>2020-07-06T08:37:23.000Z</published>
    <updated>2020-07-12T04:31:18.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><h3 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h3><p>顾名思义，这个接口是一个工厂，用于创建要池化的对象。在使用的时候一般都不直接实现，而是去继承它默认抽象实现类<code>BasePooledObjectFactory</code>。</p>
<p>只需要实现这个抽象类中的两个抽象方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PooledObject&lt;T&gt; <span class="title">wrap</span><span class="params">(T obj)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h3><p>这个接口为对象池的抽象定义，定义了很多对池的操作方法。如<code>addObject</code>等。可以简单理解为一个装对象的容器像list之类的数据结构。默认的抽象实现为<code>BaseGenericObjectPool</code>具体实现有好几个，最常见的为<code>GenericObjectPool</code>.</p>
<h3 id="GenericObjectPoolConfig"><a href="#GenericObjectPoolConfig" class="headerlink" title="GenericObjectPoolConfig"></a>GenericObjectPoolConfig</h3><p>配置类对象，就是一个简单的实体，封装很多配置参数而已。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>先针对最基本的借出对象的操作实现</p>
<h3 id="“借对象”"><a href="#“借对象”" class="headerlink" title="“借对象”"></a>“借对象”</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">borrowObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">return</span> borrowObject(getMaxWaitMillis());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">borrowObject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> borrowMaxWaitMillis)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        assertOpen();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> AbandonedConfig ac = <span class="keyword">this</span>.abandonedConfig;</div><div class="line">        <span class="keyword">if</span> (ac != <span class="keyword">null</span> &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;</div><div class="line">                (getNumIdle() &lt; <span class="number">2</span>) &amp;&amp;</div><div class="line">                (getNumActive() &gt; getMaxTotal() - <span class="number">3</span>) ) &#123;</div><div class="line">            removeAbandoned(ac);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        PooledObject&lt;T&gt; p = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Get local copy of current config so it is consistent for entire</span></div><div class="line">        <span class="comment">// method execution</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> blockWhenExhausted = getBlockWhenExhausted();</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> create;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> waitTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">            create = <span class="keyword">false</span>;</div><div class="line">            p = idleObjects.pollFirst();</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                p = create();</div><div class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                    create = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (blockWhenExhausted) &#123;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (borrowMaxWaitMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">                        p = idleObjects.takeFirst();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        p = idleObjects.pollFirst(borrowMaxWaitMillis,</div><div class="line">                                TimeUnit.MILLISECONDS);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(</div><div class="line">                            <span class="string">"Timeout waiting for idle object"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Pool exhausted"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!p.allocate()) &#123;</div><div class="line">                p = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    factory.activateObject(p);</div><div class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        destroy(p);</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e1) &#123;</div><div class="line">                        <span class="comment">// Ignore - activation failure is more important</span></div><div class="line">                    &#125;</div><div class="line">                    p = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">if</span> (create) &#123;</div><div class="line">                        <span class="keyword">final</span> NoSuchElementException nsee = <span class="keyword">new</span> NoSuchElementException(</div><div class="line">                                <span class="string">"Unable to activate object"</span>);</div><div class="line">                        nsee.initCause(e);</div><div class="line">                        <span class="keyword">throw</span> nsee;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; getTestOnBorrow()) &#123;</div><div class="line">                    <span class="keyword">boolean</span> validate = <span class="keyword">false</span>;</div><div class="line">                    Throwable validationThrowable = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        validate = factory.validateObject(p);</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</div><div class="line">                        PoolUtils.checkRethrow(t);</div><div class="line">                        validationThrowable = t;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!validate) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            destroy(p);</div><div class="line">                            destroyedByBorrowValidationCount.incrementAndGet();</div><div class="line">                        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                            <span class="comment">// Ignore - validation failure is more important</span></div><div class="line">                        &#125;</div><div class="line">                        p = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (create) &#123;</div><div class="line">                            <span class="keyword">final</span> NoSuchElementException nsee = <span class="keyword">new</span> NoSuchElementException(</div><div class="line">                                    <span class="string">"Unable to validate object"</span>);</div><div class="line">                            nsee.initCause(validationThrowable);</div><div class="line">                            <span class="keyword">throw</span> nsee;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> p.getObject();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果没有给定<code>borrowMaxWaitMillis</code>参数，那就使用默认的最大等待时间（仅仅当<code>getBlockWhenExhausted</code>为true的时候），超出这个时间就直接抛异常。</p>
<p>首先需要根据配置参数中的<code>getRemoveAbandonedOnBorrow</code>来决定是不是在每次“借”的时候抛弃掉那些快“过气”的对象。当然还是得有条件的：闲置的对象数量小于2，且当前活跃的对象数量比最大数量的差值小于3，翻译成人话就是池子快装满了呗。</p>
<h4 id="“借对象”之前的判断"><a href="#“借对象”之前的判断" class="headerlink" title="“借对象”之前的判断"></a>“借对象”之前的判断</h4><p>看看移除掉“过气”对象的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAbandoned</span><span class="params">(<span class="keyword">final</span> AbandonedConfig ac)</span> </span>&#123;</div><div class="line">        <span class="comment">// Generate a list of abandoned objects to remove</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeout =</div><div class="line">                now - (ac.getRemoveAbandonedTimeout() * <span class="number">1000L</span>);</div><div class="line">        <span class="keyword">final</span> ArrayList&lt;PooledObject&lt;T&gt;&gt; remove = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">final</span> Iterator&lt;PooledObject&lt;T&gt;&gt; it = allObjects.values().iterator();</div><div class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">            <span class="keyword">final</span> PooledObject&lt;T&gt; pooledObject = it.next();</div><div class="line">            <span class="keyword">synchronized</span> (pooledObject) &#123;</div><div class="line">                <span class="comment">// 上次使用的时间在五分钟之前 说明需要抛弃</span></div><div class="line">                <span class="keyword">if</span> (pooledObject.getState() == PooledObjectState.ALLOCATED &amp;&amp;</div><div class="line">                        pooledObject.getLastUsedTime() &lt;= timeout) &#123;</div><div class="line">                    pooledObject.markAbandoned();</div><div class="line">                    remove.add(pooledObject);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Now remove the abandoned objects</span></div><div class="line">        <span class="keyword">final</span> Iterator&lt;PooledObject&lt;T&gt;&gt; itr = remove.iterator();</div><div class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</div><div class="line">            <span class="keyword">final</span> PooledObject&lt;T&gt; pooledObject = itr.next();</div><div class="line">            <span class="keyword">if</span> (ac.getLogAbandoned()) &#123;</div><div class="line">                pooledObject.printStackTrace(ac.getLogWriter());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                invalidateObject(pooledObject.getObject());</div><div class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中有个配置参数<code>getRemoveAbandonedTimeout</code>用于判断对象是否“过气”，这个值默认是30分钟。在对象池中使用<code>allObjects</code>变量来保存所有的被“池化”的对象，这是个map类型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * All of the objects currently associated with this pool in any state. It</div><div class="line"> * excludes objects that have been destroyed. The size of</div><div class="line"> * &#123;@link #allObjects&#125; will always be less than or equal to &#123;@link</div><div class="line"> * #_maxActive&#125;. Map keys are pooled objects, values are the PooledObject</div><div class="line"> * wrappers used internally by the pool.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;IdentityWrapper&lt;T&gt;, PooledObject&lt;T&gt;&gt; allObjects =</div><div class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>然而，并不是将我们要创建的对象直接保存到这个map中，而是将对象包装成<code>PooledObject</code>放进去的，key为对象的hash值。这个对象用于池子的内部处理，比如加几个属性什么的。这种设计在很多库或者框架中很常见。为了将复杂性不直接暴露给用户，因此重新包装了一下。</p>
<p>这里的逻辑是将所有被“池化”的对象遍历出来，判断如果使用时间超过给定的时间，那就说明这个对象“过气”了，得移除掉。使用<code>invalidateObject</code>方法来销毁这个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateObject</span><span class="params">(<span class="keyword">final</span> T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">final</span> PooledObject&lt;T&gt; p = allObjects.get(<span class="keyword">new</span> IdentityWrapper&lt;&gt;(obj));</div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (isAbandonedConfig()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                <span class="string">"Invalidated object not currently part of this pool"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (p) &#123;</div><div class="line">        <span class="keyword">if</span> (p.getState() != PooledObjectState.INVALID) &#123;</div><div class="line">            destroy(p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ensureIdle(<span class="number">1</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">final</span> PooledObject&lt;T&gt; toDestroy)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        toDestroy.invalidate();</div><div class="line">        idleObjects.remove(toDestroy);</div><div class="line">        allObjects.remove(<span class="keyword">new</span> IdentityWrapper&lt;&gt;(toDestroy.getObject()));</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            factory.destroyObject(toDestroy);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            destroyedCount.incrementAndGet();</div><div class="line">            createCount.decrementAndGet();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>销毁逻辑很简单，从空闲对象列表中移除，在<code>allObjects</code>中移除，然后再更新次数，这些数据仅仅是用于对象池数据统计。</p>
<p>最核心的方法还是<code>ensureIdle</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureIdle</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> idleCount, <span class="keyword">final</span> <span class="keyword">boolean</span> always)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (idleCount &lt; <span class="number">1</span> || isClosed() || (!always &amp;&amp; !idleObjects.hasTakeWaiters())) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (idleObjects.size() &lt; idleCount) &#123;</div><div class="line">            <span class="keyword">final</span> PooledObject&lt;T&gt; p = create();</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Can't create objects, no reason to think another call to</span></div><div class="line">                <span class="comment">// create will work. Give up.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (getLifo()) &#123;</div><div class="line">                idleObjects.addFirst(p);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                idleObjects.addLast(p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isClosed()) &#123;</div><div class="line">            <span class="comment">// Pool closed while object was being added to idle objects.</span></div><div class="line">            <span class="comment">// Make sure the returned object is destroyed rather than left</span></div><div class="line">            <span class="comment">// in the idle object pool (which would effectively be a leak)</span></div><div class="line">            clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>顾名思义，这个方法保证对象池中有指定的空闲对象能用。不然你来借的时候对象池都空了，那多尴尬。</p>
<p>如果当前池中的空闲对象小于指定的值，那么就得去创建对象了，这里使用的<code>create()</code>方法就是在前文中说到的对象工厂抽象实现类中的<code>create()</code>做一样的事情，只不过这个方法创建的是一个<code>PooledObject</code>包装类型，以及一些其他的属性。然后将这个新创建的对象装到<code>idleObjects</code>容器中，这个容器类型为<code>LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt;</code>链表结构，是这个库自己实现的。</p>
<h4 id="“借对象”的细节"><a href="#“借对象”的细节" class="headerlink" title="“借对象”的细节"></a>“借对象”的细节</h4><p>之前说到<code>getBlockWhenExhausted</code>属性用于判断当“借”的时候没有是否需要等待。如果给定超时时间那就按照超时时间去等，没等到那就返回空对象，如果没给超时时间，那就死等。</p>
<p>这个属性最终决定如果池子里没对象最终抛出的异常，如果这个属性为false，那就直接抛<code>Pool exhausted</code>异常，如果为true那就抛出<code>&quot;Timeout waiting for idle object&quot;</code>异常（给了超时时间）。</p>
<p>首先得从空闲的容器中取“空闲对象”，接着判断是否是有效的。然后使用之前提到的工厂方法“激活”这个对象，默认实现中是空实现，在使用过程中可以去重写这个方法实现自定义的需求。<br><code>updateStatsBorrow</code>方法用来更新对象池的统计数据信息，不需要太关注。最后就直接返回我们需要的对象。</p>
<p>如果空闲的容器中没得可用的对象咋办？那只能去create一个了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> PooledObject&lt;T&gt; <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> localMaxTotal = getMaxTotal();</div><div class="line">        <span class="comment">// This simplifies the code later in this method</span></div><div class="line">        <span class="keyword">if</span> (localMaxTotal &lt; <span class="number">0</span>) &#123;</div><div class="line">            localMaxTotal = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localStartTimeMillis = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localMaxWaitTimeMillis = Math.max(getMaxWaitMillis(), <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Flag that indicates if create should:</span></div><div class="line">        <span class="comment">// - TRUE:  call the factory to create an object</span></div><div class="line">        <span class="comment">// - FALSE: return null</span></div><div class="line">        <span class="comment">// - null:  loop and re-test the condition that determines whether to</span></div><div class="line">        <span class="comment">//          call the factory</span></div><div class="line">        Boolean create = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (create == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (makeObjectCountLock) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> newCreateCount = createCount.incrementAndGet();</div><div class="line">                <span class="keyword">if</span> (newCreateCount &gt; localMaxTotal) &#123;</div><div class="line">                    <span class="comment">// The pool is currently at capacity or in the process of</span></div><div class="line">                    <span class="comment">// making enough new objects to take it to capacity.</span></div><div class="line">                    createCount.decrementAndGet();</div><div class="line">                    <span class="keyword">if</span> (makeObjectCount == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// There are no makeObject() calls in progress so the</span></div><div class="line">                        <span class="comment">// pool is at capacity. Do not attempt to create a new</span></div><div class="line">                        <span class="comment">// object. Return and wait for an object to be returned</span></div><div class="line">                        create = Boolean.FALSE;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// There are makeObject() calls in progress that might</span></div><div class="line">                        <span class="comment">// bring the pool to capacity. Those calls might also</span></div><div class="line">                        <span class="comment">// fail so wait until they complete and then re-test if</span></div><div class="line">                        <span class="comment">// the pool is at capacity or not.</span></div><div class="line">                        makeObjectCountLock.wait(localMaxWaitTimeMillis);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// The pool is not at capacity. Create a new object.</span></div><div class="line">                    makeObjectCount++;</div><div class="line">                    create = Boolean.TRUE;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Do not block more if maxWaitTimeMillis is set.</span></div><div class="line">            <span class="keyword">if</span> (create == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                (localMaxWaitTimeMillis &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">                 System.currentTimeMillis() - localStartTimeMillis &gt;= localMaxWaitTimeMillis)) &#123;</div><div class="line">                create = Boolean.FALSE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!create.booleanValue()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> PooledObject&lt;T&gt; p;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            p = factory.makeObject();</div><div class="line">            <span class="keyword">if</span> (getTestOnCreate() &amp;&amp; !factory.validateObject(p)) &#123;</div><div class="line">                createCount.decrementAndGet();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable e) &#123;</div><div class="line">            createCount.decrementAndGet();</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">synchronized</span> (makeObjectCountLock) &#123;</div><div class="line">                makeObjectCount--;</div><div class="line">                makeObjectCountLock.notifyAll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> AbandonedConfig ac = <span class="keyword">this</span>.abandonedConfig;</div><div class="line">        <span class="keyword">if</span> (ac != <span class="keyword">null</span> &amp;&amp; ac.getLogAbandoned()) &#123;</div><div class="line">            p.setLogAbandoned(<span class="keyword">true</span>);</div><div class="line">            p.setRequireFullStackTrace(ac.getRequireFullStackTrace());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        createdCount.incrementAndGet();</div><div class="line">        allObjects.put(<span class="keyword">new</span> IdentityWrapper&lt;&gt;(p.getObject()), p);</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个逻辑很简单，需要注意的是其中的while循环，如果池中正在创建的对象超过了最大数量，那就直接返回空。</p>
<p>至此，“借”对象的整个过程就结束了。</p>
<h3 id="驱逐逻辑"><a href="#驱逐逻辑" class="headerlink" title="驱逐逻辑"></a>驱逐逻辑</h3><p>在配置参数中有个属性<code>timeBetweenEvictionRunsMillis</code>，如果这个值为负数，就不会去运行驱逐线程，否则以配置的值作为时间间隔去扫描池中的对象，驱逐出“过气”对象。<br>具体的驱逐逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        assertOpen();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (idleObjects.size() &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            PooledObject&lt;T&gt; underTest = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">final</span> EvictionPolicy&lt;T&gt; evictionPolicy = getEvictionPolicy();</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (evictionLock) &#123;</div><div class="line">                <span class="keyword">final</span> EvictionConfig evictionConfig = <span class="keyword">new</span> EvictionConfig(</div><div class="line">                        getMinEvictableIdleTimeMillis(),</div><div class="line">                        getSoftMinEvictableIdleTimeMillis(),</div><div class="line">                        getMinIdle());</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> testWhileIdle = getTestWhileIdle();</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, m = getNumTests(); i &lt; m; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (evictionIterator == <span class="keyword">null</span> || !evictionIterator.hasNext()) &#123;</div><div class="line">                        evictionIterator = <span class="keyword">new</span> EvictionIterator(idleObjects);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!evictionIterator.hasNext()) &#123;</div><div class="line">                        <span class="comment">// Pool exhausted, nothing to do here</span></div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        underTest = evictionIterator.next();</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchElementException nsee) &#123;</div><div class="line">                        <span class="comment">// Object was borrowed in another thread</span></div><div class="line">                        <span class="comment">// Don't count this as an eviction test so reduce i;</span></div><div class="line">                        i--;</div><div class="line">                        evictionIterator = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!underTest.startEvictionTest()) &#123;</div><div class="line">                        <span class="comment">// Object was borrowed in another thread</span></div><div class="line">                        <span class="comment">// Don't count this as an eviction test so reduce i;</span></div><div class="line">                        i--;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// User provided eviction policy could throw all sorts of</span></div><div class="line">                    <span class="comment">// crazy exceptions. Protect against such an exception</span></div><div class="line">                    <span class="comment">// killing the eviction thread.</span></div><div class="line">                    <span class="keyword">boolean</span> evict;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        evict = evictionPolicy.evict(evictionConfig, underTest,</div><div class="line">                                idleObjects.size());</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</div><div class="line">                        <span class="comment">// Slightly convoluted as SwallowedExceptionListener</span></div><div class="line">                        <span class="comment">// uses Exception rather than Throwable</span></div><div class="line">                        PoolUtils.checkRethrow(t);</div><div class="line">                        swallowException(<span class="keyword">new</span> Exception(t));</div><div class="line">                        <span class="comment">// Don't evict on error conditions</span></div><div class="line">                        evict = <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (evict) &#123;</div><div class="line">                        destroy(underTest);</div><div class="line">                        destroyedByEvictorCount.incrementAndGet();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (testWhileIdle) &#123;</div><div class="line">                            <span class="keyword">boolean</span> active = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                factory.activateObject(underTest);</div><div class="line">                                active = <span class="keyword">true</span>;</div><div class="line">                            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                                destroy(underTest);</div><div class="line">                                destroyedByEvictorCount.incrementAndGet();</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (active) &#123;</div><div class="line">                                <span class="keyword">if</span> (!factory.validateObject(underTest)) &#123;</div><div class="line">                                    destroy(underTest);</div><div class="line">                                    destroyedByEvictorCount.incrementAndGet();</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    <span class="keyword">try</span> &#123;</div><div class="line">                                        factory.passivateObject(underTest);</div><div class="line">                                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                                        destroy(underTest);</div><div class="line">                                        destroyedByEvictorCount.incrementAndGet();</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (!underTest.endEvictionTest(idleObjects)) &#123;</div><div class="line">                            <span class="comment">// TODO - May need to add code here once additional</span></div><div class="line">                            <span class="comment">// states are used</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> AbandonedConfig ac = <span class="keyword">this</span>.abandonedConfig;</div><div class="line">        <span class="keyword">if</span> (ac != <span class="keyword">null</span> &amp;&amp; ac.getRemoveAbandonedOnMaintenance()) &#123;</div><div class="line">            removeAbandoned(ac);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>EvictionPolicy</code>为驱逐策略接口，用于指定使用哪种策略把过气对象清理出对象池。默认实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEvictionPolicy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EvictionPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(<span class="keyword">final</span> EvictionConfig config, <span class="keyword">final</span> PooledObject&lt;T&gt; underTest,</span></span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idleCount) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((config.getIdleSoftEvictTime() &lt; underTest.getIdleTimeMillis() &amp;&amp;</div><div class="line">                config.getMinIdle() &lt; idleCount) ||</div><div class="line">                config.getIdleEvictTime() &lt; underTest.getIdleTimeMillis()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其策略为</p>
<ul>
<li>对象池中某个对象的空闲的时间长于<code>getMinEvictableIdleTimeMillis</code></li>
<li>在对象池中的空闲对象有超过<code>getMinIdle</code>且某个对象的空闲时间长于<code>getSoftMinEvictableIdleTimeMillis</code></li>
</ul>
<p>满足其中之一即返回真，执行驱逐操作。</p>
<p>而这个线程每次只会扫描<code>getNumTests</code>数量的对象。使用<code>EvictionIterator</code>将池中所有空闲对象包装起来，其实这里使用的是迭代器模式（处处都体现设计模式呀）。如果没取到，那就将这个空对象跳过去，反正必须得取<code>getNumTests</code>这么多个，空的不算数。最后就是使用<code>destroy</code>方法将其销毁掉了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了<code>commons-pool</code>几个核心接口以及相关配置参数和代表的含义，针对核心API的实现做了源码解读。总的来说这个工具的实现其实很简单，源码读起来没有太大难度。当然除了文中提到的默认对象池实现之外，<code>commons-pool</code>还提供基于key的对象池<code>KeyedObjectPool</code>以及基于代理的对象池<code>ProxiedObjectPool</code>的实现。由于暂时没找到使用的场景，就没有继续深入解读。</p>
<p>看了对象池的实现后，觉得这些看似“高大上”的东西也不过如此。接着尝试去了解一下更加专业的“池”–连接池。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;核心接口&quot;&gt;&lt;a href=&quot;#核心接口&quot; class=&quot;headerlink&quot; title=&quot;核心接口&quot;&gt;&lt;/a&gt;核心接口&lt;/h2&gt;&lt;h3 id=&quot;PooledObjectFactory&quot;&gt;&lt;a href=&quot;#PooledObjectFactory&quot; class
    
    </summary>
    
      <category term="pool 笔记" scheme="http://www.wei-dong.top/categories/pool-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="源码" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="apache" scheme="http://www.wei-dong.top/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>池技术使用-commons-pool2</title>
    <link href="http://www.wei-dong.top/2020/07/03/%E6%B1%A0%E6%8A%80%E6%9C%AF%E4%BD%BF%E7%94%A8-commons-pool2/"/>
    <id>http://www.wei-dong.top/2020/07/03/池技术使用-commons-pool2/</id>
    <published>2020-07-03T04:37:23.000Z</published>
    <updated>2020-07-03T09:29:43.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="池技术"><a href="#池技术" class="headerlink" title="池技术"></a>池技术</h2><p>日常搬砖过程中对池技术的接触很多，最具代表的是连接池。<br>连接池也是一种池技术，本质上都是对象池。commons-pool是apacha基金会开源的一款常见的对象池工具库。</p>
<p>使用池化主要是为了节省对象创建的开销。比如日常开发息息相关的数据源连接池，就是为了减少连接创建的时间而生的。可以简单评估一下一个连接的创建经历哪些操作：对象创建，tcp连接等。tcp连接又得经历三次握手，如果是tls/ssl还得做证书签名验证，想想都麻烦。所以使用连接池可以减少这些消耗性能的操作，把机器更多的性能留给业务。</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>这里直接搬运官网的demo。</p>
<p>下面是一个从流中读取字符串的工具类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.Reader; </div><div class="line"><span class="keyword">import</span> java.io.IOException; </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderUtil</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderUtil</span><span class="params">()</span> </span>&#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Dumps the contents of the &#123;<span class="doctag">@link</span> Reader&#125; to a </div><div class="line">     * String, closing the &#123;<span class="doctag">@link</span> Reader&#125; when done. </div><div class="line">     */ </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readToString</span><span class="params">(Reader in)</span> <span class="keyword">throws</span> IOException </span>&#123; </div><div class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer(); </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = in.read(); c != -<span class="number">1</span>; c = in.read()) &#123; </div><div class="line">                buf.append((<span class="keyword">char</span>)c); </div><div class="line">            &#125; </div><div class="line">            <span class="keyword">return</span> buf.toString(); </div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123; </div><div class="line">            <span class="keyword">throw</span> e; </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            <span class="keyword">try</span> &#123; </div><div class="line">                in.close(); </div><div class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123; </div><div class="line">                <span class="comment">// ignored </span></div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>咋看上去没什么毛病，我们在日常搬砖中也会写出这样的工具类，也可以很好的工作。为了突出说明池化技术的优点，这个工具类还能继续优化，虽然优化空间不是很大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.Reader;</div><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.ObjectPool;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderUtil</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ObjectPool&lt;StringBuffer&gt; pool;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderUtil</span><span class="params">(ObjectPool&lt;StringBuffer&gt; pool)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.pool = pool;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Dumps the contents of the &#123;<span class="doctag">@link</span> Reader&#125; to a String, closing the &#123;<span class="doctag">@link</span> Reader&#125; when done.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readToString</span><span class="params">(Reader in)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException &#123;</div><div class="line">        StringBuffer buf = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            buf = pool.borrowObject();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = in.read(); c != -<span class="number">1</span>; c = in.read()) &#123;</div><div class="line">                buf.append((<span class="keyword">char</span>) c);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> buf.toString();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to borrow buffer from pool"</span> + e.toString());</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                in.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ignored</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != buf) &#123;</div><div class="line">                    pool.returnObject(buf);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ignored</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>明眼人很快就能看出区别，无非就是将StringBuffer的创建方式做了变化，以前是直接new，每次调用都得new一下，现在是通过向pool借。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.BasePooledObjectFactory;</div><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.PooledObject;</div><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.impl.DefaultPooledObject;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferFactory</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">BasePooledObjectFactory</span>&lt;<span class="title">StringBuffer</span>&gt; &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StringBuffer <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Use the default PooledObject implementation.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PooledObject&lt;StringBuffer&gt; <span class="title">wrap</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultPooledObject&lt;StringBuffer&gt;(buffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * When an object is returned to the pool, clear the buffer.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passivateObject</span><span class="params">(PooledObject&lt;StringBuffer&gt; pooledObject)</span> </span>&#123;</div><div class="line">        pooledObject.getObject().setLength(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// for all other methods, the no-op implementation</span></div><div class="line">    <span class="comment">// in BasePooledObjectFactory will suffice</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终只需要将pool传给这个util：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReaderUtil readerUtil = <span class="keyword">new</span> ReaderUtil(<span class="keyword">new</span> GenericObjectPool&lt;StringBuffer&gt;(<span class="keyword">new</span> StringBufferFactory()));</div></pre></td></tr></table></figure>
<p>需要开发关注的仅仅是对象工厂StringBufferFactory的实现，在这个工厂中，主要任务是创建对象，也就是最开始的new对象。把对象的创建工作转移到了工厂里，而不是硬生生的new出来，这也是设计模式的一种体现。</p>
<p>官网给的这个例子非常简洁易懂，很容易快速上手。然而其中还有很多配置参数，能让对象池功能更加丰富。</p>
<h2 id="带配置参数的入门"><a href="#带配置参数的入门" class="headerlink" title="带配置参数的入门"></a>带配置参数的入门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 创建池对象工厂</span></div><div class="line">        PooledObjectFactory&lt;StringBuilder&gt; factory = <span class="keyword">new</span> MyPoolableObjectFactory();</div><div class="line"></div><div class="line">        GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</div><div class="line">        <span class="comment">// 最大空闲数</span></div><div class="line">        poolConfig.setMaxIdle(<span class="number">5</span>);</div><div class="line">        <span class="comment">// 最小空闲数, 池中只有一个空闲对象的时候，池会在创建一个对象，并借出一个对象，从而保证池中最小空闲数为1</span></div><div class="line">        poolConfig.setMinIdle(<span class="number">1</span>);</div><div class="line">        <span class="comment">// 最大池对象总数</span></div><div class="line">        poolConfig.setMaxTotal(<span class="number">20</span>);</div><div class="line">        <span class="comment">// 逐出连接的最小空闲时间 默认1800000毫秒(30分钟)</span></div><div class="line">        poolConfig.setMinEvictableIdleTimeMillis(<span class="number">1800000</span>);</div><div class="line">        <span class="comment">// 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span></div><div class="line">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class="number">1800000</span> * <span class="number">2L</span>);</div><div class="line">        <span class="comment">// 在获取对象的时候检查有效性, 默认false</span></div><div class="line">        poolConfig.setTestOnBorrow(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 在归还对象的时候检查有效性, 默认false</span></div><div class="line">        poolConfig.setTestOnReturn(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 在空闲时检查有效性, 默认false</span></div><div class="line">        poolConfig.setTestWhileIdle(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 最大等待时间， 默认的值为-1，表示无限等待。</span></div><div class="line">        poolConfig.setMaxWaitMillis(<span class="number">6000</span>);</div><div class="line">        <span class="comment">// 是否启用后进先出, 默认true</span></div><div class="line">        poolConfig.setLifo(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true</span></div><div class="line">        poolConfig.setBlockWhenExhausted(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 每次逐出检查时 逐出的最大数目 默认3</span></div><div class="line">        poolConfig.setNumTestsPerEvictionRun(<span class="number">3</span>);</div><div class="line"></div><div class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">40</span>);</div><div class="line">        <span class="comment">// 创建对象池</span></div><div class="line">        <span class="keyword">final</span> GenericObjectPool&lt;StringBuilder&gt; pool = <span class="keyword">new</span> GenericObjectPool&lt;StringBuilder&gt;(factory, poolConfig);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</div><div class="line">            <span class="keyword">int</span> finalI = i;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    StringBuilder resource = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">// 注意，如果对象池没有空余的对象，那么这里会block，可以设置block的超时时间</span></div><div class="line">                        resource = pool.borrowObject();</div><div class="line">                        resource.append(<span class="string">"+"</span>).append(finalI);</div><div class="line">                        System.out.println(resource);</div><div class="line">                        Thread.sleep(<span class="number">2000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="comment">// 申请的资源用完了记得归还，不然其他人要申请时可能就没有资源用了</span></div><div class="line">                        pool.returnObject(resource);</div><div class="line">                        latch.countDown();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        latch.await();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"=====finish===="</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPoolableObjectFactory</span> <span class="keyword">extends</span> <span class="title">BasePooledObjectFactory</span>&lt;<span class="title">StringBuilder</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> PooledObject&lt;StringBuilder&gt; <span class="title">wrap</span><span class="params">(StringBuilder obj)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultPooledObject&lt;&gt;(obj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个demo中给了很多配置参数，注释中写的都很明白。值得注意的是这个demo中输出的结果可能不一致。因为多线程的缘故。</p>
<p>下面是其中的一种输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">+5</div><div class="line">+9</div><div class="line">+8</div><div class="line">+11</div><div class="line">+12</div><div class="line">+10</div><div class="line">+4</div><div class="line">+1</div><div class="line">+3</div><div class="line">+2</div><div class="line">+7</div><div class="line">+13</div><div class="line">+15</div><div class="line">+16</div><div class="line">+6</div><div class="line">+17</div><div class="line">+18</div><div class="line">+19</div><div class="line">+0</div><div class="line">+14</div><div class="line">+3+20</div><div class="line">+9+21</div><div class="line">+11+22</div><div class="line">+4+25</div><div class="line">+2+23</div><div class="line">+5+24</div><div class="line">+1+26</div><div class="line">+0+27</div><div class="line">+14+28</div><div class="line">+9+21+29</div><div class="line">+3+20+30</div><div class="line">+4+25+31</div><div class="line">+1+26+32</div><div class="line">+2+23+33</div><div class="line">+11+22+35</div><div class="line">+5+24+34</div><div class="line">+0+27+36</div><div class="line">+14+28+37</div><div class="line">+3+20+30+38</div><div class="line">+9+21+29+39</div><div class="line">=====finish====</div></pre></td></tr></table></figure>
<p>这里开了40个线程去获取对象，通过使用latch使得所有线程都结束后再结束主线程。<br>这个latch得控制为40，因为每个线程跑完都得减一，直到为0后表示所有线程都结束。这里都latch只是用于控制先后顺序，也就是即使主线程结束了，子线程也能继续执行下去，除非子线程都是守护线程。</p>
<p>由于设置都最大数量为20，因此会有20个线程先获取到stringbuffer对象，然后这里睡眠了2秒钟，模拟一下对这个对象的使用，剩下的20个线程会尝试去“借”对象，但是之前的20个线程还没用完，因此不会马上获取到，这里设置了一个超时时间6s，也就是最多等6s，如果6s后还是没能等到，那就直接抛异常了。因为模拟只使用2s，到期了就直接“还”回去了，因此这里的输出会将之前的也打印出来，虽然归还了，但是却没清理掉它的内容。</p>
<p>仔细来看，带参数的也就不过如此，对于开发者而言也没有什么太复杂的地方，十分容易上手。接下来就拨开云雾，仔细瞧瞧池技术是如何实现的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;池技术&quot;&gt;&lt;a href=&quot;#池技术&quot; class=&quot;headerlink&quot; title=&quot;池技术&quot;&gt;&lt;/a&gt;池技术&lt;/h2&gt;&lt;p&gt;日常搬砖过程中对池技术的接触很多，最具代表的是连接池。&lt;br&gt;连接池也是一种池技术，本质上都是对象池。commons-pool是ap
    
    </summary>
    
      <category term="pool 笔记" scheme="http://www.wei-dong.top/categories/pool-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="源码" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="apache" scheme="http://www.wei-dong.top/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>写在2020</title>
    <link href="http://www.wei-dong.top/2020/01/01/%E5%86%99%E5%9C%A82020/"/>
    <id>http://www.wei-dong.top/2020/01/01/写在2020/</id>
    <published>2020-01-01T03:33:18.000Z</published>
    <updated>2020-01-01T06:24:24.835Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2020第一天。</p>
<h2 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h2><p>此时的我坐在电脑前对着屏幕发呆，仔细回忆着发生在2019值得纪念的事情。最值得被纪念的还得是我这一年的成长吧。</p>
<p>当然这个成长只能算是工作上的。自从2018年来到YJ后，回想起之前的工作经历可以说是浪费时间。刚来那时候面对新环境我真的是一个dd，d中d。对于工作中的基本操作都显得十分笨拙，那时候我还是有两年的工作经验呢。在试用期的几个月内，我真的十分崩溃。在完成第一个需求的时候痛苦不堪。有个坑b的产品，加上对接的东西又很多，老代码写得和狗屎一样，这些对我来说无疑是困难。毕竟之前从未在这么大规模的研发团队中工作过，团队的协作与沟通俨然成为一道阻碍我前行的屏障。说实话代码的难度倒是没难倒我，只是对于那么大的团队协作的工作方式觉得很困惑。曾经一度想直接和经理说干不下去了太难受了我不搞了，但最后还是坚持下来了，终于熬过试用期了。还记得那时候压力太大和父亲通话，他劝我说搞不了就别搞了，机会多的是干嘛和自己过不去呢。那时候我反驳了他没听他的，我就是想证明一下自己到底能不能扛得住这些压力。因为我之前之前的日子里过得实在是太安逸了，没有任何压力，每天都不知道自己做了些什么，甚至还有点自闭。度过那段难受的时光之后我逐渐轻车熟路，慢慢知道了一些常见的套路。这得感谢我的直接领导文颗，他是一个很出色的95后，情商很高，处理人际关系很有一套。有时候看他做事方式并不像一个95的年轻人，成熟的不像95后。后来慢慢负责了一块单独的业务，那时候我才正真体会到了价值和责任，也慢慢学会了沟通的技巧，但还是不知道怎么怼人。相比之前，2019在YJ的这段时间确实让我经历了许多，至少能抗住压力了。</p>
<p>再值得纪念的是和天一兄弟的‘云创业’。那时候他提出做自媒体的想法，然后招集几个小伙伴一起出谋划策实施落地方案。我记得当时两周一次会议，每次会议一个小时，轮岗主持人制。刚开始积极性还是很高的，后来就没有了太多热情，最后坚持了一两个月就宣布失败了。不过还是学到很多实用的东西，比如会议的控场，主题的把控等很多小技巧。不得不说创业其实还是很困难的。目前天一兄弟的博客也不更新了，可能是时间都用来陪伴女朋友了吧。</p>
<p>记得五一的时候回家过一躺，一个老朋友结婚去参加了婚礼，也是我人生中第一次参加别人的婚礼。男孩女孩都是老同学了，他们经历太多最后还是走到一起。在婚礼中有那么一瞬间真的很感动，甚至想哭。因为婚礼的缘故也遇到了很多老同学老朋友，神奇的是那么多年没见再次相遇居然还没有任何生疏的感觉，一切好像昨天才见面一样熟悉。曾经以为有些人一辈子都不会再见面了，现在却真实的站在我面前。</p>
<p>再谈谈2019哪些做了哪些没做吧。这一年读几本书，正真感兴趣的不是太多。</p>
<ul>
<li>《激荡三十年（上）》</li>
<li>《激荡十年 水大鱼大》</li>
<li>《浪潮之巅》</li>
<li>《未来简史》</li>
<li>《褚时健传》</li>
<li>《淘宝技术这十年》</li>
<li>《我们仨》 </li>
<li>《读懂财经新闻的第一本书》</li>
</ul>
<p>总的来说对那些带有历史变革背景的作品比较感兴趣。对非技术类的文学作品还是缺少耐心。技术类的书籍看得多，但大多都没看完在那里吃灰，比如《CSAPP》、《TCP/IP详解》等。</p>
<p>这一年专业技术水平没有太多的提升，最多的尝试是读源码，但是正真收获的却没有太多。有个阿里P7大佬写了个开源的RPC框架我是真的一点不漏的看完了，反反复复地看，还写出了几篇解读文章。值得高兴的是被他收录到他github上去了。那时候真的有一种付出就有回报的感觉，很自豪。为什么读不下去源码，因为做这种事情时间周期久而且得到的反馈太慢了，现在都讲究短平快，及时满足感，像这种起码得花好几天才能有回报的事情做起来太吃力了。还有一个根本原因：你不够热爱！突然想起最近和一个B站插画up主聊天，他说有时候下班还会去画画，因为喜欢。我反思了一下，我下班后还会打开电脑写代码么？</p>
<p>最近值得纪念的事情就是公司裁员，这让原本和谐融洽的气氛变得十分紧张。毕竟走了近一半的同学，还是挺难过的。</p>
<p>这一年的兴趣爱好似乎依旧没有培养起来，用四个字总结就是有心无力。总是期待着成为XXX样的人，一直在内心幻想着，却没有正真去付出时间和精力。还是源自内心的恐惧，害怕失败，害怕没有结果，害怕中途放弃…</p>
<p>这一年我没有成为有趣的人，没认识新的朋友，没去过有趣的地方。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>对于2020我不想立太多flag。我希望找到自己的热爱，付出和实践；直面恐惧，发现生活的乐趣，做个内心世界丰富且强大的人。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>2019已经过去了，我还是很怀念它！<br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/jim-carry.jpg?raw=true" alt="2020"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2020第一天。&lt;/p&gt;
&lt;h2 id=&quot;回首&quot;&gt;&lt;a href=&quot;#回首&quot; class=&quot;headerlink&quot; title=&quot;回首&quot;&gt;&lt;/a&gt;回首&lt;/h2&gt;&lt;p&gt;此时的我坐在电脑前对着屏幕发呆，仔细回忆着发生在2019值得纪念的事情。最值得被纪念的还得是我这一年的
    
    </summary>
    
      <category term="beyond coding" scheme="http://www.wei-dong.top/categories/beyond-coding/"/>
    
    
      <category term="生活" scheme="http://www.wei-dong.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>浮生一记</title>
    <link href="http://www.wei-dong.top/2019/11/14/%E6%B5%AE%E7%94%9F%E4%B8%80%E8%AE%B0/"/>
    <id>http://www.wei-dong.top/2019/11/14/浮生一记/</id>
    <published>2019-11-14T08:33:18.000Z</published>
    <updated>2019-11-24T10:08:27.722Z</updated>
    
    <content type="html"><![CDATA[<p>有些日子没有更新了。最近这段日子也不算太忙，因为双11的连续上班两周，总是觉得似乎没有休息好。</p>
<p>虽说不忙，但是也有不开心的事情。整个行业的不景气，许多公司在优化，我们公司也不例外。前段时间领导突然请吃饭，我就知道事情没那么简单。果不其然在饭桌上公布优化人员的消息，气氛变得凝重起来。但是早说要比晚说要好，毕竟留下了更多的心理缓冲时间。饭桌上比我几岁的领导没控制住情绪，失声哭了起来。换为思考一下，也能理解他这种情绪。当时团队从4-5个人扩大到11个人，这一路走来还是不容易的，现在上层说优化就优化，作为领导却没办法争取点什么。对我而言也是有点难过的，因为我的那个小team也是很不错的，要走一半也是很不舍得的。</p>
<p>在此之前我们的团建经费都下发到两个小team。我所在的小team没有好的想法，就直接交给表哥他们那边了。他们决定一起去自驾游。随着双11连续的两周上班结束，我们如期进行了我们的小trip。</p>
<p>这次的目的地是大鹏，离市区差不多近100公里。一位同事自己有车，此外我们还租了一辆车。在一个阳光明媚的早晨我们出发了。<br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0389.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0362.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0404.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0410.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0376.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0411.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0377.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0363.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0405.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0388.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0375.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0407.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0361.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0406.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0360.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0374.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0412.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0358.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0370.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0364.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0402.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0365.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0403.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0417.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0371.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0359.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0398.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0401.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0367.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0373.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0372.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0414.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0366.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0399.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0380.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0394.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0425.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0357.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0419.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0418.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0356.jpg?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0424.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0395.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0381.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0397.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0383.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0368.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0369.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0382.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0396.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0392.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0379.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0422.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0378.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0393.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0385.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0391.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0408.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0409.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0390.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0384.JPG?raw=true" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些日子没有更新了。最近这段日子也不算太忙，因为双11的连续上班两周，总是觉得似乎没有休息好。&lt;/p&gt;
&lt;p&gt;虽说不忙，但是也有不开心的事情。整个行业的不景气，许多公司在优化，我们公司也不例外。前段时间领导突然请吃饭，我就知道事情没那么简单。果不其然在饭桌上公布优化人员的消
    
    </summary>
    
      <category term="玩" scheme="http://www.wei-dong.top/categories/%E7%8E%A9/"/>
    
    
      <category term="生活" scheme="http://www.wei-dong.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写作</title>
    <link href="http://www.wei-dong.top/2019/04/20/why_writting/"/>
    <id>http://www.wei-dong.top/2019/04/20/why_writting/</id>
    <published>2019-04-20T08:14:23.000Z</published>
    <updated>2019-04-20T08:47:04.358Z</updated>
    
    <content type="html"><![CDATA[<p>有一天，天一同学突然问我一个问题：你的博客是不打算更新了么？一时间我不知道怎么回答，因为我也不确定回答是或者否。</p>
<p>然后接下来好几天都在想这个问题。即使天一同学不提到，我也意识到很久没有更新文章了。然后回想一下，自从换了工作到云集工作后就再也没有更新博客了。就连github也没怎么更新过。原先买的3年期的域名，本打算在这段时间给自己留下点什么，仔细翻了翻以往写的东西，可能真的要半途而废了。</p>
<p>拿半途而废来形容是不准确的，毕竟这个域名还没到期，仅仅废了一半。那就好好分析一下为什么没想到去写文章了，总结一个字–懒！现在工作还是有压力的，业余时间都放松玩去了，压根没想到要写点什么记录一下。其次就是对技术的热爱没有那么强烈了。以前看到一些比较厉害的源码总是有那么一点小激动和兴奋，总想着去学习一下记录这个过程。而现在这种想法不是那么强烈，想着到时候需要的时候再来研究。那就不得不说，现在对什么兴趣比较强烈。现在对绘画、书法之类的比较感兴趣。空闲时间都会去b站看看，总想着有一天我也会这些东西，而不仅仅只会写代码。我想这种想法不仅仅我一个人有过，很多人都想过。同时也会关注一下那些技术博主的关于编码之外的文章，比方说生活琐事之类的。大概是因为自己从事这个行业时间久了，内心世界十分贫瘠，总是一些枯燥的代码。长久以来，我觉得技术之中也存在着某种艺术以及设计哲学，因此更加想去找到这两者之间的联系。</p>
<p>除了懒，还有一个比较重要的原因。觉得自己的语言组织能力不足，不足以将一件事情表达清楚，或者文笔不够好，担心写出来的东西太low，入不了眼。因此就更不愿意写，如此往复恶性循环。但是这个理由是站不住脚的。自己写的文章仅仅是用来取悦自己而不是取悦他人，干嘛有这么多心理负担，又不是上学那会让写个作文还得打分。因此还是一个字懒导致的。</p>
<p>还发现一个现象，随着年龄的增加，越来越多的人都不愿意在社交网络上表达自己了。我曾记得以前总是在微博盆友圈上发表一些想法感受，而现在却很少了。说不清为什么，大致觉得生活无非就是这样，稀疏平常的事情也没必要去抱怨或者去“晒”吧。或者是说成年人的世界比较复杂？</p>
<p>通篇下来，都是在讲我为什么没继续写作了，但丝毫没说为什么要写作。</p>
<p>为了留下点什么，为了不被忘记！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一天，天一同学突然问我一个问题：你的博客是不打算更新了么？一时间我不知道怎么回答，因为我也不确定回答是或者否。&lt;/p&gt;
&lt;p&gt;然后接下来好几天都在想这个问题。即使天一同学不提到，我也意识到很久没有更新文章了。然后回想一下，自从换了工作到云集工作后就再也没有更新博客了。就连
    
    </summary>
    
      <category term="写作" scheme="http://www.wei-dong.top/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="编码之外" scheme="http://www.wei-dong.top/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96/"/>
    
  </entry>
  
  <entry>
    <title>Netty中的线程模型之OIO</title>
    <link href="http://www.wei-dong.top/2018/09/12/Netty%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B9%8BOIO/"/>
    <id>http://www.wei-dong.top/2018/09/12/Netty中的线程模型之OIO/</id>
    <published>2018-09-12T09:17:23.000Z</published>
    <updated>2018-09-12T09:07:20.764Z</updated>
    
    <content type="html"><![CDATA[<p>和高性能NIO相比，个人认为OIO的实现相对要简单一点，选择这个难度稍微低一点的实现来肯对目前的菜鸡我而言更现实。</p>
<p>本质上而言，eventloopgroup就是线程池。</p>
<p><img src="http://7xsfwn.com1.z0.glb.clouddn.com/OioEventLoopGroup.png" alt="image"></p>
<p>Netty针对JDK的实现做了进一步的加强。</p>
<p>对于OIO的第一反应是「阻塞」，「性能差」，「耗资源」。事实上确实如此，但为什么还要写一篇文章（笔记）来对它进行描述呢？在之前，我以为Netty并没有提供OIO的实现，天真的认为Netty仅仅是对NIO进行了封装。直到某一天使用到了OIO，想将OIO的线程模型和Netty中的实现类似：一个线程负责连接，别的线程负责IO。想了许久没有下文，机缘巧合看到了Netty的文档，其中有对OIO的封装，恰好和我心中想的一模一样，而且对外提供的API不变。这种抽象设计让我想深入其中，看看到底是如何做到的。我想借鉴其中的设计来实现一个比较简单对OIO的封装。</p>
<blockquote>
<p>EventLoopGroup which is used to handle OIO Channel’s. Each Channel will be handled by its own EventLoop to not block others.</p>
</blockquote>
<p>文档中的解释很简单，EventLoopGroup用来处理连接，每个连接由它自己的EventLoop处理。</p>
<p>这段解释不禁联想到了针对OIO的编程：每个连接由新开的线程处理，有多少个连接就有多少个线程。这里的Channel就是连接的抽象，EventLoop可以理解为线程。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">OioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(maxChannels, threadFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ThreadPerChannelEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(maxChannels, <span class="keyword">new</span> ThreadPerTaskExecutor(threadFactory), args);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">        threadFactory.newThread(command).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器中两个参数，maxChannels为最大连接数。注意，这个是比较讲究的，在Netty线程模型中有boss和worker线程之分。如果只指定一个，也就是boss就是worker那么这个值如果为1那么任何客户端无法连进来，如果为2则只允许1个客户端连进来，依次类推。默认为0，表示允许无限多客户端接入（理论上）。当有worker的时候，boss的maxChannels指定多少无所谓，worker中的maxChannels值为多少就意味着允许多少客户端接入，同理0代表无限多。第二个参数为线程工厂，默认使用的是JDK的默认实现：Executors.defaultThreadFactory()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ThreadPerChannelEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, Executor executor, Object... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxChannels &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</div><div class="line">                <span class="string">"maxChannels: %d (expected: &gt;= 0)"</span>, maxChannels));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"executor"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</div><div class="line">        childArgs = EmptyArrays.EMPTY_OBJECTS;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        childArgs = args.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.maxChannels = maxChannels;</div><div class="line">    <span class="keyword">this</span>.executor = executor;</div><div class="line"></div><div class="line">    tooManyChannels = ThrowableUtil.unknownStackTrace(</div><div class="line">            <span class="keyword">new</span> ChannelException(<span class="string">"too many channels (max: "</span> + maxChannels + <span class="string">')'</span>),</div><div class="line">            ThreadPerChannelEventLoopGroup.class, <span class="string">"nextChild()"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的一些成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerChannelEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">AbstractEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] childArgs;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxChannels;</div><div class="line">    <span class="comment">// 任务执行器</span></div><div class="line">    <span class="keyword">final</span> Executor executor;</div><div class="line">    <span class="comment">// 活跃的线程集合</span></div><div class="line">    <span class="keyword">final</span> Set&lt;EventLoop&gt; activeChildren =</div><div class="line">            Collections.newSetFromMap(PlatformDependent.&lt;EventLoop, Boolean&gt;newConcurrentHashMap());</div><div class="line">    <span class="comment">// 空闲的线程集合</span></div><div class="line">    <span class="keyword">final</span> Queue&lt;EventLoop&gt; idleChildren = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;EventLoop&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelException tooManyChannels;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shuttingDown;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Promise&lt;?&gt; terminationFuture = <span class="keyword">new</span> DefaultPromise&lt;Void&gt;(GlobalEventExecutor.INSTANCE);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureListener&lt;Object&gt; childTerminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="comment">// Inefficient, but works.</span></div><div class="line">            <span class="keyword">if</span> (isTerminated()) &#123;</div><div class="line">                terminationFuture.trySuccess(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>EventLoopGroup的初始化就这样结束了。但是要探索其中的工作机制还得从一个Server 的启动开始。</p>
<h3 id="ServerBootstrap的启动"><a href="#ServerBootstrap的启动" class="headerlink" title="ServerBootstrap的启动"></a>ServerBootstrap的启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></div><div class="line">        b.group(bossGroup, workerGroup)</div><div class="line">         .channel(OioServerSocketChannel.class) <span class="comment">// (3)</span></div><div class="line">         .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></div><div class="line">             <span class="meta">@Override</span></div><div class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                 ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</div><div class="line">             &#125;</div><div class="line">         &#125;)</div><div class="line">         .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></div><div class="line">         .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></div><div class="line">    </div><div class="line">        <span class="comment">// Bind and start to accept incoming connections.</span></div><div class="line">        ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></div><div class="line">    </div><div class="line">        <span class="comment">// Wait until the server socket is closed.</span></div><div class="line">        <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></div><div class="line">        <span class="comment">// shut down your server.</span></div><div class="line">        f.channel().closeFuture().sync();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        workerGroup.shutdownGracefully();</div><div class="line">        bossGroup.shutdownGracefully();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最核心的是bind方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    validate();</div><div class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> doBind(localAddress);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">	 <span class="comment">// 核心是regFuture的获取，有了这个后面一切都好说</span></div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> regFuture;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</div><div class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></div><div class="line">        ChannelPromise promise = channel.newPromise();</div><div class="line">        doBind0(regFuture, channel, localAddress, promise);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></div><div class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</div><div class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Throwable cause = future.cause();</div><div class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></div><div class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></div><div class="line">                    promise.setFailure(cause);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></div><div class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></div><div class="line">                    promise.registered();</div><div class="line"></div><div class="line">                    doBind0(regFuture, channel, localAddress, promise);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</div><div class="line">    Channel channel = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    	 <span class="comment">// 实例化OioServerSocketChannel</span></div><div class="line">        channel = channelFactory.newChannel();</div><div class="line">        init(channel);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 核心是这段逻辑config().group()返回的就是我们设置的boss：OioEventLoopGroup</span></div><div class="line">    ChannelFuture regFuture = config().group().register(channel);</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</div><div class="line">            channel.close();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> regFuture;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>忽略掉无关的逻辑（实在是很复杂），关键点到了这个OioEventLoopGroup的register方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channel"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        EventLoop l = nextChild();</div><div class="line">        <span class="comment">// 将channel包装了一下--&gt; DefaultChannelPromise</span></div><div class="line">        <span class="keyword">return</span> l.register(<span class="keyword">new</span> DefaultChannelPromise(channel, l));</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailedChannelFuture(channel, GlobalEventExecutor.INSTANCE, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个Channel就是OioServerSocketChannel，对应在OIO原生API中就是ServerSocket。根据代码的字面意可以这样解释：将OioServerSocketChannel注册到EventLoopGroup。</p>
<p>最终是通过EventLoop去注册的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> EventLoop <span class="title">nextChild</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shuttingDown) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"shutting down"</span>);</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 从空闲队列中取EventLoop</span></div><div class="line">    EventLoop loop = idleChildren.poll();</div><div class="line">    <span class="keyword">if</span> (loop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (maxChannels &gt; <span class="number">0</span> &amp;&amp; activeChildren.size() &gt;= maxChannels) &#123;</div><div class="line">            <span class="keyword">throw</span> tooManyChannels;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有就新建一个 参数没用</span></div><div class="line">        loop = newChild(childArgs);</div><div class="line">        loop.terminationFuture().addListener(childTerminationListener);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 新建的放到活跃队列中</span></div><div class="line">    activeChildren.add(loop);</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 新建的一个EventLoop为ThreadPerChannelEventLoop实例，参数为EventLoopGroup 也就是说这个EventLoop说由哪个group产生的</span></div><div class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(@SuppressWarnings(<span class="string">"UnusedParameters"</span>)</span> Object... args) <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPerChannelEventLoop(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么一来，真正的注册逻辑就交给了ThreadPerChannelEventLoop去实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPerChannelEventLoop</span><span class="params">(ThreadPerChannelEventLoopGroup parent)</span> </span>&#123;</div><div class="line">	 <span class="comment">// 注意 这里的parent.executor为ThreadPerTaskExecutor实例</span></div><div class="line">    <span class="keyword">super</span>(parent, parent.executor, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.register(promise).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</div><div class="line">                ch = future.channel();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                deregister();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 父类的</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>终于要看到希望了，这一层一层的调用实在很繁琐，会把人看晕，建议多看几遍就不晕了😂。</p>
<p>promise.channel()返回的就是我们设置的OioServerSocketChannel。而unsafe方法则是继承自它的「太爷爷」。<br>其具体实现则是由它「爷爷」来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> AbstractUnsafe <span class="title">newUnsafe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultOioUnsafe();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这是它的一个内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultOioUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractUnsafe</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> SocketAddress remoteAddress,</div><div class="line">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">            doConnect(remoteAddress, localAddress);</div><div class="line"></div><div class="line">            <span class="comment">// Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel.</span></div><div class="line">            <span class="comment">// We still need to ensure we call fireChannelActive() in this case.</span></div><div class="line">            <span class="keyword">boolean</span> active = isActive();</div><div class="line"></div><div class="line">            safeSetSuccess(promise);</div><div class="line">            <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</div><div class="line">                pipeline().fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            safeSetFailure(promise, annotateConnectException(t, remoteAddress));</div><div class="line">            closeIfClosed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然快看到希望的曙光了，但是眼前却依旧是一片黑暗。😫！！！亲爱的register你到底在哪里？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractUnsafe 也是内部类 tmd netty真会折腾</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</div><div class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</div><div class="line">        promise.setFailure(</div><div class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</div><div class="line">	 <span class="comment">// 关键点 其他不管 这里一定是最后一步了</span></div><div class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</div><div class="line">        register0(promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        	  <span class="comment">// 这里大有玄机</span></div><div class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    register0(promise);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</div><div class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</div><div class="line">            closeForcibly();</div><div class="line">            closeFuture.setClosed();</div><div class="line">            safeSetFailure(promise, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这段代码看不懂 先放这个地方 看懂了再来解读</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></div><div class="line">        <span class="comment">// call was outside of the eventLoop</span></div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</div><div class="line">        <span class="comment">// OIO版本中什么都不做</span></div><div class="line">        doRegister();</div><div class="line">        neverRegistered = <span class="keyword">false</span>;</div><div class="line">        registered = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></div><div class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></div><div class="line">        pipeline.invokeHandlerAddedIfNeeded();</div><div class="line"></div><div class="line">        safeSetSuccess(promise);</div><div class="line">        pipeline.fireChannelRegistered();</div><div class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></div><div class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></div><div class="line">        <span class="keyword">if</span> (isActive()) &#123;</div><div class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</div><div class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></div><div class="line">                <span class="comment">// again so that we process inbound data.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></div><div class="line">                beginRead();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></div><div class="line">        closeForcibly();</div><div class="line">        closeFuture.setClosed();</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>eventLoop.execute方法中不仅仅只执行一个Runnable就完了，因为Netty这个狗逼没有使用默认实现 而是自己实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SingleThreadEventExecutor的实现</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</div><div class="line">    <span class="comment">// 这个task就是register0的具体逻辑 这个逻辑暂时不管（因为看不懂😂）</span></div><div class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</div><div class="line">    	  <span class="comment">// 放到队列中</span></div><div class="line">        addTask(task);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    	 <span class="comment">// 终于露出马脚了 开线程了吧</span></div><div class="line">        startThread();</div><div class="line">        addTask(task);</div><div class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class="line">            reject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class="line">        wakeup(inEventLoop);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 开个线程都玩这么花</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</div><div class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                doStartThread();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</div><div class="line">                STATE_UPDATER.set(<span class="keyword">this</span>, ST_NOT_STARTED);</div><div class="line">                PlatformDependent.throwException(cause);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 这个executor就是ThreadPerTaskExecutor </span></div><div class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            thread = Thread.currentThread();</div><div class="line">            <span class="keyword">if</span> (interrupted) &#123;</div><div class="line">                thread.interrupt();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">            updateLastExecutionTime();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            		<span class="comment">// 这个狗逼玩的是真花 还去调别人的run 实际上是ThreadPerChannelEventLoop的实现</span></div><div class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</div><div class="line">                success = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            	<span class="comment">// 太多 不看了          </span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ThreadPerChannelEventLoop</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	 <span class="comment">// 死循环</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">    	 <span class="comment">// 这里的task就是AbstractUnsafe#register0的逻辑 当然也有可能是其他的</span></div><div class="line">        Runnable task = takeTask();</div><div class="line">        <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</div><div class="line">            task.run();</div><div class="line">            updateLastExecutionTime();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Channel ch = <span class="keyword">this</span>.ch;</div><div class="line">        <span class="keyword">if</span> (isShuttingDown()) &#123;</div><div class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</div><div class="line">                ch.unsafe().close(ch.unsafe().voidPromise());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (confirmShutdown()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Handle deregistration</span></div><div class="line">                <span class="keyword">if</span> (!ch.isRegistered()) &#123;</div><div class="line">                    runAllTasks();</div><div class="line">                    deregister();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整了这么多，依旧没有搞明白这个register到底在做什么。但是明白了一件事：找到了启动入口。</p>
<h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><p>在原生OIO网络编程中，实现一个服务器需要做这几个步骤：</p>
<ul>
<li>创建ServerSocket对象绑定监听端口。</li>
<li>通过accept()方法监听客户端的请求。</li>
<li>建立连接后，通过输入输出流读取客户端发送的请求信息。</li>
<li>通过输出流向客户端发送请求信息。</li>
<li>关闭相关资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ServerSocket server=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        server=<span class="keyword">new</span> ServerSocket(<span class="number">5209</span>);</div><div class="line">        <span class="comment">//b)指定绑定的端口，并监听此端口。</span></div><div class="line">        System.out.println(<span class="string">"服务器启动成功"</span>);</div><div class="line">        <span class="comment">//创建一个ServerSocket在端口5209监听客户请求</span></div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"没有启动监听："</span>+e);</div><div class="line">            <span class="comment">//出错，打印出错信息</span></div><div class="line">    &#125;</div><div class="line">    Socket socket=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        socket=server.accept();</div><div class="line">        <span class="comment">//2、调用accept()方法开始监听，等待客户端的连接 </span></div><div class="line">        <span class="comment">//使用accept()阻塞等待客户请求，有客户</span></div><div class="line">        <span class="comment">//请求到来则产生一个Socket对象，并继续执行</span></div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">        System.out.println(<span class="string">"Error."</span>+e);</div><div class="line">        <span class="comment">//出错，打印出错信息</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在Netty中的实现基本如此，只不过代码结构比较复杂罢了。这段代码在Netty中的的实现在OioServerSocketChannel中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    socket.bind(localAddress, config.getBacklog());</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (socket.isClosed()) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Socket s = socket.accept();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            buf.add(<span class="keyword">new</span> OioSocketChannel(<span class="keyword">this</span>, s));</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                s.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</div><div class="line">                logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">        <span class="comment">// Expected</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先绑定端口，再接受连接。这个接受连接是伪非阻塞的。因为用于连接的线程只有一个，没有客户端连进来的时候不能将其阻塞调。客户端连进来了就将这个「连接」交给别的线程处理，每个连接对应一个线程。这样就做到了连接和io处理不冲突。</p>
<p>当然，最后的执行肯定是到这一步，但是具体的执行调用过程可称得上困难重重。仔细回头看这个register0的处理逻辑，发现好像仅仅启动了一个线程，用于不断从队列中取任务执行的死循环而已。似乎没有直接表现出像绑定端口，接受连接的迹象。不能慌，这个老b隐藏得很深。回到最开始的地方，这个仅仅是register，姑且就到这里，先继续往下看，看到底又有什么新发现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> regFuture;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</div><div class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></div><div class="line">        ChannelPromise promise = channel.newPromise();</div><div class="line">        doBind0(regFuture, channel, localAddress, promise);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// 省略。。。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>initAndRegister方法经历千山万水终于启动了一个线程，目的就是返回一个ChannelFuture，先不管这个ChannelFuture到底是什么鬼，先将其理解为JDK中的Future的增强实现。一旦这个Future完成了，调用doBind0:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</div><div class="line">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></div><div class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.</span></div><div class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</div><div class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                promise.setFailure(regFuture.cause());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吧，这个鬼又向队列中添加了一个任务。这个任务核心就是去绑定。想都不用想，这个绑定一定是AbstractChannel中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// pipeline的bind有是其默认实现类中的子类TailContext中的实现</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 省略。。。</span></div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeBind(localAddress, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeBind(localAddress, promise);</div><div class="line">            &#125;</div><div class="line">        &#125;, promise, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后的bind是最终的核心逻辑。先找OutboundContext：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        ctx = ctx.prev;</div><div class="line">    &#125; <span class="keyword">while</span> (!ctx.outbound);</div><div class="line">    <span class="keyword">return</span> ctx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，调用这个方法的是tail，关于pipeline的结构有必要了解一下。<img src="https://segmentfault.com/img/bVEPxn?w=2387&amp;h=584" alt="image"></p>
<p>我们在这个Server初始化的时候添加了handler，比如LoggingHandler等。这些handler都会被添加到tail和head之间。即使你不添加任何handler，netty也会把自己内部的handler添加进去。handler又分为in和out，分别代表入站和出站。这段代码就是找出站的(只有out的才有bind方法)，一直向head方向找（废话，自己都是tail了只能往前找，后面没有了）。找到一个就算数，直接返回这个context。接着就是调用invokeBind方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyOutboundHandlerException(t, promise);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bind(localAddress, promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终的bind方法在if分支中。具体的执行逻辑为实现了out的handler，例如LoggingHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isEnabled(internalLevel)) &#123;</div><div class="line">        logger.log(internalLevel, format(ctx, <span class="string">"BIND"</span>, localAddress));</div><div class="line">    &#125;</div><div class="line">    ctx.bind(localAddress, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然这个handler仅仅只是来打印log的，完事之后又交给父类去执行。而父类依然是那段。因为之前是找到第一个实现out的handler就算数，这里又回到了这个pipeline中，继续往前找，最终会找到head（head不仅是out而且还是in，就是这么屌）。最终调用的是headcontext中的bind，而它的bind却是使用的是unsafe的bind：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></div><div class="line">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</div><div class="line">        <span class="keyword">throws</span> Exception &#123;</div><div class="line">    unsafe.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/576</span></div><div class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</div><div class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</div><div class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</div><div class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</div><div class="line">        <span class="comment">// Warn a user about the fact that a non-root user can't receive a</span></div><div class="line">        <span class="comment">// broadcast packet on *nix if the socket is bound on non-wildcard address.</span></div><div class="line">        logger.warn(</div><div class="line">                <span class="string">"A non-root user can't receive a broadcast packet if the socket "</span> +</div><div class="line">                <span class="string">"is not bound to a wildcard address; binding to a non-wildcard "</span> +</div><div class="line">                <span class="string">"address ("</span> + localAddress + <span class="string">") anyway as requested."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这个逻辑是有意思的 返回值为 !socket.isClosed()&amp;&amp; socket.isBound()</span></div><div class="line">    <span class="comment">// 没关且绑定了才为true 这里一定为false 因为肯定没绑定</span></div><div class="line">    <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    	 <span class="comment">// 看到这行代码就够了 其他不管</span></div><div class="line">        doBind(localAddress);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">        closeIfClosed();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 绑定完了isActive()肯定为true</span></div><div class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</div><div class="line">        <span class="comment">// 这段代码也得看</span></div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    safeSetSuccess(promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到doBind就知道怎么回事了，这就是之前所说的OioServerSocketChannel的doBind。终于完成了第一步：绑定端口。<br>接下来就是监听客户端连接，在invokeLater中将其实现了，一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeLater</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        eventLoop().execute(task);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">        logger.warn(<span class="string">"Can't invoke task later as EventLoop rejected it"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，依旧把这个任务放到线程中去执行了。这个任务到底是什么，很重要。代码中只给了一段<code>pipeline.fireChannelActive()</code>.看看具体实现吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext.invokeChannelActive(head);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// context为head 又交给了EventExecutor去执行</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeChannelActive();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用的是head的实现</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelInboundHandler) handler()).channelActive(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyHandlerException(t);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fireChannelActive();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// head的channelActive 这里的套路和之前的一样，先调用父类的 继续找pipeline中的handler只不过方向相反（从head到tail） 依次类推 如果某个handler不去调用ctx了，那么事件就到此为止不会传递下去了</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ctx.fireChannelActive();</div><div class="line">	 <span class="comment">// 这段代码是重点</span></div><div class="line">    readIfIsAutoRead();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 父类的fireChannelActive</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    invokeChannelActive(findContextInbound());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，一定一定是要做我们在OIO原生编程中的第二步了：接受连接了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</div><div class="line">        channel.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// OioSocketChannel的read 实际上是父类的</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    pipeline.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用的是pipeline的read</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    tail.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// tail的read</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeRead();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Runnable task = next.invokeReadTask;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">            next.invokeReadTask = task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    next.invokeRead();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        executor.execute(task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里我又打脸了，还有这么多层的调用！但是不要慌，因为逻辑是类似的。都是在pipeline这条链上找handler来调用，爱调不调的思想。这里的顺序是从tail到head。如果这个链中有哪个不长眼的没有将事件传递下去，那么最终就到不了head。正常情况下是一定要到head的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    unsafe.beginRead();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 什么都得考unsafe</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line">    <span class="keyword">if</span> (!isActive()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doBeginRead();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireExceptionCaught(e);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        close(voidPromise());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 最终还是将其丢给了eventLoop去执行 readTask是核心</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (readPending) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    readPending = <span class="keyword">true</span>;</div><div class="line">    eventLoop().execute(readTask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个readTask先将其定义好了，没有直接使用匿名内部类。一股清流啊！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable readTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        doRead();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个doRead有2个实现AbstractOioByteChannel和AbstractOioMessageChannel看名字都能知道区别，一个是读字节一个是读对象。最大的区别是OioByteStreamChannel是OioSocketChannel的父类而AbstractOioMessageChannel是OioServerSocketChannel的父类。这里使用的实现不用说也知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 太多省略不看</span></div><div class="line">    <span class="keyword">final</span> ChannelConfig config = config();</div><div class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</div><div class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class="line">    allocHandle.reset(config);</div><div class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</div><div class="line">    Throwable exception = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// Perform a read. 关键点</span></div><div class="line">            <span class="keyword">int</span> localRead = doReadMessages(readBuf);</div><div class="line">            <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</div><div class="line">                closed = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            allocHandle.incMessagesRead(localRead);</div><div class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        exception = t;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不看</span></div><div class="line">    <span class="comment">// 这里还省略了一个关键代码 一直想不明白的一个问题是这段代码是怎么能够一只run下去的</span></div><div class="line">    <span class="comment">// 因为eventloop中有个死循环，取的是任务队列中的任务去执行的，取的方式是take，也就是取出来就移除掉</span></div><div class="line">    <span class="comment">// 而下面这段代码则是将其继续加到任务队列中，只要没读到数据就继续将这个task添加到任务队列 这样就能一直死循环下去</span></div><div class="line">    <span class="comment">// Reading 0 bytes could mean there is a SocketTimeout and no data was actually read, so we</span></div><div class="line">    <span class="comment">// should execute read() again because no data may have been read.</span></div><div class="line">    read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终这个doReadMessages就是OioServerSocketChannel的实现。将监听客户端连接也放到了任务队列中，让线程去轮询。至于怎么去把消息读出来以及这个过程是怎样的，这是以后的事情。因为这次基本上将整个netty的核心组件都接触到了。接下来的源码解读会稍微轻松点。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Netty真屌，不接受反驳😂！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和高性能NIO相比，个人认为OIO的实现相对要简单一点，选择这个难度稍微低一点的实现来肯对目前的菜鸡我而言更现实。&lt;/p&gt;
&lt;p&gt;本质上而言，eventloopgroup就是线程池。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsfwn.com1.z0.glb.cl
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Netty" scheme="http://www.wei-dong.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(四)</title>
    <link href="http://www.wei-dong.top/2018/08/31/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E5%9B%9B)/"/>
    <id>http://www.wei-dong.top/2018/08/31/一起学RPC(四)/</id>
    <published>2018-08-31T08:17:23.000Z</published>
    <updated>2018-08-31T08:26:41.343Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中讲到了provider中针对consumer的请求消息封装<code>MessageTask</code>的部分细节。留下了最核心的处理消息的细节<code>process</code>方法没有说。</p>
<p>在继续对所谓的核心逻辑梳理之前，先整体的捋一捋之前文章的行文思路。</p>
<p>consumer的client发送一个请求报文，这个报文包含header头以及请求体，通过provider的解码器将其进行解码，解码后的对象为<code>JRequestPayload</code>或者<code>JResponsePayload</code>。这些解码后的对象还不属于业务层的，仅仅只是对数据包进行了第一层的封装。解码完成后，经过第一层包装的消息进入具体处理消息的handler，而这个handler并不允许处理太多业务逻辑，因为这是IO线程，处理多了会累死，消耗性能，影响别的请求。handler将消息丢给了processor来处理。然而processor是一个任劳任怨的老大哥，他也很聪明，叫来了<code>CloseableExecutor</code>大佬，也就是<code>Executor</code>家族的一员来帮忙处理这些消息。但是这个大佬只能处理特定的消息，针对这些“不认识”的消息有点懵逼，于是将这些消息做了一些加工，转化成<code>MessageTask</code>，这样子大佬们就开心快乐的去干活了。然而实际上大佬不会亲自去干活，他只“安排”小弟去干，而具体做什么都在<code>MessageTask</code>里面装着，将要做的事情全部安排在<code>run</code>方法中。接下来就是对这些消息进行处理了。</p>
<p>这里要做最重要的一步就是将payload中的字节根据header中的序列化规则进行解码（反序列化），这也可以算是第二次封装了。为啥要在这里处理而不是在解码器处理，还是因为不能影响IO线程，那个家伙娇贵的很，累不得。经过反序列化后的对象叫做<code>MessageWrapper</code>.这个家伙很真实，因为完全是属于业务层的包。无非就是consumer的诉求罢了：我要调用哪个接口，参数是什么，得是什么版本的blabla一系列信息。这些信息全部都放在传输层的body里面，现在通过反序列化真真实实的站在大佬面前。那么如何来处理consumer发送过来的请求呢？前提是得知道consumer端到底要什么。之前说过，consumer将请求报文全部封装到<code>MessageWrapper</code>中，而其中有一个非常重要的信息：<code>ServiceMetadata</code>。这个对象是一个“地址”，通过这个玩意provider就能找到consumer需要的调用对象以及其他相关的信息。原理也很简单，在provider发布的时候将这个“地址”在本地做一份映射不就完了。同时将这个地址发送到注册中心去。这样consumer到注册中心拿到这个地址然后向provider发送请求的时候，provider也就能做出回应了–找到对应的“服务”（本质上就是一个bean），通过consumer的请求参数，invoke一下，爱返回结果就返回结果，没有返回的拉倒。当然有结果返回的情况又涉及一次网络请求了–provider向consumer发送响应数据。</p>
<p>如此，rpc的前半个过程就完成了，接下来就是最最最伤脑筋的部分–调用。也就是上文未具体说到的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ServiceWrapper service)</span> </span>&#123;</div><div class="line">        <span class="comment">// stack copy</span></div><div class="line">        <span class="keyword">final</span> JRequest _request = request;</div><div class="line"></div><div class="line">        Context invokeCtx = <span class="keyword">new</span> Context(service);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (TracingUtil.isTracingNeeded()) &#123;</div><div class="line">            setCurrentTraceId(_request.message().getTraceId());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Object invokeResult = Chains.invoke(_request, invokeCtx)</div><div class="line">                    .getResult();</div><div class="line"></div><div class="line">            ResultWrapper result = <span class="keyword">new</span> ResultWrapper();</div><div class="line">            result.setResult(invokeResult);</div><div class="line">            <span class="keyword">byte</span> s_code = _request.serializerCode();</div><div class="line">            Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">            JResponsePayload responsePayload = <span class="keyword">new</span> JResponsePayload(_request.invokeId());</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">                OutputBuf outputBuf =</div><div class="line">                        serializer.writeObject(channel.allocOutputBuf(), result);</div><div class="line">                responsePayload.outputBuf(s_code, outputBuf);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">byte</span>[] bytes = serializer.writeObject(result);</div><div class="line">                responsePayload.bytes(s_code, bytes);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responsePayload.status(Status.OK.value());</div><div class="line"></div><div class="line">            handleWriteResponse(responsePayload);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">if</span> (INVOKE_ERROR == t) &#123;</div><div class="line">                <span class="comment">// handle biz exception</span></div><div class="line">                handleException(invokeCtx.getExpectCauseTypes(), invokeCtx.getCause());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                processor.handleException(channel, _request, Status.SERVER_ERROR, t);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (TracingUtil.isTracingNeeded()) &#123;</div><div class="line">                TracingUtil.clearCurrent();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码中最重要的一行是获取调用结果<code>invokeResult</code>。这里使用<code>Context</code>将<code>ServiceWrapper</code>进行封装了一下，然后使用<code>Chains#invoke</code>进行调用。其中就涉及到了一种设计模式–责任链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Chains</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JFilterChain headChain;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            JFilterChain invokeChain = <span class="keyword">new</span> DefaultFilterChain(<span class="keyword">new</span> InvokeFilter(), <span class="keyword">null</span>);</div><div class="line">            JFilterChain interceptChain = <span class="keyword">new</span> DefaultFilterChain(<span class="keyword">new</span> InterceptorsFilter(), invokeChain);</div><div class="line">            headChain = JFilterLoader.loadExtFilters(interceptChain, JFilter.Type.PROVIDER);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &lt;T extends JFilterContext&gt; <span class="function">T <span class="title">invoke</span><span class="params">(JRequest request, T invokeCtx)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            headChain.doFilter(request, invokeCtx);</div><div class="line">            <span class="keyword">return</span> invokeCtx;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这点代码很简单，首先在static代码块中初始化了几个chain。<code>headChain</code>为第一个chain，通过spi机制去动态加载<code>META-INF/services/</code>目录下的配置文件来实例化<code>JFilterChain</code>.当然只会去找类型为provider的chain，同时将下一个chain放进去。而下一个chain叫做<code>interceptChain</code>，也是预先被初始化了，其中的filter的实现为<code>InterceptorsFilter</code>,最后一个filterChain为<code>invokeChain</code>，通过命名就知道这个chain是真正用来执行具体业务处理的。他没有下一个节点。</p>
<p>具体的调用顺序是headChain调用doFilter，内部其实是headChain持有的filter实例来调用doFilter,同时将headChain持有的实例nextChain作为参数传递进去。如果headChain的filter处理不了，就调用next的doFilter，而next也是同样的结构，也能做出同样的处理，这样一层一层的调用直到chain的尾巴，得到结果后再一层一层返回。</p>
<p>这种设计思想非常典型，很多框架中都有责任链模式的身影。而我们讨论的核心在invokeChain这一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeFilter</span> <span class="keyword">implements</span> <span class="title">JFilter</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Type.PROVIDER;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> &lt;T extends JFilterContext&gt; <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(JRequest request, T filterCtx, JFilterChain next)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            MessageWrapper msg = request.message();</div><div class="line">            Context invokeCtx = (Context) filterCtx;</div><div class="line"></div><div class="line">            Object invokeResult = MessageTask.invoke(msg, invokeCtx);</div><div class="line"></div><div class="line">            invokeCtx.setResult(invokeResult);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，doFilter方法中并没有调用next，也证实了一点：这是chain的尾巴了。必须处理，不处理就没人处理了。而这里具体处理逻辑却又回到了<code>MessageTask#invoke</code>,兜兜转转又是一圈。最终将返回的结果使用<code>Context#setResult</code>进行填充。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invoke</span><span class="params">(MessageWrapper msg, Context invokeCtx)</span> <span class="keyword">throws</span> Signal </span>&#123;</div><div class="line">        ServiceWrapper service = invokeCtx.getService();</div><div class="line">        <span class="comment">// 得到具体的实例</span></div><div class="line">        Object provider = service.getServiceProvider();</div><div class="line">        <span class="comment">// 方法名</span></div><div class="line">        String methodName = msg.getMethodName();</div><div class="line">        <span class="comment">// 方法参数</span></div><div class="line">        Object[] args = msg.getArgs();</div><div class="line"></div><div class="line">		 <span class="comment">// metrics api 用于统计数据</span></div><div class="line">        Timer.Context timerCtx = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (METRIC_NEEDED) &#123;</div><div class="line">            timerCtx = Metrics.timer(msg.getOperationName()).time();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Class&lt;?&gt;[] expectCauseTypes = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt;&gt; methodExtension = service.getMethodExtension(methodName);</div><div class="line">            <span class="keyword">if</span> (methodExtension == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(methodName);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 根据JLS方法调用的静态分派规则查找最匹配的方法parameterTypes</span></div><div class="line">            Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt; bestMatch = Reflects.findMatchingParameterTypesExt(methodExtension, args);</div><div class="line">            Class&lt;?&gt;[] parameterTypes = bestMatch.getFirst();</div><div class="line">            expectCauseTypes = bestMatch.getSecond();</div><div class="line"></div><div class="line">            <span class="keyword">return</span> Reflects.fastInvoke(provider, methodName, parameterTypes, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            invokeCtx.setCauseAndExpectTypes(t, expectCauseTypes);</div><div class="line">            <span class="keyword">throw</span> INVOKE_ERROR;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (METRIC_NEEDED) &#123;</div><div class="line">                timerCtx.stop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码有点晦涩难懂。尤其是使用静态分派这块逻辑非常模糊。去看一下反射调用的相关api就知道，使用反射用到的参数得有方法名，方法参数，参数类型以及调用方法的对象。在<code>ServiceWrapper</code>实例中已经有了方法名，参数，要调用的方法对象很显然就是他自己，就剩下一个参数类型不知道了。当然在rpc中请求端也没法吧参数类型给你传过来，这里需要自己去判断了。而<code>Reflects.findMatchingParameterTypesExt</code>就是根据参数来判断参数类型到底是什么。最终使用<code>Reflects.fastInvoke(provider, methodName, parameterTypes, args);</code>来完成调用。从这里看到参数确实是刚才提到的四个参数，缺一不可。然而这里并没有去使用反射调用的，而是使用字节码直接生成子类（但是反射的本质不就是生成子类吗？有点懵逼）。其实还是有一点区别的，在使用反射的时候，以jdk反射为例，每代理一个方法就会生成一个代理类，在需要很多代理方法需要被调用的时候就回生成很多个代理类，这样就很消耗性能。而这里使用的是通过字节码工具自己生成一个子类，并且缓存下来，这样节省很多性能。在benchmark中跑的结果确实比jdk反射性能要好很多。具体的代码实现就不去纠结了，反正也看不明白，这里就当作是反射调用就行了。关于Java语言的这种“动态”特性我不得不吐槽一下，虽说提供了一种基于运行时的修改程序的行为机制，但是真的是很麻烦，光看api都会把人给搞晕，非常不友好。而现在很多动态语言就很人性化，想改就改，非常轻松。其实我还是很喜欢Javascript的。</p>
<p>最终，整个调用的逻辑都完完全全走通了。当然，这只是基于正常的调用，也就是没有出现异常的情况。如果出现了异常情况改怎么处理呢？比如说空指针，除数为0等情况。在invoke的逻辑中，直接将<code>Throwable</code>捕获到，塞进<code>Context</code>中，最后抛出异常。在process逻辑也里会有捕获动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(Class&lt;?&gt;[] exceptionTypes, Throwable failCause)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (exceptionTypes != <span class="keyword">null</span> &amp;&amp; exceptionTypes.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            Class&lt;?&gt; failType = failCause.getClass();</div><div class="line">            <span class="keyword">for</span> (Class&lt;?&gt; eType : exceptionTypes) &#123;</div><div class="line">                <span class="comment">// 如果抛出声明异常的子类, 客户端可能会因为不存在子类类型而无法序列化, 会在客户端抛出无法反序列化异常</span></div><div class="line">                <span class="keyword">if</span> (eType.isAssignableFrom(failType)) &#123;</div><div class="line">                    <span class="comment">// 预期内的异常</span></div><div class="line">                    processor.handleException(channel, request, Status.SERVICE_EXPECTED_ERROR, failCause);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 预期外的异常</span></div><div class="line">        processor.handleException(channel, request, Status.SERVICE_UNEXPECTED_ERROR, failCause);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>虽然这段代码比较长，但是核心就只有一点，处理异常消息。而正真做这件事交给了processor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doHandleException</span><span class="params">(</span></span></div><div class="line">            JChannel channel, <span class="keyword">long</span> invokeId, <span class="keyword">byte</span> s_code, <span class="keyword">byte</span> status, Throwable cause, <span class="keyword">boolean</span> closeChannel) &#123;</div><div class="line"></div><div class="line">        ResultWrapper result = <span class="keyword">new</span> ResultWrapper();</div><div class="line">        <span class="comment">// 截断cause, 避免客户端无法找到cause类型而无法序列化</span></div><div class="line">        cause = ThrowUtil.cutCause(cause);</div><div class="line">        result.setError(cause);</div><div class="line"></div><div class="line">        Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">        JResponsePayload response = <span class="keyword">new</span> JResponsePayload(invokeId);</div><div class="line">        response.status(status);</div><div class="line">        <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">            OutputBuf outputBuf =</div><div class="line">                    serializer.writeObject(channel.allocOutputBuf(), result);</div><div class="line">            response.outputBuf(s_code, outputBuf);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = serializer.writeObject(result);</div><div class="line">            response.bytes(s_code, bytes);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (closeChannel) &#123;</div><div class="line">            channel.write(response, JChannel.CLOSE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.write(response, <span class="keyword">new</span> JFutureListener&lt;JChannel&gt;() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationSuccess</span><span class="params">(JChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    logger.debug(<span class="string">"Service error message sent out: &#123;&#125;."</span>, channel);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationFailure</span><span class="params">(JChannel channel, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">                        logger.warn(<span class="string">"Service error message sent failed: &#123;&#125;, &#123;&#125;."</span>, channel, stackTrace(cause));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>无非就是将异常对象写出去，当然也不一定是异常对象，也有可能是正常对象，管他呢，反正都是对象，客户端能够通过status自行去判断到底是什么类型。这样子，客户端调用一个rpc方法就像调用本地方法一样，也可以打印正常的异常栈信息，但是只能知道发生了什么异常，没办法去定位到哪一行有问题，这是很尴尬的。当然实际生成中这和你调用方关系不大，只需要遵循一个原则：谁写的bug谁去改。轻松甩锅。</p>
<p>终于，provider的核心基本上写完了，还有很多细节需要慢慢地理一遍，毕竟涉及到很多知识盲区，需要时间慢慢消化。写到这里我才发现还有一个比较关键的点没有涉及到，那就是服务的发布。接下来的一篇文章会简单概述provider是怎么“发布”出去的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中讲到了provider中针对consumer的请求消息封装&lt;code&gt;MessageTask&lt;/code&gt;的部分细节。留下了最核心的处理消息的细节&lt;code&gt;process&lt;/code&gt;方法没有说。&lt;/p&gt;
&lt;p&gt;在继续对所谓的核心逻辑梳理之前，先整体的捋一捋
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(三)</title>
    <link href="http://www.wei-dong.top/2018/08/21/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%B8%89)/"/>
    <id>http://www.wei-dong.top/2018/08/21/一起学RPC(三)/</id>
    <published>2018-08-21T08:17:23.000Z</published>
    <updated>2018-08-21T08:24:45.776Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中讲到jupiter的传输模块transport中的编解码器的实现。对server来言，编解码器扮演着一头一尾的门卫角色，保证进来的人是干净的，也得保证出去的人也是干净的。当然这么比喻很不恰当，但是也想不到别的比喻了。</p>
<p>编解码器固然重要，但是没有核心的业务处理器也没多大意义。本文的重点就是核心处理器：<code>AcceptorHandler</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ChannelHandler</span>.Sharable</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptorHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> ProviderProcessor processor;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="function"><span class="keyword">public</span> ProviderProcessor <span class="title">processor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> processor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processor</span><span class="params">(ProviderProcessor processor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.processor = processor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现一个handler很容易，直接继承<code>ChannelInboundHandlerAdapter</code>就行了。当然这是针对server来说的。根据类名来看，正常情况下首先会联想到肯定会有个与之对应的。针对server来说，要处理的就是入站数据，使用inbound就行了。如果有更加复杂的逻辑处理，可以去看看官方文档中其他的派生类。同时，这个实例也是能够被共享的，道理也很简单：没有状态。也许你会问：这里分明是有成员变量的呀。但是，这个成员变量是不会被改变的。如果发生了变化，这个程序设计上就有问题。理论上是绝对不允许改变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       Channel ch = ctx.channel();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JRequestPayload) &#123;</div><div class="line">           JChannel jChannel = NettyChannel.attachChannel(ch);</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               processor.handleRequest(jChannel, (JRequestPayload) msg);</div><div class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">               processor.handleException(jChannel, (JRequestPayload) msg, Status.SERVER_ERROR, t);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unexpected message type received: &#123;&#125;, channel: &#123;&#125;."</span>, msg.getClass(), ch);</div><div class="line"></div><div class="line">           ReferenceCountUtil.release(msg);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="keyword">int</span> count = channelCounter.incrementAndGet();</div><div class="line"></div><div class="line">       logger.info(<span class="string">"Connects with &#123;&#125; as the &#123;&#125;th channel."</span>, ctx.channel(), count);</div><div class="line"></div><div class="line">       <span class="keyword">super</span>.channelActive(ctx);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="keyword">int</span> count = channelCounter.getAndDecrement();</div><div class="line"></div><div class="line">       logger.warn(<span class="string">"Disconnects with &#123;&#125; as the &#123;&#125;th channel."</span>, ctx.channel(), count);</div><div class="line"></div><div class="line">       <span class="keyword">super</span>.channelInactive(ctx);</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       Channel ch = ctx.channel();</div><div class="line">       ChannelConfig config = ch.config();</div><div class="line"></div><div class="line">       <span class="comment">// 高水位线: ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK</span></div><div class="line">       <span class="comment">// 低水位线: ChannelOption.WRITE_BUFFER_LOW_WATER_MARK</span></div><div class="line">       <span class="keyword">if</span> (!ch.isWritable()) &#123;</div><div class="line">           <span class="comment">// 当前channel的缓冲区(OutboundBuffer)大小超过了WRITE_BUFFER_HIGH_WATER_MARK</span></div><div class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">               logger.warn(<span class="string">"&#123;&#125; is not writable, high water mask: &#123;&#125;, the number of flushed entries that are not written yet: &#123;&#125;."</span>,</div><div class="line">                       ch, config.getWriteBufferHighWaterMark(), ch.unsafe().outboundBuffer().size());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           config.setAutoRead(<span class="keyword">false</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// 曾经高于高水位线的OutboundBuffer现在已经低于WRITE_BUFFER_LOW_WATER_MARK了</span></div><div class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">               logger.warn(<span class="string">"&#123;&#125; is writable(rehabilitate), low water mask: &#123;&#125;, the number of flushed entries that are not written yet: &#123;&#125;."</span>,</div><div class="line">                       ch, config.getWriteBufferLowWaterMark(), ch.unsafe().outboundBuffer().size());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           config.setAutoRead(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>AcceptorHandler</code>重写了几个方法。注意，重写<code>channelRead()</code>方法的时候记得调用<code>ReferenceCountUtil.release(msg)</code>。</p>
<p>其中最核心的逻辑在<code>channelRead()</code>中处理。无非就是将解码器中反序列化后的对象进行处理罢了。当然这里接受的仅仅是<code>JRequestPayload</code>类型。然后将Netty的原生<code>Channel</code>转化为自定义的<code>JChannel</code>类型。这样做的目的是为了将api统一，方便接入其他网络库实现。也就说如果要换别的网络框架如mina，不需要去改动我业务的代码，只需针对别的网络库的api进行编码即可。然后使用<code>ProviderProcessor</code>来处理具体的业务逻辑。这个接口中提供了两个操作：<code>handleRequest</code>和 <code>handleException</code>.因此具体的业务逻辑处理全部都传递给<code>ProviderProcessor</code>实现了。</p>
<p>而<code>channelWritabilityChanged</code>方法在可写状态发生变化的时候会被调用。可以通过<code>Channel#isWritable()</code>方法来获取状态。而这里对其重写是为了判断OutboundBuffer的大小有没有超过高水位线，这里的水位线是在<code>ChannelConfig</code>中设置的，server初始化的时候。超过高水位线就不允许自动去读数据了。这里有一点疑惑，不清楚为什么需要调用<code>config.setAutoRead(false)</code>。一个比较模糊的概念是Netty的写动作并不是直接向socket中写，而是写到Netty中的缓冲区中，这个缓冲区叫做<code>ChannelOutboundBuffer</code>，而这个buffer的实现是使用的无界链表，如果对方的接受太慢，就会导致这个链表无限大，最坏情况会导致OOM。因此提供一种机制：设置水位线。如果超过水位线就让用户来自己决定怎么处理，具体做法就是调用<code>channelWritabilityChanged</code>方法。这里的这个方法将自动读关闭了，这里面大有玄机。其实是利用了TCP的滑动窗口来控制的。</p>
<blockquote>
<p>比如咱俩喝酒, 你喝完一杯我就立刻给你满上, 最终你喝不动了 ,<br>不再举起杯子…. 你的杯子一直是满的, 我也没法继续给你倒酒</p>
</blockquote>
<p>这个栗子很形象地解释了滑动窗口。结合这个<a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="external">动画</a>更直观。</p>
<p><a href="http://www.cnblogs.com/rainy-shurun/p/5213086.html" target="_blank" rel="external">这里</a>有一篇文章值得参考。</p>
<p><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/water-2018-08-06-10-52-13.jpg?raw=true" alt="image"></p>
<p>接下来要讨论的是这个<code>processor</code>到底是怎么处理消息的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(DefaultProviderProcessor.class);</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CloseableExecutor executor;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DefaultProviderProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>(ProviderExecutors.executor());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DefaultProviderProcessor</span><span class="params">(CloseableExecutor executor)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.executor = executor;</div><div class="line">   &#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(JChannel channel, JRequestPayload requestPayload)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       MessageTask task = <span class="keyword">new</span> MessageTask(<span class="keyword">this</span>, channel, <span class="keyword">new</span> JRequest(requestPayload));</div><div class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</div><div class="line">           task.run();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           executor.execute(task);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实不难想到，<code>handleRequest</code>方法中将接受到的数据做了一层封装，然后丢给线程池去处理。在Netty中，业务处理逻辑绝对不能放在IO线程中执行。IO线程只负责读取/发送数据，不能进行业务处理。这是因为如果业务逻辑中有耗时的操作就会将IO线程阻塞住，这样正常的请求也就被阻塞了，影响应用的性能。而这里的线程池也被自定义了。</p>
<p><code>CloseableExecutor</code>是一个接口类型，正真的实现类是通过SPI机制由工厂创建出来的。关于SPI机制这里不会展开，将单独去整理一篇文章来说明。这种机制在很多框架中都有体现。</p>
<p>而包装类<code>MessageTask</code>的实现就很关键了。既然这个对象能放到线程池中，那么一定是一个<code>Runnable</code>或者<code>Callable</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// stack copy</span></div><div class="line">       <span class="keyword">final</span> DefaultProviderProcessor _processor = processor;</div><div class="line">       <span class="keyword">final</span> JRequest _request = request;</div><div class="line"></div><div class="line">       <span class="comment">// 全局流量控制</span></div><div class="line">       ControlResult ctrl = _processor.flowControl(_request);</div><div class="line">       <span class="keyword">if</span> (!ctrl.isAllowed()) &#123;</div><div class="line">           rejected(Status.APP_FLOW_CONTROL, <span class="keyword">new</span> JupiterFlowControlException(String.valueOf(ctrl)));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       MessageWrapper msg;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           JRequestPayload _requestPayload = _request.payload();</div><div class="line"></div><div class="line">           <span class="keyword">byte</span> s_code = _requestPayload.serializerCode();</div><div class="line">           Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">           <span class="comment">// 在业务线程中反序列化, 减轻IO线程负担</span></div><div class="line">           <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">               InputBuf inputBuf = _requestPayload.inputBuf();</div><div class="line">               msg = serializer.readObject(inputBuf, MessageWrapper.class);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">byte</span>[] bytes = _requestPayload.bytes();</div><div class="line">               msg = serializer.readObject(bytes, MessageWrapper.class);</div><div class="line">           &#125;</div><div class="line">           _requestPayload.clear();</div><div class="line"></div><div class="line">           _request.message(msg);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">           rejected(Status.BAD_REQUEST, <span class="keyword">new</span> JupiterBadRequestException(<span class="string">"reading request failed"</span>, t));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 查找服务</span></div><div class="line">       <span class="keyword">final</span> ServiceWrapper service = _processor.lookupService(msg.getMetadata());</div><div class="line">       <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">           rejected(Status.SERVICE_NOT_FOUND, <span class="keyword">new</span> JupiterServiceNotFoundException(String.valueOf(msg)));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// provider私有流量控制</span></div><div class="line">       FlowController&lt;JRequest&gt; childController = service.getFlowController();</div><div class="line">       <span class="keyword">if</span> (childController != <span class="keyword">null</span>) &#123;</div><div class="line">           ctrl = childController.flowControl(_request);</div><div class="line">           <span class="keyword">if</span> (!ctrl.isAllowed()) &#123;</div><div class="line">               rejected(Status.PROVIDER_FLOW_CONTROL, <span class="keyword">new</span> JupiterFlowControlException(String.valueOf(ctrl)));</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// processing</span></div><div class="line">       Executor childExecutor = service.getExecutor();</div><div class="line">       <span class="keyword">if</span> (childExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">           process(service);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// provider私有线程池执行</span></div><div class="line">           childExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   process(service);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这段代码十分简洁。首先将全局变量赋值为局部变量，我依稀记得在一个老外的代码中看到过，目的大概是为了节省性能。接下来就是全局流量控制，所谓的流量控制简单理解为防止请求太猛导致服务垮掉。有全局的就一定有局部的。而局部的控制是针对rpc中对外暴露某个服务。其粒度更小一点。然后就是反序列化了，这个过程在编解码器中也能完成，但是作者并没有这么做。目的也很简单，毕竟序列化是比较耗性能的，再说了，编解码器实际上也是在IO线程中处理的。这么做也是为了减轻IO线程负担。紧接着就是将序列化后的对象中的<code>ServiceMetadata</code>取出来 ，通过这个对象去本地容器中找<code>ServiceWrapper</code>。本地容器就是rpc的provider在发布一个服务到注册中心的时候本地也保存一个这个服务的相关信息。所谓的服务简单理解为就是一个service bean。而这个容器简单理解为就是一个map映射，<code>ServiceMetadata</code>为key，<code>ServiceWrapper</code>为value。找到这个<code>ServiceWrapper</code>后就很好办了，接下来就是调用这个service了。但是这个<code>ServiceWrapper</code>不仅仅是一个service，里面有很多额外的功能，比方可以有一个私有的线程池。如果有，那么在具体调用这个service的时候会使用这个私有的线程池。这种场景我反正没见过，但不排除有这种情况。如果没有那就很简单了，直接处理。这个处理过程也很容易想到，无非就是将要调用的service执行一遍，将结果序列化，再写出去。然而里面的代码实现可没有那么简单。</p>
<p>具体的处理逻辑全部都在<code>process</code>方法中。当然，在看具体实现之前很有必要对其中几个核类如<code>ServiceWrapper</code>和<code>MessageWrapper</code>进行解读。</p>
<p><code>MessageWrapper</code>可以简单理解为调用者发送的数据。包含要调用的对象，对象的方法，方法的参数。当然实际上比这些内容要复杂很多，比如链路追踪id等。有个最重要的参数<code>ServiceMetadata</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMetadata</span> <span class="keyword">extends</span> <span class="title">Directory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8908295634641380163L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String group;               <span class="comment">// 服务组别</span></div><div class="line">    <span class="keyword">private</span> String serviceProviderName; <span class="comment">// 服务名称</span></div><div class="line">    <span class="keyword">private</span> String version;             <span class="comment">// 服务版本号</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Directory</code>是一个抽象类。这个命名也很容易理解，顾名思义Directory是目录的意思。对于某个服务来说，单纯的知道服务名就足矣完成调用。但是在复杂的场景下，有成百上千个服务，要做到准确调用就得对其进行分类了。而且有时候还有同一个服务版本也不一样的情形，因此版本号也得作为这个目录中的某个层级。为什么成为metadata呢？这个属性在<code>ServiceWrapper</code>对象中也有。可以猜到了，一定是一一对应起来的。通俗解释来说<code>ServiceWrapper</code>是属于服务端的。也就是说provider发布本地服务到注册中心的同时，仅仅是将元数据发出去了，注册中心有了还不能完事，自己本地得确实存在呀，不然consumer从注册中心中拿到服务元数据了去provider里找不到这个服务，这非得骂娘不可。而ServiceWrapper正是将需要暴露出去的服务在本地存起来。仅此而已。其中最重要的属性就是服务对象<code>serviceProvider</code>了，对于rpc来说，consumer知道的仅仅是接口，正真去干活的还是实现类。而其余的花里胡哨的东西还是有点用的，得分场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceWrapper</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6690575889849847348L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 服务元数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceMetadata metadata;</div><div class="line">    <span class="comment">// 服务对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object serviceProvider;</div><div class="line">    <span class="comment">// 服务拦截器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProviderInterceptor[] interceptors;</div><div class="line">    <span class="comment">// key:     method name</span></div><div class="line">    <span class="comment">// value:   pair.first:  方法参数类型(用于根据JLS规则实现方法调用的静态分派)</span></div><div class="line">    <span class="comment">//          pair.second: 方法显式声明抛出的异常类型</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt;&gt;&gt; extensions;</div><div class="line"></div><div class="line">    <span class="comment">// 权重 hashCode() 与 equals() 不把weight计算在内</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = JConstants.DEFAULT_WEIGHT;</div><div class="line">    <span class="comment">// provider私有线程池</span></div><div class="line">    <span class="keyword">private</span> Executor executor;</div><div class="line">    <span class="comment">// provider私有流量控制器</span></div><div class="line">    <span class="keyword">private</span> FlowController&lt;JRequest&gt; flowController;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>而具体的核心处理逻辑<code>process</code>以后再慢慢看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中讲到jupiter的传输模块transport中的编解码器的实现。对server来言，编解码器扮演着一头一尾的门卫角色，保证进来的人是干净的，也得保证出去的人也是干净的。当然这么比喻很不恰当，但是也想不到别的比喻了。&lt;/p&gt;
&lt;p&gt;编解码器固然重要，但是没有核
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>小白探索大前端--使用vue实现简单轮播图</title>
    <link href="http://www.wei-dong.top/2018/08/15/%E5%B0%8F%E7%99%BD%E6%8E%A2%E7%B4%A2%E5%A4%A7%E5%89%8D%E7%AB%AF--%E4%BD%BF%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <id>http://www.wei-dong.top/2018/08/15/小白探索大前端--使用vue实现简单轮播图/</id>
    <published>2018-08-15T09:17:23.000Z</published>
    <updated>2018-08-15T10:04:51.119Z</updated>
    
    <content type="html"><![CDATA[<p>最近看完了《Vue实战》这本书，这也是我第一次完整的看完的一本关于前端的书籍（现在还在看的是《CSS世界》，有点想放弃了）。照着书中的demo都写了一遍，虽然很多栗子非常简单，但是值得学习的地方还是挺多的。当然也不得不吐槽很多用法都有点过时，尤其是关于webpack的配置。不过现在的前端发展很快，各种工具版本不断更新，代码过时也是能够理解的。对于学习者来说当然得学习最新的东西。</p>
<p>这篇文章主要是用来记录在自己实现一个【知乎日报移动版】的过程中遇到的一个坑，说坑也算不上，只能叫做坎坷之路吧。因为书中给的实战demo是一个pc版的，自己跟着写了一遍，觉得没有什么难度。然后在github上找了一下，发现用知乎日报来练手的项目很多，原因也很简单–api是现成的。于是我也蠢蠢欲动，决定使用vue亲自撸一个【知乎daily】。</p>
<p>虽然gayhub很多现成的项目，但是我并不打算去抄一遍。我在手机上下载了一个知乎日报的APP，按照不同功能截屏来一一实现。没办法，这就是工(zhuang)匠(bi)情(xin)怀(tai).</p>
<p>开发过程中，整体的框架功能上基本没什么问题，该自己写组件就自己写，绝没有偷懒。也遇到很多问题，比如开发环境下的接口代理、知乎图片的同源策略等。这些问题肯定难不倒我，都不值一提。让我觉得难受的还是首页的轮播图实现。这个问题困扰了我2天（准确时间是一天半，还有半天在工作：逃）。</p>
<p>遇到这个功能的时候第一反应是使用一个开源库，分分钟就搞定了。但是经过10s的思想斗争，工匠情怀终于战胜了理智，下定决心打算自己手动实现。然而，带来的结果就是卡顿了半天，没任何进展。网上也有很多教程，也是很简单的，可以说是基础操作了。可惜我被一篇文章带偏了，走了一点弯路。</p>
<p>这篇文章的思路很常规，很有道理。首先将一个框框用来装你要显示的图片，仅仅只能显示这个框框，而图片呢就放后面排排坐，通过定时器去移动图片，就像一格格的胶卷一样，轮到谁谁就被看到了。</p>
<p>我一开始就是按照这种思路去整，结果怎么整都实现不了（在移动端）。在一筹莫展之际，发现了一个更加屌的思路。这个思路和之前的不一样，区别在于后面的图片不是排排坐好，而是叠加到一块去。下面通过代码去一探究竟。</p>
<p>首先得整一个窗口，简单来说就是用来显示一张图片的容器，它的宽度对移动端而言就是屏幕宽度。他得有一个非常重要的属性<code>overflow：hidden</code>，当子元素尺寸超过其父亲的大小多余内容就会被隐藏。这里用<code>ul</code>标签来装图片，其实使用<code>div</code>也是没问题的。元素<code>li</code>的<code>position</code>属性得设置为<code>absolute</code>.因为使用这个属性就能脱离文档流，也就不会“排排坐”了，而是叠加到一起了，当然，最后的肯定叠在最上面，前提是没有显示的设置<code>z-index</code>属性。还有很重要的一点，子元素定位设置为<code>absolute</code>父元素记得也设置一下定位属性，因为子元素的相对位置是按照第一个祖先元素不为<code>static</code>的元素来的，不然会粗大事。 html代码结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"window"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">ref</span>=<span class="string">"imagesWrapper"</span>&gt;</span></div><div class="line">       </div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(e,i) in imgs"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"e.image"</span> <span class="attr">:alt</span>=<span class="string">"e.title"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>&#123;&#123;e.title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">     <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"point-wrap"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">:class</span>=<span class="string">"&#123;active:i==currentIndex&#125;"</span> <span class="attr">v-for</span>=<span class="string">"(e,i) in imgs"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">list-style-type</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> <span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100%);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.window</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个小技巧，在静态样式中并没有将图片直接展示出来，而是将所有图片向右偏移一个窗口宽度。这是有玄机的。</p>
<p>说了这么多，还没谈到vue的部分。在<code>container</code>容器中有一个<code>ref</code>标签。这是在vue中用来获取dom元素的。也许在vue中操作dom是不被推荐的，但是对于这种动态生成的<code>li</code>元素我找不到怎么去动态绑定其样式。因此采用了这种比较low的办法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">init() &#123;</div><div class="line">     <span class="keyword">let</span> wrappers = <span class="keyword">this</span>.$refs.imagesWrapper;</div><div class="line">     <span class="keyword">let</span> children = wrappers.children;</div><div class="line">     <span class="keyword">let</span> total = <span class="keyword">this</span>.imgs.length;</div><div class="line">     <span class="comment">// 纯js操作 只需要先将三张图片位置确定好</span></div><div class="line">     <span class="comment">// 最左边按道理说是没有图片的 但是为了无限滚动效果 这里将其置为最后一张</span></div><div class="line">     <span class="keyword">let</span> left = total - <span class="number">1</span>;</div><div class="line">     <span class="keyword">let</span> center = <span class="number">0</span>;</div><div class="line">     <span class="keyword">let</span> right = <span class="number">1</span>;</div><div class="line"></div><div class="line">     <span class="comment">// 初始化的时候将li左移动了一个屏幕宽度，就是为了防止叠加的元素挡住要显示的图</span></div><div class="line">     <span class="comment">// 现在第一张显示的图片实际是最后一张 3张轮播起来就行了 没必要对每个图片进行位置计算</span></div><div class="line">     <span class="comment">// left处于最左边的位置 不显示</span></div><div class="line">     children[left].style.transform = <span class="string">"translateX("</span> + -<span class="keyword">this</span>.distance + <span class="string">"px)"</span>;</div><div class="line">     <span class="comment">// center处于中间位置 显示</span></div><div class="line">     children[center].style.transform = <span class="string">"translateX("</span> + <span class="number">0</span> + <span class="string">"px)"</span>;</div><div class="line">     <span class="comment">// right处于右边 不显示</span></div><div class="line">     children[right].style.transform = <span class="string">"translateX("</span> + <span class="keyword">this</span>.distance + <span class="string">"px)"</span>;</div><div class="line">     <span class="keyword">this</span>.sliderItem = children;</div><div class="line">     <span class="comment">// this.play();</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>首先就是初始化显示的内容，之前在静态css样式中将图片移动到右边看不到的地方去了，现在就得手动操作让其可见。刚开始我以为直接将这些图片全部“铺开”，然后滚动，后来发现这么做很笨。直接操作三张就行了！为了实现无限滚动的效果，第一张的逻辑上的前一张是最后一张，因此将第一张的“上一张”给放到屏幕左边，下一张放到屏幕右边，要显示的也就是第一张（下标为0）归位到窗口，这和之前设置的全局的样式<code>transform: translateX(100%)</code>对应起来了。</p>
<p>如此以来，初始化的三张图片就定位好了，逻辑上也是没什么问题的。其余的改不显示还是显示不了，也不会参与移动。下面看看怎么“滚”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">next() &#123;</div><div class="line">     this.currentIndex++;</div><div class="line">     // 边界判断</div><div class="line">     if (this.currentIndex &gt; this.imgs.length - 1) &#123;</div><div class="line">       this.currentIndex = 0;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     // center 为显示的图片</div><div class="line">     let center = this.currentIndex;</div><div class="line">     // 左边的 如果为负数 就取最后一张图片下标</div><div class="line">     let left = center - 1 &lt; 0 ? this.imgs.length - 1 : center - 1;</div><div class="line">     // 右边的 如果超过了最大图片数量 取第一张图片下标</div><div class="line">     let right = center + 1 == this.imgs.length ? 0 : center + 1;</div><div class="line"></div><div class="line">     let children = this.sliderItem;</div><div class="line">     // 给元素添加过渡</div><div class="line">     children[center].style.transition = "transform .5s";</div><div class="line">     children[left].style.transition = "transform .5s";</div><div class="line">     // 右边的图片是替补图片，不需要走过渡</div><div class="line">     children[right].style.transition = "none";</div><div class="line">     // 3张图片同时移动</div><div class="line">     children[left].style.transform = "translateX(" + -this.distance + "px)";</div><div class="line">     children[center].style.transform = "translateX(0px)";</div><div class="line">     children[right].style.transform = "translateX(" + this.distance + "px)";</div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p><code>currentIndex</code>为全局变量，指当前显示的图片下标，每次调用<code>next</code>会子增，到上限后会回归到0，这些都是很常规的操作。接下来就是计算上一张，下一张图片的下标，也是很容易理解，无非多了一点判断，在最后一张显示的时候下一张的下标得置为0，上一张也是同理，不然就回”空指针”了。接下来就是针对这三张图片改变样式，原则就是移动到哪个下标就显示哪个图片，上一张就移到左边，下一站移动到右边，顺便给加个动画效果。如此而已！</p>
<p>最后就是自动播放的逻辑，也是非常简单，一个定时器就搞定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">play() &#123;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.timer) &#123;</div><div class="line">       <span class="built_in">window</span>.clearInterval(<span class="keyword">this</span>.timer);</div><div class="line">       <span class="keyword">this</span>.timer = <span class="literal">null</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">this</span>.timer = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">       <span class="keyword">this</span>.next();</div><div class="line">     &#125;, <span class="keyword">this</span>.interval);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后在钩子函数中将这方法加上去就完事了。一个自制的轮播组件就写完了。简陋但是简单。这里有一个不太重要的细节，针对窗口变化的时候得动态改变偏移量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 窗口变化 重新初始化</span></div><div class="line">   windowChange() &#123;</div><div class="line">     <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line">     <span class="built_in">window</span>.onresize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">       <span class="keyword">return</span> <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</div><div class="line">         <span class="built_in">window</span>.screenWidth = <span class="built_in">document</span>.body.clientWidth;</div><div class="line">         that.distance = <span class="built_in">window</span>.screenWidth;</div><div class="line">         <span class="keyword">this</span>.init();</div><div class="line">       &#125;)();</div><div class="line">     &#125;;</div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p>这样在pc端下也能正常“滚”动了。</p>
<p>最后，做一下小小的总结。这个组件虽然简单，但是也花了一定时间，毕竟踩坑的路是不能跳过的。其中花了很多时间纠结布局和样式，很是难受，都怪我没有把《CSS世界》看完。虽然简单，但是功能也很局限，比如没有实现手动去滑动。APP上是有这个功能的，那是因为我还没学会怎么在vue下使用touch事件（实际上是懒）。比如没有代码优化等等，总不能要求一个新手来造一个完美的轮子吧（给自己一点上升的空间咯）。造轮子不是目的，理解其中的所以然才是目的，现成的库有很多，完成功能也很容易，但是不能仅仅满足于此，我觉得作为手艺人得有一种格(xi)物(huan)致(zhuang)知(B)的精神。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3117395-0a23d3aadd128f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/662" alt="image"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://web.jobbole.com/94701/" target="_blank" rel="external">CSS深入理解之relative定位</a></p>
<p><a href="https://segmentfault.com/a/1190000011013572#articleHeader2" target="_blank" rel="external">几种原生js轮播图</a></p>
<p><a href="https://github.com/Mr-Vincent/zhihu-daily-app" target="_blank" rel="external">源码地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看完了《Vue实战》这本书，这也是我第一次完整的看完的一本关于前端的书籍（现在还在看的是《CSS世界》，有点想放弃了）。照着书中的demo都写了一遍，虽然很多栗子非常简单，但是值得学习的地方还是挺多的。当然也不得不吐槽很多用法都有点过时，尤其是关于webpack的配置。
    
    </summary>
    
      <category term="前端" scheme="http://www.wei-dong.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="VUE" scheme="http://www.wei-dong.top/tags/VUE/"/>
    
      <category term="Javascript" scheme="http://www.wei-dong.top/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(二)</title>
    <link href="http://www.wei-dong.top/2018/08/09/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%BA%8C)/"/>
    <id>http://www.wei-dong.top/2018/08/09/一起学RPC(二)/</id>
    <published>2018-08-09T10:17:23.000Z</published>
    <updated>2018-08-09T10:02:11.780Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中介绍到关于jupiter的底层通信模块transport的部分实现。仅仅只是讨论了整个server的初始化以及启动流程。很多细枝末节其实还没有涉及到，例如tcp参数设置，超时机制，编解码器等等实现细节。这些东西将会逐步被消化分解。而本文的主题是jupiter的业务编解码器的实现。</p>
<p>在jupiter中有一张图，这张图清晰地描述了整个server的数据流向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">* *********************************************************************</div><div class="line"> *            I/O Request                       I/O Response</div><div class="line"> *                 │                                 △</div><div class="line"> *                                                   │</div><div class="line"> *                 │</div><div class="line"> * ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─ ─ ─</div><div class="line"> * │               │                                                  │</div><div class="line"> *                                                   │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐       ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐   │</div><div class="line"> *     IdleStateChecker#inBound          IdleStateChecker#outBound</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘       └ ─ ─ ─ ─ ─ ─△─ ─ ─ ─ ─ ─ ┘   │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐                                     │</div><div class="line"> *     AcceptorIdleStateTrigger                      │</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                                     │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐       ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐   │</div><div class="line"> *          ProtocolDecoder                   ProtocolEncoder</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘       └ ─ ─ ─ ─ ─ ─△─ ─ ─ ─ ─ ─ ┘   │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐                                     │</div><div class="line"> *          AcceptorHandler                          │</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                                     │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                    ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐                     │</div><div class="line"> *                 ▽                                 │</div><div class="line"> * │               ─ ─ ▷│       Processor       ├ ─ ─▷                │</div><div class="line"> *</div><div class="line"> * │                    └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                     │</div><div class="line"> * ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</div><div class="line"> *</div></pre></td></tr></table></figure>
<p>实际上这个图仅仅是针对Netty api的描述，和rpc没有太多直接的关系。如果换做别的通信框架这个图就没有什么意义了。鉴于Netty依旧是目前Java网络开发中最流行的框架，拿出来讨论也是很有意义的。</p>
<p>这个图中有几个核心的概念：decode、encode、IdleStateChecker和handler。在编写一个网络应用的时候首先必须定义的是通信协议。比如上传下载文件使用ftp，即时聊天使用xmpp，浏览网页使用http…当然自己写一个rpc框架也得定义自己的通信协议。为什么要定义协议这个问题对于开发的老手来说没有必要去解释，不过我还是得啰嗦一下。在网络应用程序中，所有的数据在网络上的传输都是二进制格式，也就是0101010这样的机器码。当然也有人会反驳：不是有基于字符的数据吗？我的理解是在宏观上来说确实存在，那是因为上层的协议已经将代表字符串的01010解码成了可读的字符串。但是在底层的传输，也就是在物理层比如网线、电磁波中的传输依旧还是0101。当然用0101来比喻也是不恰当，更准确的说法应该是电平信号。而协议的作用是将通信双方的内容进行规范。就像以前写书信的时候，开头得有称谓，然后写正文，最后是落款这样一种格式。别人收到后就知道，嗯，这是一封信而不是一篇散文或者自传。当然这个比喻不是很恰当，但是就这样吧，不想废话了。</p>
<p>既然定义了协议，那么就得去处理协议。Netty中提供了很多内置的协议解析的类。通常被称作编解码器。顾名思义也就是将二进制转化为我们想要的数据结构，这样方便统一处理。这张图中的具体体现就是先解码，然后再处理，最后将处理结果编码后发送出去。编解码器将是本文讨论的重点。然而还有别的几个组件如空闲链路检查<code>IdleStateChecker</code>和业务处理<code>AcceptorHandler</code>组件，这些放在后面讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">boot.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                ch.pipeline().addLast(</div><div class="line">                        <span class="keyword">new</span> IdleStateChecker(timer, JConstants.READER_IDLE_TIME_SECONDS, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                        idleStateTrigger,</div><div class="line">                        CodecConfig.isCodecLowCopy() ? <span class="keyword">new</span> LowCopyProtocolDecoder() : <span class="keyword">new</span> ProtocolDecoder(),</div><div class="line">                        encoder,</div><div class="line">                        handler);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这段代码就是初始化编解码器等组件。可以看到handler作为业务核心处理器放在了最后。这是Netty的机制所决定的。关于Netty的一些设计可以看看<a href="http://ifeve.com/netty-in-action-1/" target="_blank" rel="external">这本书</a>作为基础入门。</p>
<p>看到解码器和编码器还有点不一样。解码器是直接new的方式添加到pipeline中的，而编码器是new好了再添加到pipeline中。其实具体差别就在于解码器不能共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">ProtocolDecoder</span>.<span class="title">State</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@ChannelHandler</span>.Sharable</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">PayloadHolder</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所谓的能共享，就是意味着每次都能使用这个编码器而不需要每次用就得实例化出来。而解码器不能被共享也是有原因的。因为解码器解码的数据全部来自于网络请求，网络通常而言是不可靠的，不能保证每次都能发送完整的数据包也有可能需要的数据还没收到。那么如何保证接受到的数据是完整的呢？实际上是没法保证，只能够“假装”是完整的。所以decoder是继承自<code>ReplayingDecoder</code>。这个类的作用简单通俗来理解就是如果网络上的数据还没发完，我就继续接收，直到收完为止。具体的工作原理可以参考api文档或者源码，这里不再过多探讨。为什么继承这个类后就不能共享呢？这个类是个泛型，参数是一个state的字眼。看到这里大概可以联想到这个类肯定和状态有关系。这样就很容易理解了，有状态的对象通常不能被共享。想象一下，在多线程环境下，线程A将这个状态改为1线程B这时候拿到执行权又把这个状态改为2，然后线程A又要使用这个状态变量了，这时候就不是他刚开始改变的状态了。如此一来，全部乱套了。这些都是并发基础相关的内容，有兴趣可以去谷歌。这里不再过多描述。而encode则没有状态变量，需要编码的数据一定是确定的，不存在解码器中数据不完整的情况。因此使用共享实例没什么问题。具体可以看看其中的代码实现：<a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-transport/jupiter-transport-netty/src/main/java/org/jupiter/transport/netty/handler/ProtocolDecoder.java" target="_blank" rel="external">ProtocolDecoder</a>  <a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-transport/jupiter-transport-netty/src/main/java/org/jupiter/transport/netty/handler/ProtocolEncoder.java" target="_blank" rel="external">ProtocolEncoder</a></p>
<p>解释完这些鸡毛蒜皮的细节，接下来开始分析一下这个协议的定义以及解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">* **************************************************************************************************</div><div class="line">*                                          Protocol</div><div class="line">*  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</div><div class="line">*       2   │   1   │    1   │     8     │      4      │</div><div class="line">*  ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤</div><div class="line">*           │       │        │           │             │</div><div class="line">*  │  MAGIC   Sign    Status   Invoke Id    Body Size                    Body Content              │</div><div class="line">*           │       │        │           │             │</div><div class="line">*  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</div><div class="line">*</div><div class="line">* 消息头16个字节定长</div><div class="line">* = 2 // magic = (short) 0xbabe</div><div class="line">* + 1 // 消息标志位, 低地址4位用来表示消息类型request/response/heartbeat等, 高地址4位用来表示序列化类型</div><div class="line">* + 1 // 状态位, 设置请求响应状态</div><div class="line">* + 8 // 消息 id, long 类型, 未来jupiter可能将id限制在48位, 留出高地址的16位作为扩展字段</div><div class="line">* + 4 // 消息体 body 长度, int 类型</div><div class="line">*</div></pre></td></tr></table></figure>
<p>作者在代码中将协议格式完全标注出来了:16字节的消息头+消息体。消息头中的MAGIC字段仅仅是为了标识这个数据包是属于jupiter。就像java class文件以<code>0xCAFEBABE</code>开头一样。没有实际的意义，仅仅做个标识而已。其他的字段也就没什么可说的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_COMPOSITE_BUF = SystemPropertyUtil.getBoolean(<span class="string">"jupiter.io.decoder.composite.buf"</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProtocolDecoder</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(State.MAGIC);</div><div class="line">       <span class="keyword">if</span> (USE_COMPOSITE_BUF) &#123;</div><div class="line">           setCumulator(COMPOSITE_CUMULATOR);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">enum</span> State &#123;</div><div class="line">       MAGIC,</div><div class="line">       SIGN,</div><div class="line">       STATUS,</div><div class="line">       ID,</div><div class="line">       BODY_SIZE,</div><div class="line">       BODY</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>解码器的构造函数中直接调用了父类的构造函数，将枚举类型<code>State</code>传入。这个枚举类型所代表的就是要解析协议数据中的位置（下标）。因此构造器中传入的当然是协议的第一个字段，也就表示从第一个位置开始解析。然后有一个布尔标识，这个变量从系统变量中获取，用来决定是否使用<code>COMPOSITE_CUMULATOR</code>。默认的CUMULATOR是<code>MERGE_CUMULATOR</code>.区别可能在性能上有点差距吧。具体差异得去研究源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> JProtocolHeader header = <span class="keyword">new</span> JProtocolHeader();</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (state()) &#123;</div><div class="line">            <span class="keyword">case</span> MAGIC:</div><div class="line">                checkMagic(in.readShort());         <span class="comment">// MAGIC</span></div><div class="line">                checkpoint(State.SIGN);</div><div class="line">            <span class="keyword">case</span> SIGN:</div><div class="line">                header.sign(in.readByte());         <span class="comment">// 消息标志位</span></div><div class="line">                checkpoint(State.STATUS);</div><div class="line">            <span class="keyword">case</span> STATUS:</div><div class="line">                header.status(in.readByte());       <span class="comment">// 状态位</span></div><div class="line">                checkpoint(State.ID);</div><div class="line">            <span class="keyword">case</span> ID:</div><div class="line">                header.id(in.readLong());           <span class="comment">// 消息id</span></div><div class="line">                checkpoint(State.BODY_SIZE);</div><div class="line">            <span class="keyword">case</span> BODY_SIZE:</div><div class="line">                header.bodySize(in.readInt());      <span class="comment">// 消息体长度</span></div><div class="line">                checkpoint(State.BODY);</div><div class="line">            <span class="keyword">case</span> BODY:</div><div class="line">                <span class="keyword">switch</span> (header.messageCode()) &#123;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.HEARTBEAT:</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.REQUEST: &#123;</div><div class="line">                        <span class="keyword">int</span> length = checkBodySize(header.bodySize());</div><div class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">                        in.readBytes(bytes);</div><div class="line"></div><div class="line">                        JRequestPayload request = <span class="keyword">new</span> JRequestPayload(header.id());</div><div class="line">                        request.timestamp(SystemClock.millisClock().now());</div><div class="line">                        request.bytes(header.serializerCode(), bytes);</div><div class="line"></div><div class="line">                        out.add(request);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.RESPONSE: &#123;</div><div class="line">                        <span class="keyword">int</span> length = checkBodySize(header.bodySize());</div><div class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">                        in.readBytes(bytes);</div><div class="line"></div><div class="line">                        JResponsePayload response = <span class="keyword">new</span> JResponsePayload(header.id());</div><div class="line">                        response.status(header.status());</div><div class="line">                        response.bytes(header.serializerCode(), bytes);</div><div class="line"></div><div class="line">                        out.add(response);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        <span class="keyword">throw</span> IoSignals.ILLEGAL_SIGN;</div><div class="line">                &#125;</div><div class="line">                checkpoint(State.MAGIC);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>正真的解析逻辑全部在<code>decode</code>方法中。这里的每个case并没有break，道理很简单，每解析一段数据后得接着继续往下解析，如果break掉了后面的数据不全都放弃解析了吗？每当解析到一个位置，都将这个位置上读取的数据放到<code>header</code>变量中，同时将接下来需要解析的位置记录下来（通过<code>checkpoint(...)</code>方法）。之所以要记录下来，万一某个位置解析出错，下次就不用从头再来了，直接上次出错的位置接着来就行了，也是为了提高性能。然而解析到body部分的时候，header里面内容都已经全部填充好了。接下来就是根据消息类型来处理body里的内容。如果是心跳包，那么什么都不做直接返回，因为body里肯定是没有数据的。如果是请求包(<code>REQUEST</code>类型)，先从header里读取这个body到底有多长，然后再去读这么长的数据，最后通过<code>JRequestPayload</code>对象将这个body数据封装起来，同时将消息id和序列化类型code也封装进去了。响应包类型逻辑与之类似。整个解码器解析逻辑就完成了。</p>
<p>与之对应的就是编码器了，编码器逻辑更简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, PayloadHolder msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JRequestPayload) &#123;</div><div class="line">            doEncodeRequest((JRequestPayload) msg, out);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JResponsePayload) &#123;</div><div class="line">            doEncodeResponse((JResponsePayload) msg, out);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Reflects.simpleClassName(msg));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doEncodeRequest</span><span class="params">(JRequestPayload request, ByteBuf out)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> sign = JProtocolHeader.toSign(request.serializerCode(), JProtocolHeader.REQUEST);</div><div class="line">        <span class="keyword">long</span> invokeId = request.invokeId();</div><div class="line">        <span class="keyword">byte</span>[] bytes = request.bytes();</div><div class="line">        <span class="keyword">int</span> length = bytes.length;</div><div class="line"></div><div class="line">        out.writeShort(JProtocolHeader.MAGIC)</div><div class="line">                .writeByte(sign)</div><div class="line">                .writeByte(<span class="number">0x00</span>)</div><div class="line">                .writeLong(invokeId)</div><div class="line">                .writeInt(length)</div><div class="line">                .writeBytes(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doEncodeResponse</span><span class="params">(JResponsePayload response, ByteBuf out)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> sign = JProtocolHeader.toSign(response.serializerCode(), JProtocolHeader.RESPONSE);</div><div class="line">        <span class="keyword">byte</span> status = response.status();</div><div class="line">        <span class="keyword">long</span> invokeId = response.id();</div><div class="line">        <span class="keyword">byte</span>[] bytes = response.bytes();</div><div class="line">        <span class="keyword">int</span> length = bytes.length;</div><div class="line"></div><div class="line">        out.writeShort(JProtocolHeader.MAGIC)</div><div class="line">                .writeByte(sign)</div><div class="line">                .writeByte(status)</div><div class="line">                .writeLong(invokeId)</div><div class="line">                .writeInt(length)</div><div class="line">                .writeBytes(bytes);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>和解码器相反，编码器就是将对象中的数据按协议中的定义挨个写到buf中。</p>
<p>以上，jupiter中的消息编解码器的实现就全部整理完了。当然还有空闲链路检测部分，因此我决定暂时放弃这部分，太复杂了，等所有逻辑整理完毕后再接着填坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中介绍到关于jupiter的底层通信模块transport的部分实现。仅仅只是讨论了整个server的初始化以及启动流程。很多细枝末节其实还没有涉及到，例如tcp参数设置，超时机制，编解码器等等实现细节。这些东西将会逐步被消化分解。而本文的主题是jupiter的业务
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(一)</title>
    <link href="http://www.wei-dong.top/2018/08/08/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%B8%80)/"/>
    <id>http://www.wei-dong.top/2018/08/08/一起学RPC(一)/</id>
    <published>2018-08-08T08:17:23.000Z</published>
    <updated>2018-08-08T08:33:13.567Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中废话了很多“大概”不相关的东西。而这篇就要认认真真的开始讲干货了(也有可能是水货，谁知道呢)。</p>
<p>上一篇文章主要介绍了与rpc中间件相关的但联系不是很大的spring xml标签的自定义实现。可以说是没有太多核心的东西，全文中的关键字就是“抄”。没错，只要有官方文档，什么都能照着抄。实在不行，对着源码的实现也能抄一把。联系到目前的工作中，也是复制粘贴一把梭。不得不说现在的编码要求是越来越低了。</p>
<p>总所周知，rpc顾名思义是远程过程调用，所谓的远程就是不在一个机器上。因此机器与机器之间的可靠通信可以说是rpc的基础设施了。那么本文的重点就是深入剖析这个基础设施的具体实现（的其中一部分，其余的还没认真看）。</p>
<p>在jupiter中，对这些基础设施的设计可算是下了一番功夫的。至少我看明白花了一点时间的。在jupiter的代码组织中，将网络传输这一块单独整成一个模块。很多开源项目也是这样做的，算是中规中矩了。</p>
<p><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/structure-2018-08-01-15-55-21.jpg?raw=true" alt="image"></p>
<p>同时，为了以后的拓展，传输层还定义了一个高层次的抽象模块api。然后根据自己的喜好可以自由去切换传输层实现。这里默认只有基于Netty的实现。如果想添加Mina的实现也很容易，添加Mina依赖然后实现api中的接口就行了。</p>
<p>接下来就仔细探索一下基于Netty的服务端的实现细节。</p>
<h2 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h2><p>jupiter的服务端层次结构十分简单。继承关系也很清晰。这张图很清晰的描述了继承关系：<br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/acceptor-2018-08-01-15-50-40.jpg?raw=true" alt="image"></p>
<p>通过命名可以体现出来这些抽象类或接口的含义。我想写代码的最高境界就是能做到变量名能恰如其分的表达其功用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the transport protocol</div><div class="line">     */</div><div class="line">    <span class="function">Protocol <span class="title">protocol</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传输层协议.</div><div class="line">     */</div><div class="line">    <span class="keyword">enum</span> Protocol &#123;</div><div class="line">        TCP,</div><div class="line">        DOMAIN  <span class="comment">// Unix domain socket</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最高层次的接口仅仅只定义了一个方法，返回到底使用的是什么协议。这里可选的只有TCP或者DOMAIN。关于tcp无需多言，但是这个unix domain socket就不是那么常见了。简单来讲就是用于机器内的通信，不是机器间的通信。具体使用场景我问了一下作者feng.jc，他回复了一个词：service mesh.然后就没有然后了。对此咱暂且不管。</p>
<p>接下来就是比较细化的一个接口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JAcceptor</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 绑定的地址</div><div class="line">     */</div><div class="line">    <span class="function">SocketAddress <span class="title">localAddress</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 绑定的端口.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">boundPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Acceptor options [parent, child].</div><div class="line">     */</div><div class="line">    <span class="function">JConfigGroup <span class="title">configGroup</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回rpc处理器 </div><div class="line">     */</div><div class="line">    <span class="function">ProviderProcessor <span class="title">processor</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置ProviderProcessor 也就是实际的业务逻辑全部由这个东西处理</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withProcessor</span><span class="params">(ProviderProcessor processor)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Start the server and wait until the server socket is closed.</div><div class="line">     * 默认调用start(true)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Start the server.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> sync)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Shutdown the server gracefully.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdownGracefully</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口也很清晰简单。符合一般的思路。接下来就是这些接口的抽象实现。</p>
<h2 id="抽象实现"><a href="#抽象实现" class="headerlink" title="抽象实现"></a>抽象实现</h2><p>在走读抽象实现逻辑之前，有必要看看如果要直接启动这个transporter该怎么做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        JAcceptor acceptor = <span class="keyword">new</span> JNettyTcpAcceptor(<span class="number">9999</span>);</div><div class="line">        acceptor.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>不得不说是非常简单。但是背后的工作可谓是非常多。</p>
<p><code>JNettyTcpAcceptor</code>是最底层的实现类。在实例化的时候会传入参数端口号，这点无可厚非毫无争议。不传也是可以的，因为构造器有重载，会传入默认端口号18090。而实际上是去调用的父类的构造器。父类构造器的重载方法很多，就贴出一个全参数的重载实现,其余的请自行脑补。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyTcpAcceptor</span><span class="params">(SocketAddress localAddress, <span class="keyword">int</span> nBosses, <span class="keyword">int</span> nWorkers, <span class="keyword">boolean</span> isNative)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Protocol.TCP, localAddress, nBosses, nWorkers);</div><div class="line">        <span class="keyword">this</span>.isNative = isNative;</div><div class="line">        init();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然而恶心心的是这个构造器也去调用父类的构造函数。对于聪明的人来说这都不是事儿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyAcceptor</span><span class="params">(Protocol protocol, SocketAddress localAddress, <span class="keyword">int</span> nBosses, <span class="keyword">int</span> nWorkers)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.protocol = protocol;</div><div class="line">        <span class="keyword">this</span>.localAddress = localAddress;</div><div class="line">        <span class="keyword">this</span>.nBosses = nBosses;</div><div class="line">        <span class="keyword">this</span>.nWorkers = nWorkers;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>值得一提的仅仅只有后面两个参数。顾名思义代表的是boss的线程数和worker的线程数。如果对netty很熟悉这点就不需要解释太多。然后就是<code>init()</code>方法了。这个init方法的核心实现实际上是在顶层父类中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        ThreadFactory bossFactory = bossThreadFactory(<span class="string">"jupiter.acceptor.boss"</span>);</div><div class="line">        ThreadFactory workerFactory = workerThreadFactory(<span class="string">"jupiter.acceptor.worker"</span>);</div><div class="line">        boss = initEventLoopGroup(nBosses, bossFactory);</div><div class="line">        worker = initEventLoopGroup(nWorkers, workerFactory);</div><div class="line"></div><div class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap().group(boss, worker);</div><div class="line"></div><div class="line">        <span class="comment">// parent options</span></div><div class="line">        JConfig parent = configGroup().parent();</div><div class="line">        parent.setOption(JOption.IO_RATIO, <span class="number">100</span>);</div><div class="line"></div><div class="line">        <span class="comment">// child options</span></div><div class="line">        JConfig child = configGroup().child();</div><div class="line">        child.setOption(JOption.IO_RATIO, <span class="number">100</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码做了3件事。创建了boss和worker；实例化了ServerBootstrap；把参数配置起来了。仅仅只做了这些事情，很符合抽象类的风格。需要细化的操作请继承，然后自定义实现，爱咋咋地。反正最后肯定会去调用的子类实现，前提是别把我全部覆盖掉，增量去拓展就行。</p>
<p>说了这么多，实际上抽象实现就是对server的“大致”实现。具体的定制得交给子类完成。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>在上面的demo中实例化的一定是一个具体子类。子类通过一系列父类中的初始化方法完成了前期的准备工作：tcp参数设置、boss和worker的设置等。而正真开启一个server的方法是<code>start()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">       start(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> sync)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">       <span class="comment">// wait until the server socket is bind succeed.</span></div><div class="line">       ChannelFuture future = bind(localAddress).sync();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">           logger.info(<span class="string">"Jupiter TCP server start"</span> + (sync ? <span class="string">", and waits until the server socket closed."</span> : <span class="string">"."</span>)</div><div class="line">                   + JConstants.NEWLINE + <span class="string">" &#123;&#125;."</span>, toString());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (sync) &#123;</div><div class="line">           <span class="comment">// wait until the server socket is closed.</span></div><div class="line">           future.channel().closeFuture().sync();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><code>start()</code>方法只是入口，核心是<code>bind()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</div><div class="line">       ServerBootstrap boot = bootstrap();</div><div class="line"></div><div class="line">       initChannelFactory();</div><div class="line"></div><div class="line">       boot.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               ch.pipeline().addLast(</div><div class="line">                       <span class="keyword">new</span> IdleStateChecker(timer, JConstants.READER_IDLE_TIME_SECONDS, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                       idleStateTrigger,</div><div class="line">                       CodecConfig.isCodecLowCopy() ? <span class="keyword">new</span> LowCopyProtocolDecoder() : <span class="keyword">new</span> ProtocolDecoder(),</div><div class="line">                       encoder,</div><div class="line">                       handler);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       setOptions();</div><div class="line"></div><div class="line">       <span class="keyword">return</span> boot.bind(localAddress);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannelFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">       SocketChannelProvider.SocketType socketType = socketType();</div><div class="line">       <span class="keyword">switch</span> (socketType) &#123;</div><div class="line">           <span class="keyword">case</span> NATIVE_EPOLL:</div><div class="line">               bootstrap().channelFactory(SocketChannelProvider.NATIVE_EPOLL_ACCEPTOR);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> NATIVE_KQUEUE:</div><div class="line">               bootstrap().channelFactory(SocketChannelProvider.NATIVE_KQUEUE_ACCEPTOR);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> JAVA_NIO:</div><div class="line">               bootstrap().channelFactory(SocketChannelProvider.JAVA_NIO_ACCEPTOR);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid socket type: "</span> + socketType);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>不得不说，bind方法层次也很清晰。其中调用了一个<code>initChannelFactory()</code>方法，其实没有什么高深莫测的地方。简单理解为和下面的代码类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</div></pre></td></tr></table></figure>
<p>到此为止，整个server的启动流程就结束了。整个流程十分干净，没有任何涉及到业务的地方。可能稍微有一点和业务沾边的地方就是编解码器。这个的确是完全耦合到这个acceptor中去的，也就是说如果你想单纯的去用这个acceptor是不行的。因为只能针对特定的网络数据格式进行处理。但是针对这个项目而言是没有任何问题的，我想也没有人会仅仅去用其中的acceptor，再说也不是提供给开发者用的，这是给自己用的。</p>
<p>当然，其中的比较核心的东西没有去分析。因为实在是很复杂。我打算采用抽丝剥茧的方式将其逐步细化，毕竟害怕贪多嚼不烂。接下来要讨论的是jupiter的业务编解码器的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中废话了很多“大概”不相关的东西。而这篇就要认认真真的开始讲干货了(也有可能是水货，谁知道呢)。&lt;/p&gt;
&lt;p&gt;上一篇文章主要介绍了与rpc中间件相关的但联系不是很大的spring xml标签的自定义实现。可以说是没有太多核心的东西，全文中的关键字就是“抄”。没错，
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(零)</title>
    <link href="http://www.wei-dong.top/2018/08/06/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E9%9B%B6)/"/>
    <id>http://www.wei-dong.top/2018/08/06/一起学RPC(零)/</id>
    <published>2018-08-06T08:17:23.000Z</published>
    <updated>2018-08-06T05:55:33.640Z</updated>
    
    <content type="html"><![CDATA[<p>最近又重新开始看jupiter的源码。这个开源项目是阿里的一位大神写的，比起现在较为流行的dubbo、motan等生产上的开源软件来说轻量很多，也比较容易入门学习。本来想看看dubbo的源码的，无奈第一步都没卖出去，被extension机制给难住了。虽说目前dubbo已经成为apache的孵化项目了，对于研究源码的渣渣我来说还是有一定的难度的。于是退而求其次，jupiter就是一个比较容易入手的选择。为什么说这个jupiter比较容易入门呢？首先代码比较少，不是很多，对阅读来说不会有很多绕的地方。其次这个项目有很多热心的网友也在一起读，可以有很多交流的地方，有一个专门讨论jupiter的交流群，可以很方便的和各路大神交流学习。</p>
<p>因为jupiter源码我没有完全读完，只能看一点写一点。说不定等看完源码后再重新整理一下行文结构呢，也说不定放弃了呢，谁知道呢？</p>
<p>按照常规思路来说肯定是从一个demo来入门，但是我不决定这么做，因为如果对rpc熟悉的伙计一定知道怎么去玩，不知道怎么去玩的现在可以关掉浏览器打lol或者吃鸡去了，因为你不配。没错，就是这么傲娇。</p>
<p>看了这么多java rpc的框架比如motan、dubbo和jupiter，都有一个共同的地方，他们都使用spring作为容器来集成。这样也是情有可原，我相信java应用中没有不使用spring的吧。因此都选择这样去做大概是因为这样很容易去集成到自己的项目中。当然，这类rpc框架并不是一定得和spring集成。把他们称为“框架”其实并不是很准确。更准确的应该称为“中间件”。我的理解是因为他们虽然是集成到自己的项目代码中，但是他们却占用独立的端口。</p>
<p>spring目前在java开发中的地位很高，使用spring来管理bean是非常流行的做法。更重要的是非常方便。对于中间件来说，通过寥寥几行xml的描述就能将一个复杂的bean实例化出来，而且耦合度很低，何乐而不为呢？看一个sonsumer的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"globalInterceptor1"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyGlobalConsumerInterceptor1"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"globalInterceptor2"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyGlobalConsumerInterceptor2"</span> /&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">jupiter:client</span> <span class="attr">id</span>=<span class="string">"jupiterClient"</span> <span class="attr">registryType</span>=<span class="string">"default"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">registryServerAddresses</span>=<span class="string">"127.0.0.1:20001"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">globalConsumerInterceptors</span>=<span class="string">"globalInterceptor1,globalInterceptor2"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 可选配置 --&gt;</span></div><div class="line">       <span class="comment">&lt;!--</span></div><div class="line">           String registryServerAddresses                          // 注册中心地址 [host1:port1,host2:port2....]</div><div class="line">           String providerServerAddresses                          // IP直连到providers [host1:port1,host2:port2....]</div><div class="line">           ConsumerInterceptor[] globalConsumerInterceptors;       // 全局拦截器</div><div class="line">       --&gt;</div><div class="line"></div><div class="line">       <span class="comment">&lt;!-- 网络层配置选项 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:netOptions</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:childOption</span> <span class="attr">SO_RCVBUF</span>=<span class="string">"8192"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:childOption</span> <span class="attr">SO_SNDBUF</span>=<span class="string">"8192"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:childOption</span> <span class="attr">ALLOW_HALF_CLOSURE</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">jupiter:netOptions</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">jupiter:client</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyConsumerInterceptor1"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyConsumerInterceptor2"</span> /&gt;</span></div><div class="line"></div><div class="line">   <span class="comment">&lt;!-- consumer --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">jupiter:consumer</span> <span class="attr">id</span>=<span class="string">"serviceTest"</span> <span class="attr">client</span>=<span class="string">"jupiterClient"</span> <span class="attr">interfaceClass</span>=<span class="string">"org.jupiter.example.ServiceTest"</span>&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 以下都选项可不填 --&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 服务版本号, 通常在接口不兼容时版本号才需要升级 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">version</span>=<span class="string">"1.0.0.daily"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 序列化/反序列化类型: (proto_stuff, hessian, kryo, java)可选, 默认proto_stuff --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">serializerType</span>=<span class="string">"proto_stuff"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 软负载均衡类型[random, round_robin] --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">loadBalancerType</span>=<span class="string">"round_robin"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 派发方式: (round, broadcast)可选, 默认round(单播) --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">dispatchType</span>=<span class="string">"round"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 调用方式: (sync, async)可选, 默认sync(同步调用) --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">invokeType</span>=<span class="string">"sync"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 集群容错策略: (fail_fast, fail_over, fail_safe)可选, 默认fail_fast(快速失败) --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">clusterStrategy</span>=<span class="string">"fail_over"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 在fail_over策略下的失败重试次数 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">failoverRetries</span>=<span class="string">"2"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 超时时间设置 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">timeoutMillis</span>=<span class="string">"3000"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:methodSpecials</span>&gt;</span></div><div class="line">           <span class="comment">&lt;!-- 方法的单独配置 --&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:methodSpecial</span> <span class="attr">methodName</span>=<span class="string">"sayHello"</span> <span class="attr">timeoutMillis</span>=<span class="string">"5000"</span> <span class="attr">clusterStrategy</span>=<span class="string">"fail_fast"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">jupiter:methodSpecials</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">consumerInterceptors</span>=<span class="string">"interceptor1,interceptor2"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 可选配置 --&gt;</span></div><div class="line">       <span class="comment">&lt;!--</span></div><div class="line">           SerializerType serializerType                   // 序列化/反序列化方式</div><div class="line">           LoadBalancerType loadBalancerType               // 软负载均衡类型[random, round_robin]</div><div class="line">           long waitForAvailableTimeoutMillis = -1         // 如果大于0, 表示阻塞等待直到连接可用并且该值为等待时间</div><div class="line">           InvokeType invokeType                           // 调用方式 [同步, 异步]</div><div class="line">           DispatchType dispatchType                       // 派发方式 [单播, 广播]</div><div class="line">           long timeoutMillis                              // 调用超时时间设置</div><div class="line">           List&lt;MethodSpecialConfig&gt; methodSpecialConfigs; // 指定方法的单独配置, 方法参数类型不做区别对待</div><div class="line">           ConsumerInterceptor[] consumerInterceptors      // 消费者端拦截器</div><div class="line">           String providerAddresses                        // provider地址列表, 逗号分隔(IP直连)</div><div class="line">           ClusterInvoker.Strategy clusterStrategy;        // 集群容错策略</div><div class="line">           int failoverRetries                             // fail_over的重试次数</div><div class="line">       --&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">jupiter:consumer</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对于一个相对比较成熟的rpc中间件来说，核心的bean配置是比较复杂的。你看看其中的参数就知道。通过spring的这种xml描述文件起码能够稍微容易地理解到一个bean需要哪些参数，哪些可以不要，同时根据xsd的约束能够让开发者更清楚的知道自己的配置有什么问题。如果不给api文档的情况下干巴巴的给你一个类，让你去实例化这个复杂的class，我相信很多人都会抓狂。在这个配置文件中很容易的看出要有2个节点：client和consumer。子节点的内容就是参数。consumer会去引用client去执行一个请求。而我们的业务中直接去调用consumer就完事了。如此而已，简单直观。</p>
<p>这里的spring xml配置使用的是自定义的标签，算是对spring的拓展。不仅是jupiter，基本上大多数rpc中间件都实现了自己的一套标签，似乎不去自己实现一套自定义标签都不好意思开源。比如dubbo的自定义标签就是<code>&lt;dubbo:xxx&gt;</code>，motan类似如此。然而实际上也不是必须得实现自定义标签，使用spring的bean也是可以的，只不过显得很臃肿，不是那么直观罢了。</p>
<p>对于一个新手来讲，这些东西显得格外的高大上。其实里面没有什么黑魔法，在spring的reference中对自定义标签有介绍。感兴趣的去看看这个官方文档：<a href="https://docs.spring.io/spring/docs/4.3.19.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#xml-custom" target="_blank" rel="external">spring xml extension</a>.</p>
<p>要实现一个自定义的spring xml标签需要做一下几个步骤：</p>
<ul>
<li>定义一个约束文件，用来规范xml的内容。现在都流行使用xsd去编写约束文件，dtd已经成为老古董了。<a href="http://www.w3school.com.cn/schema/schema_intro.asp" target="_blank" rel="external">xsd了解一下</a>.</li>
<li>自定义一个<code>NamespaceHandler</code>的实现。实际上是去实现这个接口。非常容易，复制粘贴一把梭。</li>
<li>写一个或者多个<code>BeanDefinitionParser</code>的实现。也是去实现接口，当然继承抽象类也是ok的。这个是最核心的内容。</li>
<li>将上面所定义的全部注册到spring中，让spring知道有这些玩意儿。也就是在<code>META-INF</code>文件夹下新增两个配置文件：<code>spring.handlers</code>和<code>spring.schemas</code></li>
</ul>
<p>下面就结合jupiter中自定义的spring标签来谈谈他是如何实现的。</p>
<p>首先得定义xsd约束文件,完整的定义在<a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-spring-support/src/main/resources/jupiter.xsd" target="_blank" rel="external">这里</a>.这个没什么好说的，枯燥的xml定义罢了。无非就是定义有哪些元素，哪些元素下有哪些属性，其中有没有子元素，属性类型是什么，是不是必填的等等。</p>
<p>接下来就是配置一个<code>handler</code>。这个handler用来解析自定义的标签。用过spring都知道，除了最常见的bean标签还有很多其他的标签，比如<code>&lt;context:component-scan&gt;</code>、<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt;</code>以及<code>&lt;mvc:annotation-driven/&gt;</code>等。这些标签和bean标签的不同之处在于都有一个前缀。我们称这个叫做命名空间。然而自定义的当然也得加上命名空间。虽说不能和bean平起平坐，但是和aop、context这样的标签还是可以一视同仁的。</p>
<p>基于这种思路，那就很容易来自定义自己的标签了。难怪文档中对这个步骤加了一个说明：</p>
<blockquote>
<p>Coding a custom NamespaceHandler implementation (this is an easy step, don’t worry).</p>
</blockquote>
<p>的确如此，常人的思路就是照着spring的实现抄一把。如此简单！</p>
<p>而比较复杂的就是对<code>BeanDefinitionParser</code>的实现了。这个是最核心的步骤。根据文档中的描述，这个可以有一个或者多个。但是在jupiter中只定义了一个实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JupiterNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        registerBeanDefinitionParser(<span class="string">"server"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringServer.class));</div><div class="line">        registerBeanDefinitionParser(<span class="string">"client"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringClient.class));</div><div class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringProviderBean.class));</div><div class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringConsumerBean.class));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>spring的<code>TaskNamespaceHandler</code>中就使用了多个paser：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"executor"</span>, <span class="keyword">new</span> ExecutorBeanDefinitionParser());</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"scheduled-tasks"</span>, <span class="keyword">new</span> ScheduledTasksBeanDefinitionParser());</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"scheduler"</span>, <span class="keyword">new</span> SchedulerBeanDefinitionParser());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个paser用通俗的话来解释就是将在xml的配置参数给set到相应的实例中去。举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">getBeanClass</span><span class="params">(Element element)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SimpleDateFormat.class; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder bean)</span> </span>&#123;</div><div class="line">        <span class="comment">// this will never be null since the schema explicitly requires that a value be supplied</span></div><div class="line">        String pattern = element.getAttribute(<span class="string">"pattern"</span>);</div><div class="line">        bean.addConstructorArg(pattern);</div><div class="line"></div><div class="line">        <span class="comment">// this however is an optional property</span></div><div class="line">        String lenient = element.getAttribute(<span class="string">"lenient"</span>);</div><div class="line">        <span class="keyword">if</span> (StringUtils.hasText(lenient)) &#123;</div><div class="line">            bean.addPropertyValue(<span class="string">"lenient"</span>, Boolean.valueOf(lenient));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个栗子是继承自<code>AbstractSingleBeanDefinitionParser</code>并没有去实现<code>BeanDefinitionParser</code>接口。道理都知道，没有必要去实现一个要啥没啥的接口，吃现成的就好。重写父类的<code>getBeanClass</code>方法，将需要纳入spring管理的对象返回掉。这里不仅仅可以重写这个方法，还有其他例如<code>getBeanClassName</code>也行。值得注意的是如果采用继承抽象类的方式，这两个方法必须选择一个来重写。这个也非常容易理解，因为这个方法返回的class实例或者类的全路径名就是用来实例化的对象。如果通过实现接口的方式来定义paser就不需要考虑这个规则了，只需要创建出<code>BeanDefinition</code>的实例即可。jupiter中就是采用实现接口的方式，因为继承抽象类有一定的局限性，实现接口会有更多的灵活性。</p>
<p>有了要煮饭的锅，就差下锅的米了。这个栗子中重写父类的<code>doParser</code>方法。从代码的表现上来看实际上就是将xml配置文件中的属性获取到，然后做一下检查放到实例化的对象中去。当然这里没有那么直接，这里使用的是<code>BeanDefinitionBuilder</code>来操作的。这只是最简单的实现。</p>
<p>复杂的parser都是自己去实现接口的。比如jupiter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JupiterBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JupiterBeanDefinitionParser</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanClass = beanClass;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (beanClass == JupiterSpringServer.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterServer(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanClass == JupiterSpringClient.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterClient(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanClass == JupiterSpringProviderBean.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterProvider(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanClass == JupiterSpringConsumerBean.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterConsumer(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Unknown class to definition: "</span> + beanClass.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jupiter的自定义parser中需要纳入spring管理的bean class对象是通过构造器传进来的。根据不同的class来作不同的处理。其中具体的逻辑很枯燥无味，就不再细细探讨了。不过我在看源码的过程中发现了一个细节的地方，也是值得注意的地方。</p>
<p><code>JupiterSpringConsumerBean</code>不仅仅和其他(如<code>JupiterSpringServer</code>等)实现<code>InitializingBean</code>，还实现了一个叫做<code>FactoryBean</code>的接口。这说明了一个问题，这个bean不是普通的bean，而是一个factory bean。相信很多人都会疑惑factory bean 和bean factory有什么区别。要我说两者都没有直接的联系，如果在面试的时候有人问我这个问题，我一定直接怼回去：雷锋和雷峰塔有什么区别？言归正传，这个factory bean本质上也是bean，但是与其他bean不同的是这个bean在spring容器中获取的方式和别的不一样。通常在spring中获取一个bean采用<code>ctx.getBean(xxx.class)</code>方法。通过这个方法获取的factory bean并不是他自己，而是它的某个成员。可以看看这个接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    Class&lt;?&gt; getObjectType();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说返回的对象是<code>getObject()</code>返回值。那么这个接口存在的意义是什么呢？我也不复制粘贴了，觉着<a href="https://www.jianshu.com/p/6f0a59623090" target="_blank" rel="external">这篇文章</a>写得很不错，浅显易懂。那么如何获取这个bean本身呢？干嘛想着获取它本身，简直是无聊！也有方法，加个前缀”&amp;”就行了(<code>ctx.getBean(&quot;&amp;sb&quot;)</code>)。</p>
<p>最后呢，就是照着spring的官方文档抄一下配置文件。依葫芦画瓢，非常简单。</p>
<p>完成了以上的几个步骤，自定义的spring xml标签就大功告成了。接下来要做的就是去使用自定义的标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:myns</span>=<span class="string">"http://www.mycompany.com/schema/myns"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- as a top-level bean --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">myns:dateformat</span> <span class="attr">id</span>=<span class="string">"defaultDateFormat"</span> <span class="attr">pattern</span>=<span class="string">"yyyy-MM-dd HH:mm"</span> <span class="attr">lenient</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jobDetailTemplate"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- as an inner bean --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">myns:dateformat</span> <span class="attr">pattern</span>=<span class="string">"HH:mm MM-dd-yyyy"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里是抄的官方文档的栗子。标签<code>myns:dateformat</code>实际上定义了一个<code>SimpleDateFormat</code>的bean实例。在spring容器加载的时候这个实例就回被初始化。在使用自定义的标签的时候，需要注意的是得声明好命名空间和指定location，不然会报无法找到这个标签的错误。其实这些东西照着抄就行了，只是不要忘记了或者抄错了。</p>
<p>自定义spring xml标签如此简单。无非就是照着文档抄一把，自己再改吧改吧万事就大吉了。对于其中核心的东西实际上还是一知半解，比方说<code>BeanDefinition</code>的具体实现原理等。上层的封装太抽象了，留给开发者的仅仅只是一个需要实现的方法。要想知道为什么要这样做，还得去研究spring的源码。</p>
<p>rpc中的最简单的一个可选模块就这样简单的实现了。这是一小步，也是一大步。接下来会继续探索稍微核心一点的jupiter实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又重新开始看jupiter的源码。这个开源项目是阿里的一位大神写的，比起现在较为流行的dubbo、motan等生产上的开源软件来说轻量很多，也比较容易入门学习。本来想看看dubbo的源码的，无奈第一步都没卖出去，被extension机制给难住了。虽说目前dubbo已经成
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>浅析JDK中的定时器Timer实现</title>
    <link href="http://www.wei-dong.top/2018/04/21/Timer/"/>
    <id>http://www.wei-dong.top/2018/04/21/Timer/</id>
    <published>2018-04-21T08:17:23.000Z</published>
    <updated>2018-05-17T06:30:16.624Z</updated>
    
    <content type="html"><![CDATA[<p>在jdk中处理定时任务工具类中有2种：Timer和ScheduledExecutorService。前者是在java.util包中，从1.3版本开始，属于比较老的工具类了。而ScheduledExecutorService属于java.util.concurrent包，作者是老爷子Doug Lea，1.5版本开始才有。虽然现在大多使用ScheduledExecutorService，但是我觉得很有必要对其“同宗”Timer的实现进行解读。</p>
<h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>官方文档中的解释是这样的：</p>
<blockquote>
<p>A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.</p>
</blockquote>
<p>线程的工具，用于在后台线程中安排将来执行的任务。 可以安排一次性执行任务，或定期重复执行任务。</p>
<blockquote>
<p>This class is thread-safe: multiple threads can share a single Timer object without the need for external synchronization.<br>This class does not offer real-time guarantees: it schedules tasks using the Object.wait(long) method.<br>Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn’t require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer.</p>
</blockquote>
<p>这个类是线程安全的，但不能保证是实时的，因为使用的是wait方法来调度任务。文档还说了建议使用JUC下的ScheduledThreadPoolExecutor（ScheduledExecutorService的实现）类来处理定时任务，这个类提供的功能更多，参数更灵活，而且是多线程的。当线程池size指定为一那就和Timer一个样了。</p>
<p>下面通过一个demo来展示一下相关api的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkTimerDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="string">"timer-demo"</span>);</div><div class="line">        MyTask[] tasks = <span class="keyword">new</span> MyTask[<span class="number">20</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</div><div class="line">            tasks[i] = <span class="keyword">new</span> MyTask(i);</div><div class="line">            System.out.println(<span class="string">"time no "</span> + i + <span class="string">" task start at "</span> + <span class="keyword">new</span> Date());</div><div class="line">            timer.schedule(tasks[i], <span class="number">2</span> * <span class="number">1000</span>, <span class="number">3</span> * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"timer started at: "</span> + <span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> timeNo;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> timeNo)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.timeNo = timeNo;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果任务出现异常不被捕获，其他任务不会被执行</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (timeNo == <span class="number">8</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"time no "</span> + timeNo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个demo展示一个Timer的弊端。当任务中出现未被捕获的异常，接下来的任务都不会被执行，定时器crash掉。这个demo中定义了20个task交给timer调度，timer启动2秒后开始执行任务，每隔3秒执行一次。接下来就跟着demo一步一步看看其中的实现原理。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>首先看看构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name, <span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.setDaemon(isDaemon);</div><div class="line">    thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器的参数代表着timer的名字和这个timer是否是后台运行的（timer本质上是一个线程）。一旦实例化就将这个线程给启动了。这个线程是核心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</div></pre></td></tr></table></figure>
<p>可以看到这个成员属性TimerThread内部维护着一个queue。这个queue上什么稍后再讲。</p>
<p>实例化结束后就得调用它的schedule方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</div><div class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</div><div class="line">    sched(task, System.currentTimeMillis()+delay, -period);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 核心的是这段逻辑</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Constrain value of period sufficiently to prevent numeric</span></div><div class="line">    <span class="comment">// overflow while still being effectively infinitely large.</span></div><div class="line">    <span class="comment">// 防止溢出 如果周期比最大值的一半还大 那就将其除以2 道理何在？</span></div><div class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</div><div class="line">        period &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">            <span class="comment">// 如果任务状态不为新创建的 直接抛异常</span></div><div class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Task already scheduled or cancelled"</span>);</div><div class="line">            <span class="comment">// 设置任务下次执行时间 执行周期 以及 状态</span></div><div class="line">            task.nextExecutionTime = time;</div><div class="line">            task.period = period;</div><div class="line">            task.state = TimerTask.SCHEDULED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		  <span class="comment">// 任务实际上是放在队列中 并不是直接执行的 </span></div><div class="line">        queue.add(task);</div><div class="line">        <span class="comment">// 为什么需要queue.getMin() == task时才调用notify方法呢？</span></div><div class="line">        <span class="keyword">if</span> (queue.getMin() == task)</div><div class="line">            queue.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看似简单，但也是有点门道的。在设置任务属性的时候采用加锁，避免并发下把不同任务的执行周期等参数搞混乱了。添加任务到队列中也使用了加锁，实际上是针对add方法加的锁。保证add任务不出乱（这个队列不是安全的队列）。最后有个判断，为什么需要queue.getMin() == task时才调用notify方法呢？因为只有新加入的task是所有Task中要被最早执行的task时，才会需要打断TimeThread的等待状态。举个例子，当前队列中有两个task，分别是A（3分钟后到时间）、B（5分钟后到时间），此时TimerThread正在等待A的时间到来，所以会调用queue.wait(3min)，这个时候，队列中新增一个任务C（1分钟后到时），如果不打断queue.wait(3min)，那当wait(3min)自然结束时，C任务已经过期了… 但是如果新加入的C任务是需要在4分钟后执行，那就没必要打断wait(3min)的状态，因为就算wait(3min)自然结束时，C也还没到时间.</p>
<h5 id="任务是什么"><a href="#任务是什么" class="headerlink" title="任务是什么"></a>任务是什么</h5><p>说了这么久，还没弄清楚这个任务是个什么玩意？按照直觉说到任务第一想到就是Runnable对象，但是也有其他情况下不是这样的。然而这个任务确实是个Runnable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">// 对象锁</span></div><div class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line">   </div><div class="line">    <span class="comment">// 任务状态 新建 已调度 已执行 已取消</span></div><div class="line">    <span class="comment">// 默认是新建</span></div><div class="line">    <span class="keyword">int</span> state = VIRGIN;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRGIN = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULED   = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTED    = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">3</span>;</div><div class="line">	 <span class="comment">// 下次执行的时间</span></div><div class="line">    <span class="keyword">long</span> nextExecutionTime;</div><div class="line">	 <span class="comment">// 周期</span></div><div class="line">    <span class="keyword">long</span> period = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TimerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">boolean</span> result = (state == SCHEDULED);</div><div class="line">            state = CANCELLED;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">scheduledExecutionTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">return</span> (period &lt; <span class="number">0</span> ? nextExecutionTime + period</div><div class="line">                               : nextExecutionTime - period);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TimeTask对Runnable进行简单封装。暴露出抽象的run方法让用户的具体实现类去完成。同时提供了取消任务的方法。和JUC中不同的是这里状态的转化非常简单，没有JUC中动不动就用CAS的骚操作。老版本的代码就是好理解些。</p>
<h5 id="任务的调度（定时器的核心）"><a href="#任务的调度（定时器的核心）" class="headerlink" title="任务的调度（定时器的核心）"></a>任务的调度（定时器的核心）</h5><p>既然都知道任务是什么了，接下来看看队列中的任务是怎么被取出来和执行的。首先得看看这个线程是个什么样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">// 标记这个线程是不是要被挂起</span></div><div class="line">    <span class="keyword">boolean</span> newTasksMayBeScheduled = <span class="keyword">true</span>;</div><div class="line">	 <span class="comment">// 维护一个队列 用于存放任务的队列</span></div><div class="line">    <span class="keyword">private</span> TaskQueue queue;</div><div class="line"></div><div class="line">    TimerThread(TaskQueue queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mainLoop();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></div><div class="line">            <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">                queue.clear();  <span class="comment">// Eliminate obsolete references</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 具体执行核心逻辑 开死循环跑</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimerTask task;</div><div class="line">                <span class="keyword">boolean</span> taskFired;</div><div class="line">                <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                    <span class="comment">// Wait for queue to become non-empty</span></div><div class="line">                    <span class="comment">// 如果队列中没有任务，而且定时器没有被取消（默认为true，只有将timer取消cancel方法调用的时候将其置为false，还有一个地方） 就得将这个线程挂起 不然就造成了死循环 cpu直接上100%</span></div><div class="line">                    <span class="comment">// 而唤起的地方只有cancel方法和threadReaper</span></div><div class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</div><div class="line">                        queue.wait();</div><div class="line">                    <span class="comment">// 任务队列空了 定时器取消了 跳出循环 线程结束</span></div><div class="line">                    <span class="keyword">if</span> (queue.isEmpty())</div><div class="line">                        <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></div><div class="line"></div><div class="line">                    <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></div><div class="line">                    <span class="keyword">long</span> currentTime, executionTime;</div><div class="line">                    <span class="comment">// 从队列中取出最delay时间最小的任务 得最早执行的任务</span></div><div class="line">                    task = queue.getMin();</div><div class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">                    	 <span class="comment">// 任务取消了，将其移出队列 继续取下一个</span></div><div class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</div><div class="line">                            queue.removeMin();</div><div class="line">                            <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// currentTimeMillis()返回以毫秒为单位的当前时间，返回的是当前时间与1970 年 1 月 1 日午夜之间的时间差</span></div><div class="line">                        currentTime = System.currentTimeMillis();</div><div class="line">                        executionTime = task.nextExecutionTime;</div><div class="line">                        <span class="comment">// 如果给定的到期时间小于当前时间（1970-01-01到现在的差值）说明任务到期了 需要被执行 把taskFired置为true</span></div><div class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</div><div class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></div><div class="line">                            	  <span class="comment">// 不是周期执行的任务 直接从队列中移除掉 将任务状态置为已执行</span></div><div class="line">                                queue.removeMin();</div><div class="line">                                task.state = TimerTask.EXECUTED;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></div><div class="line">                                <span class="comment">// 是周期任务 重新计算下次执行的时间 即当前时间+间隔时间为下次任务执行的时间</span></div><div class="line">                                <span class="comment">// 这里是➖因为之前传进来的是一个负值</span></div><div class="line">                                queue.rescheduleMin(</div><div class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</div><div class="line">                                                : executionTime + task.period);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果没到期 就等一个delay长的时间</span></div><div class="line">                    <span class="comment">// executionTime  = System.currentTimeMillis()+delay</span></div><div class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></div><div class="line">                        queue.wait(executionTime - currentTime);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 任务启动 执行业务逻辑</span></div><div class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></div><div class="line">                    task.run();</div><div class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="小疑惑"><a href="#小疑惑" class="headerlink" title="小疑惑"></a>小疑惑</h5><p>整个定时器的核心逻辑在代码注释中都一一解释了。其中一个细节：变量newTasksMayBeScheduled用来做什么的。<br>首先得看看它的值被置为false的情形在哪些地方出现。</p>
<ul>
<li>Timer#cancel方法</li>
<li>TimerThread的mainloop执行完了finally块中</li>
<li>Timer的成员属性threadReaper的finalize方法中</li>
</ul>
<p>前两者都不必多解释，值得注意的是最后一种情况。这种写法我还是第一次见，还不明白其中的玄机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This object causes the timer's task execution thread to exit</div><div class="line"> * gracefully when there are no live references to the Timer object and no</div><div class="line"> * tasks in the timer queue.  It is used in preference to a finalizer on</div><div class="line"> * Timer as such a finalizer would be susceptible to a subclass's</div><div class="line"> * finalizer forgetting to call it.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object threadReaper = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">            thread.newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">            queue.notify(); <span class="comment">// In case queue is empty.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当queue为空，并且没人调用add或cancel方法时，TimerThread永远都不会stop，那么还有别的可能吗？</p>
<p>上述的做法就提供了另外的思路。当队列中没有任务的时候，TimerThread会wait，如果不手动调用cancel这个线程一直会挂起。聪明的jdk就提供了上述的方法。当在GC的时候会触发finalize方法调用，那什么时候会触发GC呢？当Timer对象没有被任何对象引用的时候如果有GC那么这段代码被调用：newTasksMayBeScheduled置为false同时将挂起的TimerThread唤醒，这时候mainloop死循环就跳出了，TimerThread线程结束！</p>
<p>具体验证可以使用Jprofile这个工具。事实上确实可行。但是通过这段代码让我联想到一个这个定时器的弊端：没做到像ExecutorService能够等到任务全部执行完成后再将其关闭。手动关闭只能通过cancel这种粗暴的方式,还好jdk工程师提供这样一个“后门”，交给jvm来管理。这也不失为一种补救措施，但是对于之后的JUC而言，这种做法显得有点“小儿科”了。但是对于学习者而言，这种代码组织显得更容易读懂，设计思想很容易呈现在我们面前。时代不断进步，总会有好的设计来取代老的旧的东西。并不是意味着老的旧的真正被取代，而是以另外一种价值呈现在我们后来人面前。通过比较，我们可能会更加理解什么是好的设计。</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>整个Timer定时任务的核心逻辑就梳理完了。其中有一些细节被忽略掉了，比如这个任务队列queue的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * This class represents a timer task queue: a priority queue of TimerTasks,</div><div class="line"> * ordered on nextExecutionTime.  Each Timer object has one of these, which it</div><div class="line"> * shares with its TimerThread.  Internally this class uses a heap, which</div><div class="line"> * offers log(n) performance for the add, removeMin and rescheduleMin</div><div class="line"> * operations, and constant time performance for the getMin operation.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护一个长度为128的数组</span></div><div class="line">    <span class="keyword">private</span> TimerTask[] queue = <span class="keyword">new</span> TimerTask[<span class="number">128</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 队列长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Adds a new task to the priority queue.</div><div class="line">     * 当前队列长度为最大长度-1的时候就进行扩容 新队列长度为当前2倍</div><div class="line">     * 为什么要在最大长度-1的时候扩容呢？因为不提前扩容当前的元素加不进去😂</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TimerTask task)</span> </span>&#123;</div><div class="line">        <span class="comment">// Grow backing store if necessary</span></div><div class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> == queue.length)</div><div class="line">            queue = Arrays.copyOf(queue, <span class="number">2</span>*queue.length);</div><div class="line"></div><div class="line">        queue[++size] = task;</div><div class="line">        fixUp(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function">TimerTask <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下标从1开始取</span></div><div class="line">    <span class="function">TimerTask <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 移除第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra reference to prevent memory leak</span></div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickRemove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> i &lt;= size;</div><div class="line"></div><div class="line">        queue[i] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra ref to prevent memory leak</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 改第一个元素的到期时间属性</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rescheduleMin</span><span class="params">(<span class="keyword">long</span> newTime)</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>].nextExecutionTime = newTime;</div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Null out task references to prevent memory leak</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=size; i++)</div><div class="line">            queue[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) assuming the heap</div><div class="line">     * satisfies the invariant except possibly for the leaf-node indexed by k</div><div class="line">     * (which may have a nextExecutionTime less than its parent's).</div><div class="line">     *</div><div class="line">     * This method functions by "promoting" queue[k] up the hierarchy</div><div class="line">     * (by swapping it with its parent) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is greater than or equal to that of its parent.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> j = k &gt;&gt; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the subtree</div><div class="line">     * rooted at k, which is assumed to satisfy the heap invariant except</div><div class="line">     * possibly for node k itself (which may have a nextExecutionTime greater</div><div class="line">     * than its children's).</div><div class="line">     *</div><div class="line">     * This method functions by "demoting" queue[k] down the hierarchy</div><div class="line">     * (by swapping it with its smaller child) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is less than or equal to those of its children.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">while</span> ((j = k &lt;&lt; <span class="number">1</span>) &lt;= size &amp;&amp; j &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (j &lt; size &amp;&amp;</div><div class="line">                queue[j].nextExecutionTime &gt; queue[j+<span class="number">1</span>].nextExecutionTime)</div><div class="line">                j++; <span class="comment">// j indexes smallest kid</span></div><div class="line">            <span class="keyword">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the entire tree,</div><div class="line">     * assuming nothing about the order of the elements prior to the call.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</div><div class="line">            fixDown(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个队列是一个优先队列，以task的到期时间来排序，时间越小越靠前。这个队列是用堆结构实现的（废话，优先队列本身就是堆），实际上堆本质上就是完全二叉树。对于add remove操作的复杂度为log(n)。最核心的操作就是fixDown fixUp。堆也分为大根堆和小根堆，这是一个小根堆，最小的放到最上面，也就是下标为1的位置（只是Timer中的实现将下标为0的位置给弃用了）。每次添加元素都得调整堆结构，同理移除的时候也得这样做。</p>
<p>本文中的<a href="https://github.com/Mr-Vincent/simple-rpc/blob/a570c16128062b14ac0f0fa75e769d76060d3ad2/simple-example/src/main/java/top/weidong/example/netty/nettyinpractice/timer/JdkTimerDemo.java#L95-L94" target="_blank" rel="external">demo</a>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>源码读起来没那么难受，仔细推敲还是很有意思的。</li>
<li>相比老爷子Doug Lea的骚代码，这种中规中矩的写法看起来更让人容易理解。</li>
<li>建议使用ScheduledExecutorService，毕竟Timer的适用场景很局限。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在jdk中处理定时任务工具类中有2种：Timer和ScheduledExecutorService。前者是在java.util包中，从1.3版本开始，属于比较老的工具类了。而ScheduledExecutorService属于java.util.concurrent包，作者
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.wei-dong.top/categories/JDK-SOURCE/"/>
    
    
      <category term="JDK" scheme="http://www.wei-dong.top/tags/JDK/"/>
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>写给2017</title>
    <link href="http://www.wei-dong.top/2017/12/31/my%202017/"/>
    <id>http://www.wei-dong.top/2017/12/31/my 2017/</id>
    <published>2017-12-31T09:42:35.000Z</published>
    <updated>2018-01-01T10:44:55.854Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2018年一月一号，2018年的第一天。胡斐早上去HK买手机到现在还没回来，阿华刚刚出去约会去了。现在就剩下我一个人在家，坐在沙发上思量着这篇文章该怎么去写。傍晚了，余晖渐渐褪。和往常不同的是今天的天际线边没有往日那样红了。曾几何时，多少个黄昏十分，我就坐在沙发上，静静等着，等着太阳落山，等着晚霞映红天际线。每到那个点儿，总有飞机飞过，在晚霞的映衬下，缓缓地划过去，一架又一架。那是去年年底的时候。</p>
<p>12月份，被公司劝退。当时走的时候心里别提多高兴了，终于可以不用上班了，终于不用天天做一些无聊又没有意义的事情了。没有马上去找工作，而是什么都不干，玩他么2个星期再说。果真玩了一个星期，什么都没有去想，安安静静的看看书，看看电视剧，睡睡觉。那时候觉得不用工作真的是很幸福的一件事情。第二周把简历随便写了写，又随便投了投，没什么回应。也不在乎，反正也不想上班，继续玩呗。书也看的差不多了，得找些更加有意思的事情来做。在网易云课堂上报了一个素描班，开始学习画画。虽然现在都没怎么动笔去画了，但是我对素描的热情还是没有褪去。买了好几本书还没开始看，我知道总会看的，总会去坚持下去，总会实践出来。仔细回想过去，对于每天的枯燥无聊的coding和加班，是时候该问问自己到底想要什么，想达到一个什么样的层次。培养一种兴趣爱好对于我们这种生活单调无聊的人来说很重要。不光仅仅学素描，还时不时去谈谈吉他，虽然手上的茧都消地差不多了，但是热情还在。</p>
<p>没上班的日子我想过很多。目前这个职业我想我不会一直走下去，万一走不下去了我得给自己找条后路。但不论怎么说，目前还是得走下去，还是得不断去学习。</p>
<p>总觉得有很多时候，能一个人独处是一件多么愉快的事情。屋子里就我一个人，心没有那么浮躁。不会去看阿华打游戏，不会找胡斐扯淡。可以看书，可以写点东西…</p>
<p>总是将看书作为一件很重要的事情。离开校园，踏入社会参加工作，可能没有机会去碰书。因此读书就显得十分可贵。感触最明显的时候就是和别人交流的时候，有时候觉得对方说的自己都没办法接。去年我也读了部分书，仅仅只是读过，还没有什么深刻认识。印象中耗时最长的是《白鹿原》。以前上下班在地铁上就拿着手机看，每天都能看一点。现在没有那么多大把大把的时间了。零碎的时间也不知道该怎么利用。收获最大的一本书是《How Tomcat Works》。这本书本身就写得不错，浅显易懂。很久以来，我读书都没有记笔记的习惯。但是读这本书我用纸笔将其中有意思的内容记下来了。以前一直认为不会的或者忘记了的去百度谷歌就好了。现在则是觉得有必要就可以用笔记下来，画一下也行，这样容易帮助理解和记忆。虽然现在的各种软件APP都很多很方便，但是有时候就是记下来就很少去看了。走过一遭，总得留下点什么吧。</p>
<p>前些日子，把玩了差不多2年的游戏王者农药卸载了。以后不再这上面浪费时间了。然而可耻的是开始了吃鸡。我想我也不会沉迷于吃鸡太久，比较一个人玩也没多大意思。玩着玩着可能就无聊了。可能会将注意力转移到写作或者素描上来。去年屯的书也还一本没看完，总得给自己一点交代吧。</p>
<p>出来工作这么久了，难过的是一个新朋友都没有交到。很多老朋友却没什么联系了。有时候就觉得人情薄如纸。圈子不同了，可能认知也不太一样了。仅仅只是我还在原地踏步而已，却总暗示自己要向前走。即使如此那又怎样？我初心不改，我依旧是那个我。虽与孤独为伴，但是内心依旧丰富。从此再也不委屈自己，不再热脸贴冷屁股。我也有我自己的世界。</p>
<p>每当回首过去的时候，总是觉得许多日子都虚度了。有些事情，做好规划还是很有必要，前提是呀有足够的自律，否则其他都是瞎扯淡。</p>
<p>不论过去有怎样的懊悔和不满，路还长，总得往前走。只希望在下个路标回头的时候，我能依然记得此时的我对自己的期许。</p>
<p>2018，我已准备好！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2018年一月一号，2018年的第一天。胡斐早上去HK买手机到现在还没回来，阿华刚刚出去约会去了。现在就剩下我一个人在家，坐在沙发上思量着这篇文章该怎么去写。傍晚了，余晖渐渐褪。和往常不同的是今天的天际线边没有往日那样红了。曾几何时，多少个黄昏十分，我就坐在沙发上，静
    
    </summary>
    
      <category term="beyound coding" scheme="http://www.wei-dong.top/categories/beyound-coding/"/>
    
    
      <category term="所想" scheme="http://www.wei-dong.top/tags/%E6%89%80%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《How Tomcat Works》读书笔记</title>
    <link href="http://www.wei-dong.top/2017/12/06/%E3%80%8AHow%20Tomcat%20Works%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.wei-dong.top/2017/12/06/《How Tomcat Works》读书笔记/</id>
    <published>2017-12-06T04:37:23.000Z</published>
    <updated>2017-12-06T04:39:19.177Z</updated>
    
    <content type="html"><![CDATA[<p>这本书看了这么久，差不多可以算是看完了。准确来讲是还剩两个章节没有读完。最后那两个章节的的确确是很不得劲，也有可能是自己开始浮躁起来了。我看的是中文翻译的，可气的是中文翻译很多错别字不说，居然有些地方根本就没有翻译到，“缺斤少两”很可气。然后又找原版对照着看，避免被“误入歧途”。<br><a id="more"></a><br>差不多“读完”后，有那么一点小收获：</p>
<ul>
<li>观察者模式</li>
<li>责任链模式</li>
<li>门面模式</li>
<li>想到了再写</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>这个模式是我印象最深刻的，也是我最想学习的。尤其是看到了Tomcat源码中的那些骚操作。当然不仅仅是在Tomcat中有这种设计，<br>我在看Spring源码的时候也留意到了也有这种设计思想，内心不禁发出一个信号：教练我也想学。</p>
<p>接下来就针对Tomcat中的源码来对观察者模式进行简单的整理。Tomcat中许多组件都有生命周期，其实不止Tomcat，很多其他地方也有生命周期的概念：Spring生命周期，Servlet生命周期等等。生命周期就是观察者模式最好的体现。举个栗子，Service组件：<code>StandardService</code>就有生命周期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Lifecycle</span>, <span class="title">Service</span> &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The set of Connectors associated with this Service.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Connector connectors[] = <span class="keyword">new</span> Connector[<span class="number">0</span>];</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The Container associated with this Service.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Container container = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The debugging detail level for this component.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> debug = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Descriptive information about this component implementation.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String info =</div><div class="line">        <span class="string">"org.apache.catalina.core.StandardService/1.0"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Has this component been initialized?</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The name of this service.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String name = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The lifecycle event support for this component.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LifecycleSupport lifecycle = <span class="keyword">new</span> LifecycleSupport(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The string manager for this package.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm =</div><div class="line">        StringManager.getManager(Constants.Package);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The &lt;code&gt;Server&lt;/code&gt; that owns this Service, if any.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Server server = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Has this component been started?</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The property change support for this component.</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> PropertyChangeSupport support = <span class="keyword">new</span> PropertyChangeSupport(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// ------------------------------------------------------ Lifecycle Methods</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a LifecycleEvent listener to this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to add</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">        lifecycle.addLifecycleListener(listener);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the lifecycle listeners associated with this lifecycle. If this </div><div class="line">     * Lifecycle has no listeners registered, a zero-length array is returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> lifecycle.findLifecycleListeners();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove a LifecycleEvent listener from this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to remove</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">        lifecycle.removeLifecycleListener(listener);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Prepare for the beginning of active use of the public methods of this</div><div class="line">     * component.  This method should be called before any of the public</div><div class="line">     * methods of this component are utilized.  It should also send a</div><div class="line">     * LifecycleEvent of type START_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that prevents this component from being used</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Validate and update our current component state</span></div><div class="line">        <span class="keyword">if</span> (started) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException</div><div class="line">                (sm.getString(<span class="string">"standardService.start.started"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        System.out.println</div><div class="line">            (sm.getString(<span class="string">"standardService.start.name"</span>, <span class="keyword">this</span>.name));</div><div class="line">        lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Container first</span></div><div class="line">        <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (container) &#123;</div><div class="line">                <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Lifecycle) &#123;</div><div class="line">                    ((Lifecycle) container).start();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Connectors second</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (connectors[i] <span class="keyword">instanceof</span> Lifecycle)</div><div class="line">                    ((Lifecycle) connectors[i]).start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Gracefully terminate the active use of the public methods of this</div><div class="line">     * component.  This method should be the last one called on a given</div><div class="line">     * instance of this component.  It should also send a LifecycleEvent</div><div class="line">     * of type STOP_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that needs to be reported</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Validate and update our current component state</span></div><div class="line">        <span class="keyword">if</span> (!started) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException</div><div class="line">                (sm.getString(<span class="string">"standardService.stop.notStarted"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        lifecycle.fireLifecycleEvent(STOP_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        System.out.println</div><div class="line">            (sm.getString(<span class="string">"standardService.stop.name"</span>, <span class="keyword">this</span>.name));</div><div class="line">        started = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Stop our defined Connectors first</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (connectors[i] <span class="keyword">instanceof</span> Lifecycle)</div><div class="line">                    ((Lifecycle) connectors[i]).stop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Stop our defined Container second</span></div><div class="line">        <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (container) &#123;</div><div class="line">                <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Lifecycle) &#123;</div><div class="line">                    ((Lifecycle) container).stop();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Invoke a pre-startup initialization. This is used to allow connectors</div><div class="line">     * to bind to restricted ports under Unix operating environments.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">throws</span> LifecycleException &#123;</div><div class="line">        <span class="keyword">if</span> (initialized)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException (</div><div class="line">                sm.getString(<span class="string">"standardService.initialize.initialized"</span>));</div><div class="line">        initialized = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Initialize our defined Connectors</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                    connectors[i].initialize();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中只保留了有关<code>Lifecycle</code>接口的方法实现。看看<code>Lifecycle</code>接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line">    <span class="comment">// ----------------------------------------------------- Manifest Constants</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component start" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String START_EVENT = <span class="string">"start"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component before start" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_START_EVENT = <span class="string">"before_start"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component after start" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_START_EVENT = <span class="string">"after_start"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component stop" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOP_EVENT = <span class="string">"stop"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component before stop" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_STOP_EVENT = <span class="string">"before_stop"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component after stop" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_STOP_EVENT = <span class="string">"after_stop"</span>;</div><div class="line">    <span class="comment">// --------------------------------------------------------- Public Methods</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a LifecycleEvent listener to this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to add</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the lifecycle listeners associated with this lifecycle. If this </div><div class="line">     * Lifecycle has no listeners registered, a zero-length array is returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove a LifecycleEvent listener from this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to remove</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Prepare for the beginning of active use of the public methods of this</div><div class="line">     * component.  This method should be called before any of the public</div><div class="line">     * methods of this component are utilized.  It should also send a</div><div class="line">     * LifecycleEvent of type START_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that prevents this component from being used</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Gracefully terminate the active use of the public methods of this</div><div class="line">     * component.  This method should be the last one called on a given</div><div class="line">     * instance of this component.  It should also send a LifecycleEvent</div><div class="line">     * of type STOP_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that needs to be reported</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了定义两个动作<code>start</code>和<code>stop</code>外，还定义了一系列常量。当然还有对监听器的操作：添加、查找和移除。监听器可以说是观察者模式中的订阅者，它向感兴趣的事件注册，等事件发生的时候它获得通知。这个模型在Tomcat中可以这样解释：某个监听器对<code>start</code>事件感兴趣，因此对某个生命周期组件注册了，当<code>start</code>事件发生了，这个监听器获得通知，响应的代码被执行。可能用语言不好解释清楚，看代码是最好理解的了。<br>单独去看看<code>StandardService</code>中的生命周期方法<code>start()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Prepare for the beginning of active use of the public methods of this</div><div class="line">     * component.  This method should be called before any of the public</div><div class="line">     * methods of this component are utilized.  It should also send a</div><div class="line">     * LifecycleEvent of type START_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that prevents this component from being used</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Validate and update our current component state</span></div><div class="line">        <span class="keyword">if</span> (started) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException</div><div class="line">                (sm.getString(<span class="string">"standardService.start.started"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        System.out.println</div><div class="line">            (sm.getString(<span class="string">"standardService.start.name"</span>, <span class="keyword">this</span>.name));</div><div class="line">        lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Container first</span></div><div class="line">        <span class="comment">// 调用子组件的生命周期方法</span></div><div class="line">        <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (container) &#123;</div><div class="line">                <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Lifecycle) &#123;</div><div class="line">                    ((Lifecycle) container).start();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Connectors second</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (connectors[i] <span class="keyword">instanceof</span> Lifecycle)</div><div class="line">                    ((Lifecycle) connectors[i]).start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我想这段代码中最惹人注意的地方肯定是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</div><div class="line">lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</div><div class="line">lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</div></pre></td></tr></table></figure></p>
<p>我觉得其他的都可以忽略，仅仅关心这三行就够了。正如<code>Lifecycle</code>接口中常量描述的一样，<code>start</code>对应开始前，开始和开始后三个状态。因此在调用<code>start</code>的时候将这个三个事件顺序触发，那么谁去接收这几个事件呢？这就得问问我们之前说的监听器了。这里还有一个细节值得注意：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> LifecycleSupport lifecycle = <span class="keyword">new</span> LifecycleSupport(<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>这也是生命周期方法的直接调用者。由此引出一个问题：我直接实现了<code>Lifecycle</code>接口不就完了，里面的方法自己实现就行了，干嘛还得引入这个东西再去调用一次？这个就体现一种设计思想：设想一下，加入每个组件都自己去实现一次，但是很多代码都是类似的，这样就造成了很多冗余代码，维护起来很要命。不信可以看看这个<code>LifecycleSupport</code>具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleSupport</span> </span>&#123;</div><div class="line">    <span class="comment">// ----------------------------------------------------------- Constructors</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Construct a new LifecycleSupport object associated with the specified</div><div class="line">     * Lifecycle component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lifecycle The Lifecycle component that will be the source</div><div class="line">     *  of events that we fire</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleSupport</span><span class="params">(Lifecycle lifecycle)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ----------------------------------------------------- Instance Variables</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The source component for lifecycle events that we will fire.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Lifecycle lifecycle = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The set of registered LifecycleListeners for event notifications.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LifecycleListener listeners[] = <span class="keyword">new</span> LifecycleListener[<span class="number">0</span>];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// --------------------------------------------------------- Public Methods</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a lifecycle event listener to this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to add</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">          LifecycleListener results[] =</div><div class="line">            <span class="keyword">new</span> LifecycleListener[listeners.length + <span class="number">1</span>];</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++)</div><div class="line">              results[i] = listeners[i];</div><div class="line">          results[listeners.length] = listener;</div><div class="line">          listeners = results;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the lifecycle listeners associated with this lifecycle. If this </div><div class="line">     * Lifecycle has no listeners registered, a zero-length array is returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> listeners;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Notify all lifecycle event listeners that a particular event has</div><div class="line">     * occurred for this Container.  The default implementation performs</div><div class="line">     * this notification synchronously using the calling thread.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> type Event type</div><div class="line">     * <span class="doctag">@param</span> data Event data</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(lifecycle, type, data);</div><div class="line">        LifecycleListener interested[] = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">            interested = (LifecycleListener[]) listeners.clone();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interested.length; i++)</div><div class="line">            interested[i].lifecycleEvent(event);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove a lifecycle event listener from this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to remove</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">            <span class="keyword">int</span> n = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (listeners[i] == listener) &#123;</div><div class="line">                    n = i;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            LifecycleListener results[] =</div><div class="line">              <span class="keyword">new</span> LifecycleListener[listeners.length - <span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (i != n)</div><div class="line">                    results[j++] = listeners[i];</div><div class="line">            &#125;</div><div class="line">            listeners = results;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是对<code>Lifecycle</code>的部分方法的实现，这些方法一般是不会变化的，因此单独抽离出来，假如以后想改动也仅仅对这个类去改，而不是针对每个生命周期组件去改。</p>
<p>我觉得有个地方很值得借鉴：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line">      <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">          LifecycleListener results[] =</div><div class="line">            <span class="keyword">new</span> LifecycleListener[listeners.length + <span class="number">1</span>];</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++)</div><div class="line">              results[i] = listeners[i];</div><div class="line">          results[listeners.length] = listener;</div><div class="line">          listeners = results;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>假如是我去写这个接口我首先不会想到用数组去装<code>listeners</code>，我可能会使用一个<code>list</code>去存，这样进行添加的时候不会有这么复杂的操作。但是这里使用的是数组来处理，却达到了同样的效果。不得不佩服底层代码对这些细节的考虑。</p>
<p>继续接着那三行代码，看看具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(lifecycle, type, data);</div><div class="line">        LifecycleListener interested[] = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">            interested = (LifecycleListener[]) listeners.clone();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interested.length; i++)</div><div class="line">            interested[i].lifecycleEvent(event);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>一眼往去，无非就是触发监听器感兴趣的事件，而且是挨个来。这里有一个<code>LifecycleEvent</code>类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleEvent</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">EventObject</span> &#123;</div><div class="line">    <span class="comment">// ----------------------------------------------------------- Constructors</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Construct a new LifecycleEvent with the specified parameters.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lifecycle Component on which this event occurred</div><div class="line">     * <span class="doctag">@param</span> type Event type (required)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleEvent</span><span class="params">(Lifecycle lifecycle, String type)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>(lifecycle, type, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Construct a new LifecycleEvent with the specified parameters.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lifecycle Component on which this event occurred</div><div class="line">     * <span class="doctag">@param</span> type Event type (required)</div><div class="line">     * <span class="doctag">@param</span> data Event data (if any)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleEvent</span><span class="params">(Lifecycle lifecycle, String type, Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(lifecycle);</div><div class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ----------------------------------------------------- Instance Variables</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The event data associated with this event.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Object data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The Lifecycle on which this event occurred.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Lifecycle lifecycle = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The event type this instance represents.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String type = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ------------------------------------------------------------- Properties</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the event data of this event.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.data);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the Lifecycle on which this event occurred.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.lifecycle);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the event type of this event.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.type);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类继承了JDK中的<code>EventObject</code>，不用去管它。从构造器中可以看到有三个参数：生命周期对象，类型以及数据。有了这几个属性，这个生命周期事件对象可以放心去玩了。具体怎么去玩呢，和谁一起玩呢？这个得问问监听器了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleListener</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Acknowledge the occurrence of the specified event.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> event LifecycleEvent that has occurred</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>fireLifecycleEvent(String type, Object data)</code>方法中有这么个调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LifecycleListener interested[] = <span class="keyword">null</span>;</div><div class="line">...</div><div class="line">interested[i].lifecycleEvent(event);</div></pre></td></tr></table></figure></p>
<p>事件传给监听器了！<br>监听器拿到生命周期事件，由于事件中的数据全都有：当前生命周期对象、生命周期类型及携带的数据，因此监听器可以想怎么玩就怎么玩。演示一下怎么玩：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Lifecycle.START_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============START_EVENT================="</span>);</div><div class="line">      Context context = (Context) event.getLifecycle();</div><div class="line">      context.setConfigured(<span class="keyword">true</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Lifecycle.BEFORE_START_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============BEFORE_START_EVENT================="</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Lifecycle.BEFORE_STOP_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============BEFORE_STOP_EVENT=================="</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Lifecycle.STOP_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============STOP_EVENT=================="</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以说是简单到无聊。<br>忘了一点，事件监听得注册上去，不然事件发生了没法响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LifecycleListener listener = <span class="keyword">new</span> ContextConfig();</div><div class="line">((Lifecycle) context).addLifecycleListener(listener);</div></pre></td></tr></table></figure></p>
<p>多添加几个也无妨，只要你想。<br>Tomcat中给我印象最深刻的也就是Lifecycle观察者模式。相比去找一些设计模式的栗子去学习，我觉得阅读优秀的源码要理解地更透彻一些。除了观察者模式还有其他的设计思想也值得学习，慢慢总结，不断更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书看了这么久，差不多可以算是看完了。准确来讲是还剩两个章节没有读完。最后那两个章节的的确确是很不得劲，也有可能是自己开始浮躁起来了。我看的是中文翻译的，可气的是中文翻译很多错别字不说，居然有些地方根本就没有翻译到，“缺斤少两”很可气。然后又找原版对照着看，避免被“误入歧途”。&lt;br&gt;
    
    </summary>
    
      <category term="Tomcat 笔记" scheme="http://www.wei-dong.top/categories/Tomcat-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Tomcat" scheme="http://www.wei-dong.top/tags/Tomcat/"/>
    
      <category term="读书笔记" scheme="http://www.wei-dong.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Securing Web Applications with Apache Shiro[译]</title>
    <link href="http://www.wei-dong.top/2017/10/26/Securing%20Web%20Applications%20with%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.wei-dong.top/2017/10/26/Securing Web Applications with Apache Shiro[译]/</id>
    <published>2017-10-26T12:41:23.000Z</published>
    <updated>2017-10-26T12:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是介绍使用Shiro一步一步保护你的web应用的教程。它包含了Shiro的知识，以及和最近两篇文章很相似：</p>
<ul>
<li><a href="https://www.infoq.com/articles/apache-shiro" target="_blank" rel="external">Application Security with Apache Shiro</a></li>
<li><a href="http://shiro.apache.org/10-minute-tutorial.html" target="_blank" rel="external">Apache Shiro 10 Minute Tutorial</a><br>这个入门教程会花费大约45分钟到一个小时。当你读完后，你就会知道Shiro在web应用中怎么工作了的。<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3></li>
<li>概括</li>
<li>设置</li>
<li>第一步：开启Shiro</li>
<li>第二步：连接到用户存储</li>
<li>第三步：开启登录和登出</li>
<li>第四步：改变用户指定UI</li>
<li>第五步：仅仅允许认证用户访问</li>
<li>第六步：基于角色访问控制</li>
<li>第七步：基于权限访问控制</li>
</ul>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>虽然Shiro设计的核心目标可以用于保护任何基于JVM的应用，例如命令行应用，后台服务，网页应用等。这篇文章专注最常见的应用：保护跑在Servlet容器上的web应用，例如Tomca或者Jetty。</p>
<h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>下面的工具是要安装到你本地开发机器上的，以便遵循本教程。</p>
<ul>
<li>Git (tested w/ 1.7)</li>
<li>Java SDK 7</li>
<li>Maven 3</li>
<li>你自己喜欢的编辑器，IDEA或者Eclipse都行，甚至文本编辑器也行。</li>
</ul>
<h4 id="教程格式"><a href="#教程格式" class="headerlink" title="教程格式"></a>教程格式</h4><p>这是一步接着一步的教程。该教程和所有步骤都在GIT仓库中存着。当你clone git仓库，master分支就是你的起点。在这个教程中的每个步骤都是单独的分支。你可以通过检出你正在看的教程步骤的git分支来读这个教程（就是边看代码边读这个教程的意思）。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>我们将构建的Web应用程序是一个超级webapp，可以作为你自己的应用程序的起点。它将演示用户登录，注销，用户特定的欢迎消息，对Web应用程序的某些部分的访问控制以及与可插拔安全数据存储的集成。</p>
<p>我们将首先设置项目，包括构建工具和声明依赖关系，以及配置servlet web.xml文件以启动Web应用程序和Shiro环境。</p>
<p>完成设置后，我们将分层单独的功能，包括与安全数据存储集成，然后启用用户登录，注销和访问控制。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>我们已经在git仓库中设置完成了，因此你不必手动去设置目录结构初始化文件等。</p>
<h4 id="1-Fork-the-tutorial-project"><a href="#1-Fork-the-tutorial-project" class="headerlink" title="1. Fork the tutorial project"></a>1. Fork the tutorial project</h4><p>在github中访问<a href="https://github.com/lhazlewood/apache-shiro-tutorial-webapp" target="_blank" rel="external">这个</a>，点击<code>fork</code>按钮。</p>
<h4 id="2-Clone-your-tutorial-repository"><a href="#2-Clone-your-tutorial-repository" class="headerlink" title="2. Clone your tutorial repository"></a>2. Clone your tutorial repository</h4><p>现在你把那个仓库fork到你自己的账号中去了，clone到你自己的机器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git@github.com:<span class="variable">$YOUR_GITHUB_USERNAME</span>/apache-shiro-tutorial-webapp.git</div></pre></td></tr></table></figure></p>
<h4 id="3-Review-project-structure"><a href="#3-Review-project-structure" class="headerlink" title="3. Review project structure"></a>3. Review project structure</h4><p>完成clone后，你当前的<code>master</code>分支将有下面的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">apache-shiro-tutorial-webapp/</div><div class="line">     |-- src/</div><div class="line">     |  |-- main/</div><div class="line">     |    |-- resources/</div><div class="line">     |      |-- logback.xml</div><div class="line">     |    |-- webapp/</div><div class="line">     |      |-- WEB-INF/</div><div class="line">     |        |-- web.xml</div><div class="line">     |      |-- home.jsp</div><div class="line">     |      |-- include.jsp</div><div class="line">     |      |-- index.jsp</div><div class="line">     |-- .gitignore</div><div class="line">     |-- .travis.yml</div><div class="line">     |-- LICENSE</div><div class="line">     |-- README.md</div><div class="line">     |-- pom.xml</div></pre></td></tr></table></figure></p>
<p>这些是每个文件表示的含义：</p>
<ul>
<li>pom.xml 不解释</li>
<li>README.md 描述文件</li>
<li>LICENSE 证书</li>
<li>.travis.yml CI的配置文件，假如你想持续集成</li>
<li>.gitignore 忽略文件，包含后缀。你不想加入版本控制的都能写这里</li>
<li>src/main/resources/logback.xml 简单的Logback配置文件，在这个教程中，我们选择SELF4J作为日志API，Logback作为实现。这个比Log4J和JUL简单。</li>
<li>src/main/webapp/WEB-INF/web.xml web配置文件</li>
<li>src/main/webapp/include.jsp  公用的JSP文件，用于导入和声明。方便在一个地方管理。</li>
<li>src/main/webapp/home.jsp 默认的homepage</li>
<li>src/main/webapp/index.jsp 默认主页，仅仅是将请求指向home.jsp</li>
</ul>
<h4 id="4-Run-the-webapp"><a href="#4-Run-the-webapp" class="headerlink" title="4. Run the webapp"></a>4. Run the webapp</h4><p>现在你将工程克隆到本地了，你可以通过使用一下命令来跑这个web应用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>然后打开你的浏览器，输入 localhost:8080 你可以看到主页显示的Hello，World！按ctl-c停止web。</p>
<h3 id="Step-1-Enable-Shiro"><a href="#Step-1-Enable-Shiro" class="headerlink" title="Step 1: Enable Shiro"></a>Step 1: Enable Shiro</h3><p>我们初始化仓库master分支仅仅是一个简单通用的可用于任何应用的模板的web应用。Let’s add the bare minimum to enable Shiro in the web app next(这句话不知道怎么翻译)。</p>
<p>执行下面的git检出命令加载step1的分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step1</div></pre></td></tr></table></figure></p>
<p>检出后你会发现两个变化：</p>
<ol>
<li>多了<code>src/main/webapp/WEB-INF/shiro.ini</code>这个文件</li>
<li><code>src/main/webapp/WEB-INF/web.xml</code>被改了</li>
</ol>
<h4 id="添加shiro-ini文件"><a href="#添加shiro-ini文件" class="headerlink" title="添加shiro.ini文件"></a>添加shiro.ini文件</h4><p>在web应用中油很多种方式配置Shiro，这取决于你使用的是什么web框架。例如，你可以通过Spring、Guice、Tapestry等配置Shiro。</p>
<p>现在为了方便，我们将使用Shiro默认的配置,<a href="http://shiro.apache.org/configuration.html" target="_blank" rel="external">基于ini的配置</a>。</p>
<p>如果你检出了step1的分支，你可以看到这个新的配置文件<code>src/main/webapp/WEB-INF/shiro.ini</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line"></div><div class="line"># Let&apos;s use some in-memory caching to reduce the number of runtime lookups against a remote user store.</div><div class="line"># A real application might want to use a more robust caching solution (e.g. ehcache or a</div><div class="line"># distributed cache).  When using such caches, be aware of your cache TTL settings: too high</div><div class="line"># a TTL and the cache won&apos;t reflect any potential changes in Stormpath fast enough.  Too low</div><div class="line"># and the cache could evict too often, reducing performance.</div><div class="line">cacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager</div><div class="line">securityManager.cacheManager = $cacheManager</div></pre></td></tr></table></figure></p>
<p>这个ini配置文件包含一个<code>[main]</code>的最小配置。</p>
<ul>
<li>定义了一个<code>cacheManager</code>实例。缓存在Shiro架构中是一个很重要的部分。它减少了重复的数据交互。这个例子使用<code>MemoryConstrainedCacheManager</code>，仅仅对单个JVM应用很棒。如果你的应用部署在多个主机，你最好使用集群的CacheManager 实现。</li>
<li>它在Shiro securityManager上配置新的cacheManager实例。Shiro SecurityManager实例始终存在，因此不需要明确定义。</li>
</ul>
<h4 id="在web-xml中开启Shiro"><a href="#在web-xml中开启Shiro" class="headerlink" title="在web.xml中开启Shiro"></a>在web.xml中开启Shiro</h4><p>虽然我们有shiro.ini配置文件，但是我们确实需要把它加载进去然后开启Shiro环境让web应用能够使用它。</p>
<p>我们在<code>src/main/webapp/WEB-INF/web.xml</code>配置文件中添加这些东西：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.apache.shiro.web.env.EnvironmentLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.shiro.web.servlet.ShiroFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>INCLUDE<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;listener&gt;</code>声明定义了一个<code>ServletContextListener</code>用于在web用于启动的时候创建一个Shiro环境。默认这个listener会去自动找<code>WEB-INF/shiro.ini</code>配置文件。</li>
<li><code>&lt;filter&gt;</code>定义了一个主要的<code>ShiroFilter</code>。这个过滤器会去过滤所有的请求，这样Shiro能够在允许请求到达应用程序之前执行必要的身份和访问控制操作。</li>
</ul>
<h4 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h4><p>拉去了分支后，继续跑起来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>这个时候，你会看到下面熟悉的输出，这表示Shiro确实在你的web应用中跑起来了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">16:04:19.807 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Starting Shiro environment initialization.</div><div class="line">16:04:19.904 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Shiro environment initialized in 95 ms.</div></pre></td></tr></table></figure></p>
<h3 id="Step-2-Connect-to-a-User-Store"><a href="#Step-2-Connect-to-a-User-Store" class="headerlink" title="Step 2: Connect to a User Store"></a>Step 2: Connect to a User Store</h3><p>执行下面的命令检出step2的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step2</div></pre></td></tr></table></figure></p>
<p>现在我们将Shiro集成并运行在webapp中.但是我们还没有告诉Shiro要做什么事情。</p>
<p>在我们登录，退出或执行基于角色或权限的访问控制或任何其他安全相关之前，我们需要用户！</p>
<p>我们需要配置Shiro来访问某种类型的用户存储，这样它可以查找用户做登录操作或者检查角色等等。有许多类型的用户存储，任何应用程序可能需要访问：也许你将用户存在MySql数据库中，或者MongoDB，或者LDAP，或者Active Directory，或者简单的文件中。</p>
<p>Shiro将这叫做<code>Realm</code>.来自Shiro的文档：</p>
<blockquote>
<p>Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application.<br>In this sense a Realm is essentially a security-specific DAO: it encapsulates connection details for data sources and makes the associated data available to Shiro as needed. When configuring Shiro, you must specify at least one Realm to use for authentication and/or authorization. The SecurityManager may be configured with multiple Realms, but at least one is required.<br>Shiro provides out-of-the-box Realms to connect to a number of security data sources (aka directories) such as LDAP, relational databases (JDBC), text configuration sources like INI and properties files, and more. You can plug-in your own Realm implementations to represent custom data sources if the default Realms do not meet your needs.</p>
</blockquote>
<p>因此我们需要配置一个<code>realm</code>这样我们就能够得到用户了。</p>
<h4 id="Set-up-Stormpath"><a href="#Set-up-Stormpath" class="headerlink" title="Set up Stormpath"></a>Set up Stormpath</h4><p>本着越简单越好的原则，没有介绍Shiro的复杂性，我们使用一个最简单的realm的实现：Stormpath realm。</p>
<p>Stormpath 是一个云平台上的用户管理服务。对开发者免费。这意味着使用了Stormpath以后，帮你做了做以下的事情：</p>
<ul>
<li>一个用于管理应用，目录、账户、和组的接口。Shiro根本不提供这些东西，因此当你浏览这篇教程的时候能够节约时间，这是很方便的。</li>
<li>一个为用户存储密码的安全机制。你的应用不必担心密码安全，密码比较或存储密码。虽然Shiro能做这些事情，但是你有必要去配置一下，然后注意一下加密的概念。 Stormpath自动的对密码进行保护，因此你不必担心这些东西。</li>
<li>安全的工作流，类似于邮箱验证密码重置。Shiro对此没有任何支持，因为这是应用程序来把控的。</li>
<li>主机托管总是在基础设施上的（云平台），你没有必要来维护这些东西。</li>
</ul>
<p>为了本教程的目的，Stormpath比设置单独的RDBMS服务器要简单得多，并且担心SQL或密码加密问题。</p>
<p>当然，Stormpath只是Shiro可以进行沟通的许多后端数据存储之一。 稍后将介绍更复杂的数据存储和应用程序特定的配置。</p>
<h5 id="Sign-up-for-Stormpath"><a href="#Sign-up-for-Stormpath" class="headerlink" title="Sign up for Stormpath"></a>Sign up for Stormpath</h5><p>blabla…..</p>
<h5 id="Get-a-Stormpath-API-Key"><a href="#Get-a-Stormpath-API-Key" class="headerlink" title="Get a Stormpath API Key"></a>Get a Stormpath API Key</h5><p>Stormpath API Key对于Stormpath来说是必须的。可以这样获取：</p>
<ol>
<li>登录到Stormpath中（这个网站关了，合并到okta）。</li>
<li>页面的右边，访问API KEY：Manage API KEY</li>
<li><p>在账号详情页面，点击Create API Key。此时会生成你的API key，然后下载到你的电脑。如果你打开看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apiKey.id = 144JVZINOF5EBNCMG9EXAMPLE</div><div class="line">apiKey.secret = lWxOiKqKPNwJmSldbiSkEbkNjgh2uRSNAb+AEXAMPLE</div></pre></td></tr></table></figure>
</li>
<li><p>保存到一个安全的地方，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$HOME/.stormpath/apiKey.properties</div></pre></td></tr></table></figure>
</li>
<li><p>当然也可以改一下这个文件的权限。例如在*nix下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chmod go-rwx <span class="variable">$HOME</span>/.stormpath/apiKey.properties</div><div class="line">$ chmod u-w <span class="variable">$HOME</span>/.stormpath/apiKey.properties</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="Retrieve-the-default-Stormpath-Application"><a href="#Retrieve-the-default-Stormpath-Application" class="headerlink" title="Retrieve the default Stormpath Application"></a>Retrieve the default Stormpath Application</h5><p>当你登录到Stormpath，自动的创建了一个空的应用，名字叫做：<code>My Application</code></p>
<p>我们必须使用Strompath注册我们的web应用，这样就能使用Strompath来管理我们的用户和对用户授权。为了使用我的应用程序Stormpath应用程序注册我们的Web应用程序，我们需要了解一些信息。幸运的是，我们可以使用Stormpath API来检索这些信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -i --user <span class="variable">$YOUR_API_KEY_ID</span>:<span class="variable">$YOUR_API_KEY_SECRET</span> \</div><div class="line"><span class="string">'https://api.stormpath.com/v1/tenants/current'</span></div></pre></td></tr></table></figure></p>
<p>你能得到这些返回信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 302 Found</div><div class="line">Date: Fri, 28 Aug 2015 18:34:51 GMT</div><div class="line">Location: https://api.stormpath.com/v1/tenants/sOmELoNgRaNDoMIdHeRe</div><div class="line">Server: Apache</div><div class="line">Set-Cookie: rememberMe=deleteMe; Path=/; Max-Age=0; Expires=Thu, 27-Aug-2015 18:34:52 GMT</div><div class="line">Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</div><div class="line">Content-Length: 0</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure></p>
<p>注意到<code>Location</code>，这个就是你的Stormpath tenant.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -u <span class="variable">$API_KEY_ID</span>:<span class="variable">$API_KEY_SECRET</span> \</div><div class="line">     -H <span class="string">"Accept: application/json"</span> \</div><div class="line">     <span class="string">'$TENANT_HREF/applications?name=My%20Application'</span></div></pre></td></tr></table></figure></p>
<p>这个回应有很多的信息。 这是一个从响应中摘录的例子.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    "href": "https://api.stormpath.com/v1/applications/aLoNGrAnDoMAppIdHeRe",</div><div class="line">    "name": "My Application",</div><div class="line">    "description": "This application was automatically created for you in Stormpath for use with our Quickstart guides(https://docs.stormpath.com). It does apply to your subscription's number of reserved applications and can be renamed or reused for your own purposes.",</div><div class="line">    "status": "ENABLED",</div><div class="line">    "tenant": &#123;</div><div class="line">        "href": "https://api.stormpath.com/v1/tenants/sOmELoNgRaNDoMIdHeRe"</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面注意你的最上面的<code>href</code>，接下来我们将在shiro.ini配置中使用这个<code>href</code>。</p>
<h5 id="Create-an-application-test-user-account"><a href="#Create-an-application-test-user-account" class="headerlink" title="Create an application test user account"></a>Create an application test user account</h5><p>现在我们有一个应用程序，我们将要为该应用程序创建一个示例/测试用户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl --request POST --user <span class="variable">$YOUR_API_KEY_ID</span>:<span class="variable">$YOUR_API_KEY_SECRET</span> \</div><div class="line">    -H <span class="string">"Accept: application/json"</span> \</div><div class="line">    -H <span class="string">"Content-Type: application/json"</span> \</div><div class="line">    <span class="_">-d</span> <span class="string">'&#123;</span></div><div class="line">           "givenName": "Jean-Luc",</div><div class="line">           "surname": "Picard",</div><div class="line">           "username": "jlpicard",</div><div class="line">           "email": "capt@enterprise.com",</div><div class="line">           "password":"Changeme1"</div><div class="line">        &#125;' \</div><div class="line"> <span class="string">"<span class="variable">$YOUR_APPLICATION_HREF</span>/accounts"</span></div></pre></td></tr></table></figure></p>
<h4 id="Configure-the-Realm-in-shiro-ini"><a href="#Configure-the-Realm-in-shiro-ini" class="headerlink" title="Configure the Realm in shiro.ini"></a>Configure the Realm in shiro.ini</h4><p>按照Shiro的要求，你选择至少一个用户存储的连接，我们将需要配置一个表示该数据存储的域，然后告诉Shiro SecurityManager。</p>
<p>如果你检出step2的分支，你会看到<code>src/main/webapp/WEB-INF/shiro.ini</code>中的[main]部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># Configure a Realm to connect to a user datastore.  In this simple tutorial, we&apos;ll just point to Stormpath since it</div><div class="line"># takes 5 minutes to set up:</div><div class="line">stormpathClient = com.stormpath.shiro.client.ClientFactory</div><div class="line">stormpathClient.cacheManager = $cacheManager</div><div class="line"></div><div class="line"># (Optional) If you put your apiKey.properties in the non-default location, you set the location here</div><div class="line">#stormpathClient.apiKeyFileLocation = $HOME/.stormpath/apiKey.properties</div><div class="line"></div><div class="line">stormpathRealm = com.stormpath.shiro.realm.ApplicationRealm</div><div class="line">stormpathRealm.client = $stormpathClient</div><div class="line"></div><div class="line"># Find this URL in your Stormpath console for an application you create:</div><div class="line"># Applications -&gt; (choose application name) --&gt; Details --&gt; REST URL</div><div class="line"># (Optional) If you only have one Application</div><div class="line">#stormpathRealm.applicationRestUrl = https://api.stormpath.com/v1/applications/$STORMPATH_APPLICATION_ID</div><div class="line"></div><div class="line">stormpathRealm.groupRoleResolver.modeNames = name</div><div class="line">securityManager.realm = $stormpathRealm</div></pre></td></tr></table></figure></p>
<p>注意看可选的那行：</p>
<ul>
<li>如果你已经使用Stormpath一段时间，并且你有更多的Stormpath应用程序，<code>stormpathRealm.applicationRestUrl</code>这个属性必须被设置。</li>
</ul>
<h4 id="Run-the-webapp"><a href="#Run-the-webapp" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>在完成上面的改动后，使用下面的命令来跑一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>这时候就会看到熟悉的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">16:08:25.466 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Starting Shiro environment initialization.</div><div class="line">16:08:26.201 [main] INFO  o.a.s.c.IniSecurityManagerFactory - Realms have been explicitly set on the SecurityManager instance - auto-setting of realms will not occur.</div><div class="line">16:08:26.201 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Shiro environment initialized in 731 ms.</div></pre></td></tr></table></figure></p>
<h3 id="Step-3-Enable-Login-and-Logout"><a href="#Step-3-Enable-Login-and-Logout" class="headerlink" title="Step 3: Enable Login and Logout"></a>Step 3: Enable Login and Logout</h3><p>现在我们有用户，而且我们能很容易的添加，移除和禁用他们。现在我们可以在我们的应用程序中开始启用登录/注销和访问控制等功能。</p>
<p>检出step3的分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step3</div></pre></td></tr></table></figure></p>
<p>添加了2个东西:</p>
<ul>
<li><code>src/main/webapp/login.jsp</code>中加了一个简单的登录表单，我们使用它登录。</li>
<li><code>shiro.ini</code>文件已更新，以支持Web（URL）特定功能。</li>
</ul>
<h4 id="Enable-Shiro-form-login-and-logout-support"><a href="#Enable-Shiro-form-login-and-logout-support" class="headerlink" title="Enable Shiro form login and logout support"></a>Enable Shiro form login and logout support</h4><p>step3中<code>src/main/webapp/WEB-INF/shiro.ini</code>添加了下面2个东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line"></div><div class="line">shiro.loginUrl = /login.jsp</div><div class="line"></div><div class="line"># Stuff we&apos;ve configured here previously is omitted for brevity</div><div class="line"></div><div class="line">[urls]</div><div class="line">/login.jsp = authc</div><div class="line">/logout = logout</div></pre></td></tr></table></figure></p>
<p>在[main]这个部分多了一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shiro.loginUrl = /login.jsp</div></pre></td></tr></table></figure></p>
<p>这是一个告诉Shiro的特殊配置指令:”对于任何具有loginUrl属性的Shiro的默认过滤器，我希望该属性值设置为/login.jsp。”</p>
<p>这个就是让Shiro的默认认证过滤器（默认的是FormAuthenticationFilter）知道登录页面是哪个。这个让FormAuthenticationFilter正确的工作是很有必要的。</p>
<p>[urls]部分允许你使用非常简洁的键值对语法来告诉Shiro怎么样去过滤给定的url请求。urls中的所有路径都是相对于Web应用程序的HttpServletRequest.getContextPath()的值.</p>
<p>这些键值对提供一个极其强大的方式来过滤请求，允许各种各样的安全规则。URL和过滤器链的更深入的覆盖范围超出了本文档的范围，但如果你有兴趣，请详细阅读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/login.jsp = authc</div><div class="line">/logout = logout</div></pre></td></tr></table></figure>
<ul>
<li>第一行指出不论Shiro什么时候遇到请求<code>/login.jsp</code>的url，在请求中开启authc过滤器。</li>
<li>第二行表示不论Shiro遇到<code>/login.jsp</code>的url，在请求中开启logout 过滤器。</li>
</ul>
<p>这两个过滤器都有一点特殊的地方，他们都不需要在背后进行额外的处理。它们实际上只是完全处理请求，而不是过滤。这意味着你对这些URL的请求没有任何要求，不需要写任何controller。Shiro将根据需要处理这些请求。</p>
<h4 id="Add-a-login-page"><a href="#Add-a-login-page" class="headerlink" title="Add a login page"></a>Add a login page</h4><p>在上个步骤中我们开启了对登录和登出的支持。现在我们需要保证有一个<code>/login.jsp</code>页面来显示登录表单。</p>
<p>step3的分支中包含<code>src/main/webapp/login.jsp</code>页面。这是一个简单的bootstrap主题的登录页面，但是依旧有四点需要注意：</p>
<ul>
<li>这个表单的<code>action</code>值是空的字符串。当表单中没有<code>action</code>值，浏览器将提交请求到同一个URL。这很好，因为我们会告诉Shiro那个URL很短，所以Shiro可以自动处理任何登录提交。<code>/login.jsp = authc</code>这行是告诉authc过滤器处理这个提交。</li>
<li>有一个<code>username</code>字段，Shiro authc过滤器将在登录提交期间自动查找用户名请求参数，并将其用作登录期间的值（许多域允许此为电子邮件或用户名）。</li>
<li>有一个<code>password</code>字段，Shiro authc过滤器将在登录提交期间自动查找密码请求参数。</li>
<li>有一个rememberMe复选框，其“checked”状态可以是“true”值（true，t，1，enabled，y，yes或on）。</li>
</ul>
<p>我们的login.jsp表单只使用默认的用户名，密码和rememberMe表单字段名称。 如果您想更改这些名称，这些名称是可配置的。参见<a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html" target="_blank" rel="external">FormAuthenticationFilter</a>.</p>
<h4 id="Run-the-webapp-1"><a href="#Run-the-webapp-1" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>再跑一次：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<h4 id="Try-to-Login"><a href="#Try-to-Login" class="headerlink" title="Try to Login"></a>Try to Login</h4><p>使用您的Web浏览器，导航到localhost：8080 / login.jsp，您将看到我们新的登录表单。</p>
<p>输入你在步骤2结束时创建的帐户的用户名和密码，然后点击“登录”。 如果登录成功，你将被引导到主页！ 如果登录失败，你将再次显示登录页面。</p>
<p>提示：如果你希望成功登录将用户重定向到主页（上下文路径/）以外的其他页面，则可以在INI的main部分中设置authc.successUrl = / any。</p>
<h3 id="Step-4-User-specific-UI-changes"><a href="#Step-4-User-specific-UI-changes" class="headerlink" title="Step 4: User-specific UI changes"></a>Step 4: User-specific UI changes</h3><p>通常需要根据用户是谁来更改web用户界面。我们可以很容易地做到这一点，因为Shiro支持JSP标签库根据当前登录的Subject（用户）进行操作。</p>
<p>检出step4的分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step4</div></pre></td></tr></table></figure></p>
<p>在<code>home.jsp</code>页面中新增了：</p>
<ul>
<li>当浏览该页面的当前用户未登录时，他们将看到一个“欢迎访客”消息，并查看登录页面的链接。</li>
<li>当浏览该页面的当前用户登录后，他们将看到自己的名字“欢迎xxx”和一个链接以注销。</li>
</ul>
<p>这种类型的UI定制对于导航栏是非常常见的，用户控件位于屏幕的右上方。</p>
<h4 id="Add-the-Shiro-Tag-Library-Declaration"><a href="#Add-the-Shiro-Tag-Library-Declaration" class="headerlink" title="Add the Shiro Tag Library Declaration"></a>Add the Shiro Tag Library Declaration</h4><p>在<code>home.jsp</code>顶部包含了这两行：<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">"http://shiro.apache.org/tags"</span> %&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"c"</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span></div></pre></td></tr></table></figure></p>
<p>这两个JSP页面指令允许页面中的Core（c )和Shiro（shiro )标签库。</p>
<h4 id="Add-Shiro-Guest-and-User-tags"><a href="#Add-Shiro-Guest-and-User-tags" class="headerlink" title="Add Shiro Guest and User tags"></a>Add Shiro Guest and User tags</h4><p><code>home.jsp</code>文件进一步修改了body里的内容，以包含<shiro：guest>和<shiro：user>标签。<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi <span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span>Guest<span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span><span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span></div><div class="line">    //<span class="attr">This</span> <span class="attr">should</span> <span class="attr">never</span> <span class="attr">be</span> <span class="attr">done</span> <span class="attr">in</span> <span class="attr">a</span> <span class="attr">normal</span> <span class="attr">page</span> <span class="attr">and</span> <span class="attr">should</span> <span class="attr">exist</span> <span class="attr">in</span> <span class="attr">a</span> <span class="attr">proper</span> <span class="attr">MVC</span> <span class="attr">controller</span> <span class="attr">of</span> <span class="attr">some</span> <span class="attr">sort</span>, <span class="attr">but</span> <span class="attr">for</span> <span class="attr">this</span></div><div class="line">    //<span class="attr">tutorial</span>, <span class="attr">we</span>'<span class="attr">ll</span> <span class="attr">just</span> <span class="attr">pull</span> <span class="attr">out</span> <span class="attr">Stormpath</span> <span class="attr">Account</span> <span class="attr">data</span> <span class="attr">from</span> <span class="attr">Shiro</span>'<span class="attr">s</span> <span class="attr">PrincipalCollection</span> <span class="attr">to</span> <span class="attr">reference</span> <span class="attr">in</span> <span class="attr">the</span></div><div class="line">    //&lt;<span class="attr">c:out</span>/&gt; tag next:</div><div class="line"></div><div class="line">    request.setAttribute("account", org.apache.shiro.SecurityUtils.getSubject().getPrincipals().oneByType(java.util.Map.class));</div><div class="line"></div><div class="line">%&gt;</div><div class="line"><span class="tag">&lt;<span class="name">c:out</span> <span class="attr">value</span>=<span class="string">"$&#123;account.givenName&#125;"</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span>!</div><div class="line">    ( <span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">logout</span>"/&gt;</span>"&gt;Log out<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">login.jsp</span>"/&gt;</span>"&gt;Log in<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span> )</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></shiro：user></shiro：guest></p>
<p>给定的格式有点难以阅读，但是在这里使用了两个标签：</p>
<ul>
<li><code>&lt;shiro:guest&gt;</code>这个标签仅仅显示它内部的内容，假如当前的subject是一个访客的话。Shiro将guest定义为未登录到应用程序的任何Subject，或者在之前登录没有被记住的用户。</li>
<li><code>&lt;shiro:user&gt;</code>Shiro将用户定义为当前登录到（认证）应用程序或从先前登录记录的主题的任何主题。</li>
</ul>
<p>如果subject是访客，上述代码段将呈现以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi Guest! (Log in)</div></pre></td></tr></table></figure></p>
<p>如果subject是“用户”，它将呈现以下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi jsmith! (Log out)</div></pre></td></tr></table></figure></p>
<p>你可以看到，您可以关闭整个页面部分，功能和UI组件。<br>除了这两个标签，Shiro还提供其他标签供你来定制你自己的UI。</p>
<h4 id="Run-the-webapp-2"><a href="#Run-the-webapp-2" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>跑吧！</p>
<h3 id="Step-5-Allow-Access-to-Only-Authenticated-Users"><a href="#Step-5-Allow-Access-to-Only-Authenticated-Users" class="headerlink" title="Step 5: Allow Access to Only Authenticated Users"></a>Step 5: Allow Access to Only Authenticated Users</h3><p>虽然你可以根据subject的状态来改变内容，但是通常情况下，你将要限制webapp的整个部分，这取决于有人在当前与Web应用程序的互动过程中是否已证明其身份（已验证）。</p>
<p>如果webapp的用户专区部分显示敏感信息（如帐单明细或控制其他用户的能力），这一点尤为重要。</p>
<p>检出step5：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step5</div></pre></td></tr></table></figure></p>
<p>Step 5有3个更新：</p>
<ul>
<li>添加了一个新的部分（url path），我们要限制只有经过身份验证的用户。</li>
<li>我们更改了shiro.ini，以告诉Shiro只允许经过身份验证的用户访问该Web应用程序的该部分。</li>
<li>我们修改了主页，根据当前的主题是否被认证来更改其输出。</li>
</ul>
<h4 id="Add-a-new-restricted-section"><a href="#Add-a-new-restricted-section" class="headerlink" title="Add a new restricted section"></a>Add a new restricted section</h4><p><code>src/main/webapp/account</code>目录被添加进来了。此目录（及其下方的所有路径）会模拟网站的“私有”或“仅验证”部分，你可能希望将其限制为只能登录用户。<code>src/main/webapp/account/index.jsp</code>文件只是模拟“主页”页面的占位符。</p>
<h4 id="Configure-shiro-ini"><a href="#Configure-shiro-ini" class="headerlink" title="Configure shiro.ini"></a>Configure shiro.ini</h4><p>在<code>shiro.ini</code>的<code>[urls]</code>这个章节的结尾，添加了下面的一行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/account/** = authc</div></pre></td></tr></table></figure></p>
<p>这个Shiro过滤器链定义意味着“对/ account（或其任何子路径）的任何请求必须被认证”。<br>但是，如果有人尝试访问该路径或其任何子路径，会发生什么？<br>你还记得在步骤3中,当我们将以下行添加到main部分吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shiro.loginUrl = /login.jsp</div></pre></td></tr></table></figure></p>
<p>这一行自动使用我们的webapp登录URL配置authc过滤器。<br>基于这一行配置，authc过滤器现在足够聪明，可以知道当访问/帐户当前主题未被验证时，它将自动将主题重定向到/login.jsp页面。成功登录后，它将自动将用户重定向到他们试图访问的页面（/帐户）。 很方便！</p>
<h4 id="Update-our-home-page"><a href="#Update-our-home-page" class="headerlink" title="Update our home page"></a>Update our home page</h4><p>步骤5的最终更改是更新/home.jsp页面，让用户知道他们可以访问网站的新部分。这些行被添加到欢迎消息下:<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">shiro:authenticated</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Visit your <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">account</span>"/&gt;</span>"&gt;account page<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:authenticated</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">shiro:notAuthenticated</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>If you want to access the authenticated-only <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">account</span>"/&gt;</span>"&gt;account page<span class="tag">&lt;/<span class="name">a</span>&gt;</span>, you will need to log-in first.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">shiro:notAuthenticated</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果当前的Subject在当前会话期间已经登录（认证），则<shiro：authenticated>标签内的内容被显示。这是Subject知道他们可以去访问网站的新部分。<br>如果当前Subject在当前会话期间尚未验证，则<shiro：notauthenticated>标签内的内容被显示。<br>但是你注意到了吗，未经身份验证的内容仍然具有/ account部分的URL？没关系 - 我们的authc过滤器将如上所述处理login-and-then-redirect流程。<br>用新的更改启动webapp并尝试一下！</shiro：notauthenticated></shiro：authenticated></p>
<h4 id="Run-the-webapp-3"><a href="#Run-the-webapp-3" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>跑一下吧。</p>
<h3 id="Step-6-Role-Based-Access-Control"><a href="#Step-6-Role-Based-Access-Control" class="headerlink" title="Step 6: Role-Based Access Control"></a>Step 6: Role-Based Access Control</h3><p>除了基于身份验证控制访问之外，还经常需要根据分配给当前主体的角色来限制对应用程序某些部分的访问。<br>检出代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step6</div></pre></td></tr></table></figure></p>
<h4 id="Add-Roles"><a href="#Add-Roles" class="headerlink" title="Add Roles"></a>Add Roles</h4><p>为了执行基于角色的访问控制，我们需要有角色。<br>在本教程中最快的方法是在Stormpath中添加一些组。要做到这一点，登录到UI并导航如下：<br><strong>Directories &gt; My Application Directory &gt; Groups</strong><br>添加下面三个组：</p>
<ul>
<li>Captains</li>
<li>Officers</li>
<li>Enlisted</li>
</ul>
<p>创建组后，将Jean-Luc Picard帐户添加到Captains和Officers组。您可能需要创建一些临时帐户，并将它们添加到您喜欢的任何组；确保某些帐户不重叠组，因此你可以基于分配给用户帐户的单独组查看变更。</p>
<h4 id="Role-Based-Access-Control-RBAC-Tags"><a href="#Role-Based-Access-Control-RBAC-Tags" class="headerlink" title="Role Based Access Control (RBAC) Tags"></a>Role Based Access Control (RBAC) Tags</h4><p>我们更新/home.jsp页面，让用户知道他们有什么角色，哪些角色没有。这些消息将添加到主页的新的<code>&lt;h2&gt;</code>角色<code>&lt;/ h2&gt;</code>部分:<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Roles<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Here are the roles you have and don't have. Log out and log back in under different user</div><div class="line">    accounts to see different roles.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Roles you have:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"Captains"</span>&gt;</span>Captains<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"Officers"</span>&gt;</span>Bad Guys<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"Enlisted"</span>&gt;</span>Enlisted<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Roles you DON'T have:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"Captains"</span>&gt;</span>Captains<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"Officers"</span>&gt;</span>Officers<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"Enlisted"</span>&gt;</span>Enlisted<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果当前主体被分配了指定的角色，<shiro：hasrole>标签将显示其中的内容。<shiro：lacksrole>标签只会在当前主体未分配指定角色时显示其中的内容。</shiro：lacksrole></shiro：hasrole></p>
<h4 id="RBAC-filter-chains"><a href="#RBAC-filter-chains" class="headerlink" title="RBAC filter chains"></a>RBAC filter chains</h4><p>向读者留下的一个练习（不是一个定义的步骤）是根据分配给当前用户的角色，创建网站的一个新的部分，并限制URL访问该网站的该部分。<br>提示：使用 <code>filter chain definition</code>为webapp的新部分创建过滤器链定义。</p>
<h4 id="Run-the-webapp-4"><a href="#Run-the-webapp-4" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>run一下咯</p>
<h3 id="Step-7-Permission-Based-Access-Control"><a href="#Step-7-Permission-Based-Access-Control" class="headerlink" title="Step 7: Permission-Based Access Control"></a>Step 7: Permission-Based Access Control</h3><p>基于角色的访问控制对于许多情况是行得通的，但是它存在一个主要问题：你不能在运行时添加或删除角色。角色检查使用角色名称进行硬编码，所以如果你改变了角色名称或角色配置，或添加或删除角色，你必须回去更改代码！<br>因此，Shiro具有强大的功能：内置的权限支持。<br>在Shiro，权限是一个原始的功能说明，例如“打开门”，创建博客条目“，”删除jsmith用户“等。权限反映了您的应用程序的原始功能，所以在更改应用程序的功能时，您只需要更改权限检查，而不是要更改角色或用户模型。<br>为了演示这一点，我们将创建一些权限并将其分配给用户，然后根据用户的授权（权限）自定义我们的Web UI。</p>
<h4 id="Add-Permissions"><a href="#Add-Permissions" class="headerlink" title="Add Permissions"></a>Add Permissions</h4><p>Shiro的Realm是只读组件:每个数据存储模型的角色，组，权限，帐户和他们的关系不同,所以Shiro没有一个’write’API来修改这些资源。要修改模型对象的底层，你只需通过任何您想要的API直接修改它们。你的Shiro的Realm然后知道如何阅读这些信息，并以Shiro理解的格式表示它。<br>因此，由于我们在此示例应用程序中使用Stormpath，因此我们将以特定于Stormpath API的方式为帐户和组分配权限。<br>让我们执行一个cURL请求，为以前创建的Jean-Luc Picard帐户添加一些权限。 使用该帐户的href URL，我们将通过自定义数据将一些apacheShiroPermissions发布到该帐户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">curl -X POST --user <span class="variable">$YOUR_API_KEY_ID</span>:<span class="variable">$YOUR_API_KEY_SECRET</span> \</div><div class="line">    -H <span class="string">"Accept: application/json"</span> \</div><div class="line">    -H <span class="string">"Content-Type: application/json"</span> \</div><div class="line">    <span class="_">-d</span> <span class="string">'&#123;</span></div><div class="line">            "apacheShiroPermissions": [</div><div class="line">                "ship:NCC-1701-D:command",</div><div class="line">                "user:jlpicard:edit"</div><div class="line">            ]</div><div class="line">        &#125;' \</div><div class="line"><span class="string">"https://api.stormpath.com/v1/accounts/<span class="variable">$JLPICARD_ACCOUNT_ID</span>/customData"</span></div></pre></td></tr></table></figure></p>
<p>其中$ JLPICARD_ACCOUNT_ID与你在本教程开头创建的Jean-Luc Picard的插槽相匹配。<br>这将直接向Stormpath帐户添加两个权限：</p>
<ul>
<li>ship:NCC-1701-D:command</li>
<li>user:jlpicard:edit</li>
</ul>
<p>这些使用Shiro的WildcardPermission语法。<br>第一个基本上是指用“NCC-1701-D”标识符来“命令”’船’的能力。这是实例级权限的一个示例：控制对资源船的特定实例NCC-1701-D的访问。第二个也是一个实例级权限，指出使用标识符jlpicard编辑用户的能力。<br>如何在Stormpath中存储权限，以及如何在Stormpath中自定义存储和访问选项超出本文档的范围，但这是在Shiro Stormpath插件文档中解释的。</p>
<h4 id="Permission-Tags"><a href="#Permission-Tags" class="headerlink" title="Permission Tags"></a>Permission Tags</h4><p>就像我们有用于角色检查的JSP标签一样，还有同样用于权限检查的标签。我们更新/home.jsp页面，让用户知道是否允许你根据分配给他们的权限执行某些操作。这些消息将添加到主页的新的<code>&lt;h2&gt;</code>权限<code>&lt;/ h2&gt;</code>部分：<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Permissions<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>You may <span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"ship:NCC-1701-D:command"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>NOT<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span> command the <span class="tag">&lt;<span class="name">code</span>&gt;</span>NCC-1701-D<span class="tag">&lt;/<span class="name">code</span>&gt;</span> Starship!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>You may <span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"user:$&#123;account.username&#125;:edit"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>NOT<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span> edit the $&#123;account.username&#125; user!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当你第一次访问主页时，在登录之前，你将看到以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You may NOT command the NCC-1701-D Starship!</div><div class="line">You may NOT edit the user!</div></pre></td></tr></table></figure></p>
<p>但是，在你使用Jean-Luc Picard帐户登录后，你将看到这一点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You may command the NCC-1701-D Starship!</div><div class="line">You may edit the user!</div></pre></td></tr></table></figure></p>
<p>你可以看到Shiro解决了经过身份验证的用户具有权限，并以适当的方式呈现输出。<br>您还可以使用<shiro：haspermission>标签进行肯定权限检查。<br>最后，我们将注意到极其强大的权限检查功能。 你能看到第二个权限检查如何使用运行时生成的权限值吗？<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"user:$&#123;account.username&#125;:edit"</span>&gt;</span> ...</div></pre></td></tr></table></figure></shiro：haspermission></p>
<p><code>${account.username}</code>在运行的时候将<code>user:aUsername:edit</code>的值组装起来，最后这个最终的值被用来权限检查。<br>这种运行时的权限检查机制是用来构建高度定制化和安全的应用的常规技术。</p>
<h4 id="Run-the-webapp-5"><a href="#Run-the-webapp-5" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>run一run咯</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>我们希望这篇指南能对你使用Shiro构建webapp有帮助。在下个版本我们将推出这些内容：</p>
<ul>
<li>不同用户数据的存储插件，像RDBMS或者NoSQL之类的。</li>
</ul>
<p>原文<a href="http://shiro.apache.org/webapp-tutorial.html" target="_blank" rel="external">Securing Web Applications with Apache Shiro</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是介绍使用Shiro一步一步保护你的web应用的教程。它包含了Shiro的知识，以及和最近两篇文章很相似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.infoq.com/articles/apache-shiro&quot;&gt;Application Security with Apache Shiro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://shiro.apache.org/10-minute-tutorial.html&quot;&gt;Apache Shiro 10 Minute Tutorial&lt;/a&gt;&lt;br&gt;这个入门教程会花费大约45分钟到一个小时。当你读完后，你就会知道Shiro在web应用中怎么工作了的。
    
    </summary>
    
      <category term="Apache" scheme="http://www.wei-dong.top/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.wei-dong.top/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Java Authorization Guide with Apache Shiro[译]</title>
    <link href="http://www.wei-dong.top/2017/09/25/Java%20Authorization%20Guide%20with%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.wei-dong.top/2017/09/25/Java Authorization Guide with Apache Shiro[译]/</id>
    <published>2017-09-25T12:05:23.000Z</published>
    <updated>2017-09-25T12:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>授权或者说访问控制指的是为资源分配访问权限。换句话说就是谁能干什么。</p>
<p>举个授权的栗子：用户允许看网页、改数据、看按钮或者打印吗？这些都能决定用户能不能做什么。<br><a id="more"></a></p>
<h3 id="Elements-of-Authorization"><a href="#Elements-of-Authorization" class="headerlink" title="Elements of Authorization"></a>Elements of Authorization</h3><p>授权有三个我们在Shiro中使用很多的核心元素–权限、角色和用户。</p>
<h3 id="Permissions-Defined"><a href="#Permissions-Defined" class="headerlink" title="Permissions Defined"></a>Permissions Defined</h3><p>权限是安全策略的最原子级别，它们是功能语句。权限就是在你的应用中能做什么。权限描述了资源类型以及当你与这些资源进行交互时可能采取的操作。你能开门吗？你能读取文件吗？你能删除客户记录吗？你能按按钮吗？</p>
<p>数据相关资源的常见操作是创建，读取，更新和删除，通常称为CRUD。</p>
<p>重要的是要明白，权限不是谁能执行的操作 - 它们只是可以执行哪些操作的语句。</p>
<h4 id="Levels-of-permission-granularity"><a href="#Levels-of-permission-granularity" class="headerlink" title="Levels of permission granularity"></a>Levels of permission granularity</h4><p>以上权限都指定资源（门，文件，客户记录等）上的操作（打开，读取，删除等）。在Shiro，您可以定义任何您喜欢的粒度的权限。以下是粒度顺序的几个常见权限级别。</p>
<ul>
<li>资源级别 - 这最广泛最简单构建。 用户可以编辑客户记录或打开门。 资源被指定，但不是该资源的特定实例。</li>
<li>实例级别 - 权限可以指定资源的实例。 用户可以编辑IBM的客户记录或打开厨房门。</li>
<li>属性级别 - 权限现在可以指定实例或资源的属性。 用户可以编辑IBM客户记录上的地址。</li>
</ul>
<p>获取更多信息:<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external">Permissions Documentation</a></p>
<h3 id="Roles-Defined"><a href="#Roles-Defined" class="headerlink" title="Roles Defined"></a>Roles Defined</h3><p>在授权的上下文中，角色实际上是用于简化权限和用户管理的权限集合。因此，用户可以分配角色，而不是直接分配权限，这可能会使较大的用户基础和更复杂的应用程序变得复杂。因此，例如，银行应用程序可能具有管理员角色或银行出纳员角色。</p>
<p>有2中类型的角色你需要知道，Shiro同时也支持。</p>
<h4 id="Implicit-Roles（隐式的角色）"><a href="#Implicit-Roles（隐式的角色）" class="headerlink" title="Implicit Roles（隐式的角色）"></a>Implicit Roles（隐式的角色）</h4><p>代码中的角色检查通常是隐含角色的反映。你可以查看患者数据，因为你具有管理员角色。你可以创建一个帐户，因为你有银行出纳员角色。事实上这些名字的存在和软件具体能做的没有任何关系。大多数人以这种方式使用角色。这是最简单的，但它可以为所有但最简单的应用程序造成大量的维护和管理问题。</p>
<h4 id="Explicit-Roles（显式的角色）"><a href="#Explicit-Roles（显式的角色）" class="headerlink" title="Explicit Roles（显式的角色）"></a>Explicit Roles（显式的角色）</h4><p>显式角色具有明确分配给它的权限，因此是明确的权限集合。代码中的权限检查反映了明确的角色。你可以查看患者的数据，因为你将患者数据视图视为管理员角色的一部分。你可以创建一个帐户，因为你有创建帐户权限作为你的银行柜员角色的一部分。你可以执行这些操作，而不是因为基于字符串的一些隐式角色名称，而是因为相应权限被明确分配给你的角色。</p>
<p>明确角色的最大好处是易于管理，降低了应用程序的维护。如果你需要添加，删除或更改角色，则可以在不触摸源代码的情况下执行此操作。在Shiro中，你还可以在运行时动态添加，删除或更改角色，并且你的授权检查将始终具有最新值。这意味着你不必强制用户注销并重新登录以获取他们的新权限。</p>
<h3 id="Users-Defined"><a href="#Users-Defined" class="headerlink" title="Users Defined"></a>Users Defined</h3><p>用户就是谁在用这个应用程序。然而，在Shiro，用户的概念实际上是Subject实例。我们使用Subject这个词而不是用户，因为用户通常意味着人类，而在Shiro中，Subject可以与你的应用程序进行任何交互 - 无论是人类还是服务。</p>
<p>用户就是允许在你的应用程序中通过角色或者权限的关联执行某些动作。因此你可以打开一个客户的记录，因为你已经被分配了打开客户记录的权限，或者你被分配了带有权限的角色。</p>
<h3 id="How-to-perform-Authorization-in-Java-with-Shiro"><a href="#How-to-perform-Authorization-in-Java-with-Shiro" class="headerlink" title="How to perform Authorization in Java with Shiro"></a>How to perform Authorization in Java with Shiro</h3><p>在Shiro中授权有四种：</p>
<ul>
<li>以编程方式 - 你可以在java代码中执行授权检查，其结构如if和else。</li>
<li>JDK注解 - 你可以将授权注解附加到Java方法。</li>
<li>JSP / GSP TagLibs  - 你可以根据角色和权限来控制jsp或gsp页面输出</li>
</ul>
<h4 id="Programmatic-Authorization"><a href="#Programmatic-Authorization" class="headerlink" title="Programmatic Authorization"></a>Programmatic Authorization</h4><p>检查角色和权限，在你的代码中使用编程方式是一种传统方式来处理授权。</p>
<h5 id="Role-Check"><a href="#Role-Check" class="headerlink" title="Role Check"></a>Role Check</h5><p>这是一个使用编程方式来检查角色的栗子。我们想检查用户是否具有管理员角色，如果有，那么我们将显示一个特殊的按钮，否则我们不会显示它。</p>
<p>首先我们得到当前用户，也就是Subject。然后我们将admin传给Subject的<code>hasRole()</code>方法。它会返回<code>TRUE</code>或者 <code>FALSE</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get the current Subject </span></div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (currentUser.hasRole(<span class="string">"administrator"</span>)) &#123;</div><div class="line">    <span class="comment">//show a special button‏</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?)‏</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，基于角色的检查是快速和容易实现的，但它具有主要的缺点。 这是隐式的。</p>
<p>如果你只想稍后添加，删除或重新定义角色怎么办？你必须打开源代码，并更改所有角色检查以反映你的安全模型的变化。你必须关闭应用程序，破解代码，测试它，然后重新启动它。</p>
<p>在非常简单的应用程序中，这可能足够好，但对于较大的应用程序，这可能是应用程序的整个生命周期中的主要问题，并为你的软件带来大量维护成本。</p>
<h5 id="Permission-Check"><a href="#Permission-Check" class="headerlink" title="Permission Check"></a>Permission Check</h5><p>这是你如何通过权限进行安全检查的示例。我们想检查用户是否有权打印到laserjet3000n，如果是这样，那么我们将显示打印按钮，否则我们不会显示。这是一个实例级权限或实例级授权的示例。</p>
<p>再次，首先你可以访问当前的用户，Subject。然后构造一个Permission对象或者实例来表示一个动作或者资源。在这个栗子中这个实例可以命名为printPermission,资源是laserjet3000n，动作是打印。然后我们将printPermission传给Subject的<code>.isPermitted()</code>方法。它返回true或者false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">Permission printPermission = <span class="keyword">new</span> PrinterPermission(<span class="string">"laserjet3000n"</span>,<span class="string">"print"</span>);</div><div class="line"></div><div class="line">If (currentUser.isPermitted(printPermission)) &#123;</div><div class="line">    <span class="comment">//do one thing (show the print button?)‏</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Permission-Check-String-based"><a href="#Permission-Check-String-based" class="headerlink" title="Permission Check (String-based)"></a>Permission Check (String-based)</h5><p>你也可以用一个简单的字符串而不是permission类做权限检查。</p>
<p>因此，如果你不想实现我们permission 接口，你仅仅传一个string字符串就行了。在这个栗子中，我们传<code>.isPermitted()</code>一个字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String perm = <span class="string">"printer:print:laserjet4400n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(currentUser.isPermitted(perm))&#123;</div><div class="line">    <span class="comment">//show the print button?</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要你的域知道如何使用它，你可以按照你想要的方式构建权限字符串。在这个栗子中，我们使用Shiro的可选的权限语法，<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external"> WildCardPermissions</a>.WildCardPermissions功能强大直观。</p>
<p>通过使用基于字符串的权限检查，你可以获得的功能和之前的栗子是一样的。好处是你不必强制实现权限接口，你可以通过简单的字符串构造权限。缺点是你没有类型安全，如果你需要更复杂的许可权限，这些权限超出了这个处理的范围。接下来讲如何基于Permission接口实现权限对象。</p>
<h4 id="Annotation-Authorization"><a href="#Annotation-Authorization" class="headerlink" title="Annotation Authorization"></a>Annotation Authorization</h4><p>如果你不想在代码层做权限控制，你也可以使用Java注解。Shiro提供很多注解可以让你放在方法上面。</p>
<h5 id="Enabling-Annotation-Support"><a href="#Enabling-Annotation-Support" class="headerlink" title="Enabling Annotation Support"></a>Enabling Annotation Support</h5><p>在你使用Java注解之前，你需要在你的应用中开启AOP支持。有很多不同的AOP框架，因此不幸的是，在应用中没有一个标准的方式开启AOP。</p>
<p>对AspectJ而言，看栗子<a href="https://github.com/apache/shiro/tree/master/samples/aspectj" target="_blank" rel="external">AspectJ sample application</a></p>
<p>对Spring而言，看栗子<a href="http://shiro.apache.org/spring.html" target="_blank" rel="external"> Spring Integration </a></p>
<p>对Guice而言，看栗子<a href="http://shiro.apache.org/guice.html" target="_blank" rel="external"> Guice Integration</a></p>
<h5 id="Permission-Check-1"><a href="#Permission-Check-1" class="headerlink" title="Permission Check"></a>Permission Check</h5><p>在这个栗子中，我们想检查一个用户在调用<code>openAccount</code>方法之前是否有<code>account:create</code>权限。如果有，按照期望的调用，如果没得，那就抛异常。</p>
<p>和通过编程方式检查权限一样，你可以使用Permission对象或者简单的字符串方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Will throw an AuthorizationException if none</span></div><div class="line"><span class="comment">//of the caller’s roles imply the Account</span></div><div class="line"><span class="comment">//'create' permission</span></div><div class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"account:create"</span>)‏</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openAccount</span><span class="params">( Account acct )</span> </span>&#123;</div><div class="line">    <span class="comment">//create the account</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Role-Check-1"><a href="#Role-Check-1" class="headerlink" title="Role Check"></a>Role Check</h5><p>在这个栗子中，我们想检查一个用户在执行<code>openAccount</code>方法前是否有<code>teller</code>角色。如果有就按照期望的走下去，没有就抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Throws an AuthorizationException if the caller</span></div><div class="line"><span class="comment">//doesn’t have the ‘teller’ role:</span></div><div class="line"><span class="meta">@RequiresRoles</span>( <span class="string">"teller"</span> )</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openAccount</span><span class="params">( Account acct )</span> </span>&#123;</div><div class="line">    <span class="comment">//do something in here that only a teller</span></div><div class="line">    <span class="comment">//should do</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="JSP-TagLib-Authorization"><a href="#JSP-TagLib-Authorization" class="headerlink" title="JSP TagLib Authorization"></a>JSP TagLib Authorization</h4><p>对于基于JSP / GSP的Web应用程序，Shiro还提供了一个标签库供您使用。</p>
<p>在此示例中，我们将向用户显示user:manage权限,一个指向“管理用户”页面的链接。如果他们没有权限，那么我们会给他们一个友好的消息提示。</p>
<p>首先，我们需要将Shiro taglib添加到我们的Web应用程序中。接着我们为user:manage权限添加<shiro:haspermission>标签。在<shiro：haspermission>标签中，如果用户具有我们正在检查的权限，我们就放置要执行的代码。如果我们要执行一个动作假如这个用户缺少权限，我们需要添加<shiro:lackspermission> 标签，再次检查users:manage权限。如果用户缺少权限，我们想要执行的任何代码都需要放在<shiro：lackspermission>标签中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">http://shiro.apache.org/tags</span> %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"users:manage"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"manageUsers.jsp"</span>&gt;</span></div><div class="line">            Click here to manage users</div><div class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"users:manage"</span>&gt;</span></div><div class="line">        No user management for you!</div><div class="line">    <span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></shiro：lackspermission></shiro:lackspermission></shiro：haspermission></shiro:haspermission></p>
<p>当然，还有用于检查角色和其他用户数据和状态的标签。</p>
<p>有关JSP / GSP标签的更多信息，请查看JSP标签库，以及有关将应用程序集成到Web应用程序中的更多信息，请阅读<a href="http://shiro.apache.org/web.html" target="_blank" rel="external">Web集成文档</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;授权或者说访问控制指的是为资源分配访问权限。换句话说就是谁能干什么。&lt;/p&gt;
&lt;p&gt;举个授权的栗子：用户允许看网页、改数据、看按钮或者打印吗？这些都能决定用户能不能做什么。&lt;br&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://www.wei-dong.top/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.wei-dong.top/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Application Security With Apache Shiro[译]</title>
    <link href="http://www.wei-dong.top/2017/09/21/Application%20Security%20With%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.wei-dong.top/2017/09/21/Application Security With Apache Shiro[译]/</id>
    <published>2017-09-21T04:41:23.000Z</published>
    <updated>2017-09-21T04:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的应用添加安全措施的时候有没有觉得很受挫？你有没有觉得Java在安全这一块的解决方案用起来很难，让你更加觉得困惑？这篇文章介绍<a href="http://shiro.apache.org/" target="_blank" rel="external">Apache Shiro</a>,一个简单又强大为你应用提供安全的Java框架。本文对Apache Shiro的愿景、架构设计及怎样去使用Shiro来保护你的应用进行解释。</p>
<h3 id="Apache-Shiro是什么？"><a href="#Apache-Shiro是什么？" class="headerlink" title="Apache Shiro是什么？"></a>Apache Shiro是什么？</h3><p>Apache Shiro（发音为“歇肉”，在日本的发音是城堡的意思）是一个强大又好用的Java安全框架，它提供认证、授权、加密和会话管理，它可以被用在保护任何应用–从命令行应用、移动应用到大型的web企业级应用。</p>
<p>Shiro为以下几个方面提供应用安全的API。</p>
<ul>
<li>认证-证明用户身份，通常叫做登录</li>
<li>授权-访问控制</li>
<li>加密-保护或隐藏数据不被窥视</li>
<li>会话管理-每个用户的状态是对时间敏感的</li>
</ul>
<p>Shiro还提供辅助的特性，比如说web安全，单元测试，和多线程的支持。这些都是为了加强上面提到的几个特性。</p>
<h3 id="Apache-Shiro为什么被发明？"><a href="#Apache-Shiro为什么被发明？" class="headerlink" title="Apache Shiro为什么被发明？"></a>Apache Shiro为什么被发明？</h3><p>对于一个框架而言，它存在的意义就是它满足你的需求而找不到其他的替代方案。为了理解这些东西，我们有必要翻一番Shiro的历史以及当时的替代品。</p>
<p>在2008年加入ASF之前，Shiro都5岁了，而且和早在2003年开始的JSecurity一样有名了。在2003年，没有太多为Java开发者提供可选的安全方案。我们坚持使用Java认证和Java授权服务，称作JAAS。然而JASS有很多缺点当然认证能力是可以接受的，授权方面让人用起来觉得很崩溃。JAAS和JVM级别的安全密切相关，比方说决定一个class该不该被加载到JVM。作为一个应用开发者，我更关心的是应用程序用户能做什么，而不是我的代码在JVM里能做什么。</p>
<p>由于我当时着手的工作，我需要一个干净的和容器无关的会话机制。当时在游戏（我猜作者的工作就是写游戏）中唯一的选择就是HttpSession，这个玩意需要一个web容器或者EJB容器。我需要的是能够从容器中解耦，而且在任何环境下都好用的。</p>
<p>最后有一个密码的问题。有很多情况下我们需要加密数据，但是Java加密架构除了密码专家外普通人很难理解。它的API到处都是异常检查，用起来感觉很笨重。我迫切希望一个干净的开箱即用的可以满足我的需求的解决方案。</p>
<p>看了一下在2003年早期的安全概况，你能很快的意识到没有一款单一的框架能够满足这些需求。正因为如此，JSecurity还有后来的Shiro诞生了。</p>
<h3 id="如今你为何用Apache-Shiro"><a href="#如今你为何用Apache-Shiro" class="headerlink" title="如今你为何用Apache Shiro?"></a>如今你为何用Apache Shiro?</h3><p>自2003年来，框架的格局发生了很大的变化，因此现在有一个让人信服的理由来使用Shiro。理由如下：</p>
<ul>
<li>好用–好用是一个项目最关键的目标。应用安全可能是非常让人沮丧和困惑，因此被称作“必要的罪恶”。假如你让它变得新手程序员都容易使用，那就不那么痛苦了。</li>
<li>全面–没有比Shiro更广泛的安全框架了，因此它可以一站式满足你对安全的需要。</li>
<li>灵活–Shiro能在任何环境下工作。虽然它在web、EJB、和ioC容器中工作，但是它不依赖他们。Shiro没有太多的规定，也没有太多的依赖。</li>
<li>支持web–Shiro对web应用有全面的支持，你可以创建基于web协议和url的灵活的安全策略，同时提供一套控制页面输出的JSP库。</li>
<li>可插拔–Shiro干净的API（干净可以翻译为简洁）和设计思想可以让你很容易地集成到其他框架和应用。你可以看到Shiro和Spring、Grails等框架无缝集成。</li>
<li>支持–Shiro是ASF的一部分。这个项目的开发和用户群会友好的提供帮助。如果需要，像<a href="https://stormpath.com/" target="_blank" rel="external">Katasoft</a>商业公司也会提供专业的支持和服务。</li>
</ul>
<h3 id="谁在用Shiro？"><a href="#谁在用Shiro？" class="headerlink" title="谁在用Shiro？"></a>谁在用Shiro？</h3><p>Shiro和它的先驱JSecurity在很多行业很多公司的项目中用了很多年。在成为ASF顶级项目之后，它的网站流量和使用率大增。也有许多开源的组织使用Shiro，比方说Spring, Grails, Wicket, Tapestry, Tynamo, Mule, 和 Vaadin。</p>
<p>商业公司像Katasoft、Sonatype、MuleSoft等也使用Shiro来保护他们的商业软件和网站。</p>
<h3 id="核心概念：主体，安全管理器，域"><a href="#核心概念：主体，安全管理器，域" class="headerlink" title="核心概念：主体，安全管理器，域"></a>核心概念：主体，安全管理器，域</h3><p>目前我们讲了Shiro的优点，我们直接来看看它的API，让你直接感受它。Shiro的架构有3个核心的概念–主体、安全管理器和域。</p>
<h4 id="Subject-主体"><a href="#Subject-主体" class="headerlink" title="Subject(主体)"></a>Subject(主体)</h4><p>当你要对你的应用进行保护的时候，你最大的可能要问的问题就是“当前用户是谁？”或者“当前用户允许做这件事吗？”，我们问自己这些问题是很正常的，就像我们在写代码或者设计接口一样。应用程序通常是基于用户故事来构建，而且你想基于每个用户来构建你的功能。因此，你考虑在你应用安全最常规的思路就是基于当前用户。Shiro API中的主体概念基本上体现了这种思路。</p>
<p>主体是安全术语中的一个名词，代表的是当前执行的用户。不能仅仅只称作“用户”因为“用户”这个词通常和人类关联起来。在安全领域，主体这个词可以代表一个人，也可以代表第三方进程、一个后台账号或者类似的东西。简单来讲，就是和当前软件交互的东西。然而对于大多数目的和用途，你可以把它当做Shiro用户的概念。你能很容易地在你的代码中获取Shiro的主体，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import org.apache.shiro.subject.Subject;</div><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">...</div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div></pre></td></tr></table></figure></p>
<p>一旦你获取了主体，你就能使用Shiro为当前用户拿到90%的访问权限，比如登录，退出登录，获取session，执行权限检查等。这里关键点是Shiro的API大体上是很直观的，从中可以体现开发者在针对每个用户的安全控制中的思路（这句话实在是不知道怎么翻译）。在代码中任何地方获取主体很容易，在需要进行安全操作的地方进行控制也很容易。</p>
<h4 id="SecurityManager-安全管理器"><a href="#SecurityManager-安全管理器" class="headerlink" title="SecurityManager(安全管理器)"></a>SecurityManager(安全管理器)</h4><p>在主体背后后与之配对的是安全管理器。主体提供当前用户的安全操作，然而安全管理器为所有用户管理着安全操作。这是Shiro架构的核心，有类似于很多“伞”的作用。这些伞内部引用了很多嵌套的安全组件而形成一个伞图（翻译很晦涩，意思就是很多组件组合而成）。然而，一旦安全管理器及内部的“伞图”配置好了，应用开发者几乎将所有时间都花在了主体API上，通常这个安全管理器是独立的。</p>
<p>在每一个应用中总有一个安全管理器实例。本质上是一个单例应用（虽然不必是静态单例）。像Shiro中其他东西一样，默认的安全管理器的实现是POJO，可以通过任何与POJO兼容的配置机制–普通的Java代码、Spring XML、YAML、.properties和ini文件等等。通常来讲，能够被实例化的类和能够调用JavaBean兼容方法的都可以使用。</p>
<p>为此，Shiro借助基于文本的INI配置提供了一个缺省的“公共”解决方案。INI读起来很容易，用起来很简单，而且依赖的东西也很少。你可以看到，通过简单了解对象图导航，INI可以很高效的配置简单的对象图,像SecurityManager。注意Shiro也支持Spring XML配置合其他替代品。我们这里只谈INI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">cm = org.apache.shiro.authc.credential.HashedCredentialsMatcher</div><div class="line">cm.hashAlgorithm = SHA-512</div><div class="line">cm.hashIterations = 1024</div><div class="line">#Base64 encoding (less text):</div><div class="line">cm.storedCredentialsHexEncoded = false</div><div class="line">iniRealm.credentialsMatcher = $cm</div><div class="line">[users]</div><div class="line">jdoe = TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJpcyByZWFzb2</div><div class="line">asmith = IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbXNoZWQsIG5vdCB</div></pre></td></tr></table></figure></p>
<p>在上面的INI配置例子中，我们看到配置SecurityManager 实例。在INI配置中有2个部分：[main]和[users].</p>
<p>[main]部分用于配置SecurityManager对象或者被SecurityManager 使用的任何对象。在这个例子中，我们看到了两个对象被配置：</p>
<ol>
<li>cm对象，Shiro中的HashedCredentialsMatcher 类的一个实例。你能看到，很多cm的属性通过嵌套的点的语法被配置。清单3所示的IniSecurityManagerFactory使用的约定来表示对象图形导航和属性设置。</li>
<li>iniRealm对象，它是SecurityManager用于表示以INI格式定义的用户帐户的组件。</li>
</ol>
<p>在[users]这部分中你可以指定一个静态的用户列表，对于简单的应用是很方便来测试的。</p>
<p>介绍这些的目的不是去理解每个部分的复杂性，而是INI配置方式是一种简单的Shiro配置。更多关于INI配置的细节，详情可以参考<a href="http://shiro.apache.org/documentation.html" target="_blank" rel="external">Shiro文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</div><div class="line">import org.apache.shiro.mgt.SecurityManager;</div><div class="line">import org.apache.shiro.util.Factory;</div><div class="line">...</div><div class="line">//1. Load the INI configuration</div><div class="line">Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</div><div class="line">//2. Create the SecurityManager SecurityManager securityManager = factory.getInstance();</div><div class="line">//3. Make it accessible</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，我们有3个步骤：</p>
<ol>
<li>加载配置SecurityManager及其组件的INI配置文件。</li>
<li>基于这个配置创建SecurityManager实例(使用Shiro的工厂概念)。</li>
<li>把SecurityManager变成单例。在这个例子中，我们将它设置成VM静态单例，但是这不是必须的。你的应用配置机制可以决定你要不要使用静态内存(这段翻译真的一点都不容易理解)。</li>
</ol>
<h4 id="Realms-域"><a href="#Realms-域" class="headerlink" title="Realms(域)"></a>Realms(域)</h4><p>Shiro中第三个核心概念就是域。域在你的应用数据和Shiro中承担一个桥梁或者说是连接器的角色。也就是说，当和安全相关的数据交互，比方说认证（登录）和授权（访问控制）时，Shiro从为应用配置的一个或者多个域配置中去找这些东西。</p>
<p>在某种意义上，一个域本质上就是一个安全的DAO：它为数据源封装了连接细节以及在需要的时候让Shiro能够访问关联的数据。当在配置Shiro的时候，你必须指定至少一个域用来做认证或者授权。可以配置多个，但至少要有一个。</p>
<p>Shiro提供开箱即用的域来连接各种安全的数据源，比方说LDAP、数据库相关的（JDBC）、文本文件配置类似INI文件和properties配置文件等。如果默认的域不能满足你的需求，你也可以将你自己实现的域插入到其中。下面通过INI配置Shiro的例子就是用LDAP来作为应用的一个域实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">ldapRealm = org.apache.shiro.realm.ldap.JndiLdapRealm</div><div class="line">ldapRealm.userDnTemplate = uid=&#123;0&#125;,ou=users,dc=mycompany,dc=com</div><div class="line">ldapRealm.contextFactory.url = ldap://ldapHost:389</div><div class="line">ldapRealm.contextFactory.authenticationMechanism = DIGEST-MD5</div></pre></td></tr></table></figure></p>
<p>现在我们知道了怎么配置一个基础的Shiro环境，我们接下来一起讨论作为一个开发者你改怎么使用这个框架。</p>
<h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>认证是验证用户的唯一性的过程。就是说，当用户使用应用进行认证的时候，他们在证明他们确实是他们所说的那个人。通常有时候我们把它称作登录。典型的三个步骤：</p>
<ol>
<li>收集用户身份信息，也叫作principals，并支持身份证明，称为credentials。</li>
<li>提交principals和credentials到系统。</li>
<li>如果提交的credentials和系统期望该用户身份匹配，这个用户就可以认为认证通过。如果不匹配，那就是认证不通过。</li>
</ol>
<p>每个人都熟悉的最常见的例子就是用户名和密码的组合。当用户登录到系统，他们通常提供他的用户名（principal）和密码（credential）。如果存储在系统中的 密码和用户提供的一致，他就被认证成功。</p>
<p>Shiro以简单直观的方式支持类似的流程。正如我们说的，Shiro有一套以主体为中心的API–几乎所有在运行时你和Shiro关心的都是通过与当前执行的主体交互实现的。因此，要登录一个主体，你只需要调用它的登录方法，传一个带有principals 和credentials的AuthenticationToken实例。下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//1. Acquire submitted principals and credentials:</div><div class="line"> AuthenticationToken token = new UsernamePasswordToken(username,password);</div><div class="line">//2. Get the current Subject:</div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"> //3. Login:</div><div class="line"> currentUser.login(token);</div></pre></td></tr></table></figure></p>
<p>如你所见，Shiro的APi很简单的表示了这个流程。你可以将这种对所有主体操作的简单性作为一种特色。当登录方法被调用，SecurityManager将接收AuthenticationToken然后将其分发到一个或者多个配置好的域中用来做认证。每个域都有能力根据需要对提交的AuthenticationToken进行处理。但是假如登录失败了会发生什么呢？假如用户的密码输错了呢？你可以通过运行时的AuthenticationException 来处理这些失败，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//3. Login:</div><div class="line">try &#123;</div><div class="line">    currentUser.login(token);</div><div class="line">&#125; catch (IncorrectCredentialsException ice) &#123; …</div><div class="line">&#125; catch (LockedAccountException lae) &#123; …</div><div class="line">&#125;</div><div class="line">…</div><div class="line">catch (AuthenticationException ae) &#123;…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以选择捕获AuthenticationException的一个子类来进行具体的处理，或者统一处理任何AuthenticationException（比如说，通常显示“用户名或者密码错误”消息）。这是根据你应用的需求来选择的。</p>
<p>一个主体登录成功后，他们被认为认证通过，通常你允许他们使用你的应用。但是，由于用户仅证明了自己的身份不代表他们在应用中能做任何他们想做的事情。这就提出了下一个问题：“我如何控制用户被允许做什么？”决定用户允许做什么叫做授权。接下来我们讨论Shiro怎么启用授权。</p>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>授权是基本的访问控制–控制你的用户在你的应用中可以访问什么，比方说资源、web页面等等。大多数用户通过使用角色和权限等概念来执行访问控制。就是说，一个用户通常允许做什么事或者不允许做什么事是基于他们分配的角色或者权限的。然后，你的应用程序可以根据对这些角色和权限的检查来控制显示哪些功能。正如你期望的，主体API允许你非常容易的执行权限和角色检查。代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.hasRole(“administrator”) ) &#123;</div><div class="line">    //show the ‘Create User’ button</div><div class="line">&#125; else &#123;</div><div class="line">    //grey-out the button?</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，你的应用可以基于访问控制开启或者关闭功能。</p>
<p>权限检查是另一种执行授权的方式。在上面的例子中检查权限有一个很大的缺陷：你不能再运行的时候添加或者删除角色。你的代码是和角色名字硬编码进去的，因此假如你改变了角色名或者配置，你的代码将会爆炸！假如你需要可以在运行时改变角色的含义，或者根据需要添加删除角色，那么你就必须依靠别的东西了。</p>
<p>为此，Shiro支持权限的概念。权限是原始功能的说明，举个栗子，‘开门’、‘创建博客实体’、‘删除xx用户’等等。有权限代表你有应用的原始功能，当你更改应用程序的功能时，你只需要更改权限检查。反过来，在运行时必要的时候你可以分配权限到角色或者用户。下面的代码使用权限检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.isPermitted(“user:create”) ) &#123;</div><div class="line">    //show the ‘Create User’ button</div><div class="line">&#125; else &#123;</div><div class="line">    //grey-out the button?</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，任何分配了“user：create”权限的角色或用户可以单击“创建用户”按钮,而且这些角色和分配甚至可以在运行时更改，给你提供了一种非常灵活的安全模型。</p>
<p>“user：create”字符串是遵守某些解析约定的权限字符串的示例。Shiro通过其WildcardPermission支持这个开箱即用的约定。虽然超出本导言文章的范围，你将看到WildcardPermission在创建安全策略时可以非常灵活，甚至支持诸如实例级访问控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.isPermitted(“user:delete:jsmith”) ) &#123;</div><div class="line">    //delete the ‘jsmith’ user</div><div class="line">&#125; else &#123;</div><div class="line">    //don’t delete ‘jsmith’</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子展示了你能控制，甚至可以细化到更细粒度的级别，如果有需要可以访问单个资源。如果你想的话你也可以发明自己的权限语法。参考<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external">Shiro Permission</a>获取更多详情。最后，就像身份验证一样，上面的调用最终也进入了SecurityManager，SecurityManager将会查询一个或多个域，以作出访问控制决定。这允许领域根据需要对认证和授权操作进行响应。</p>
<p>到此就是一个队Shiro授权功能的一个简要概述。很多安全框架在认证和授权面前停了下来，而Shiro不止于此。接下来我们要讨论Shiro的高级会话管理功能。</p>
<h4 id="Session-Management"><a href="#Session-Management" class="headerlink" title="Session Management"></a>Session Management</h4><p>Shiro提供安全框架里独一无二的：可用于任何应用和任何结构层一致的会话API。也就是说，Shiro为任何应用程序启用了会话编程范例–从小的后台应用到大型集群web应用。这意味着希望使用会话的应用程序开发人员不再强制使用Servlet或EJB容器。或者，如果使用这些容器，开发人员现在可以选择在任何层中使用统一和一致的会话API，而不是使用servlet或EJB特定的机制。</p>
<p>但是或许一个最重要的好处是Shiro会话是独立于容器的。这具有微妙但非常强大的含义。例如我们考虑会话集群。有多少以指定容器的方式来集群会话以进行容错和故障转移？Tomcat和Jetty做的不一样，和Websphere也不一样。但是使用Shiro session，你可以获得一个容器无关的集群解决方案。Shiro的架构允许可插拔的会话数据存储，例如企业级缓存，关系型数据库。NoSQL等。这意味着你可以一次配置会话群集，并且无论你的部署环境如何，它都将以相同的方式工作–Tomcat、Jetty、JEE Server或者独立的应用。实在是没用必要根据你怎么部署你的应用来重新配置你的应用。</p>
<p>另一个Shiro session的好处是session数据如果需要可以跨客户端共享。举个栗子，如果需要，Swing桌面客户端可以参与相同的Web应用程序会话–如果终端用户同时使用两者，则很有用。因此你怎样在任何环境下访问主体的session？下面的代码主体的2个方法会展示出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Session session = subject.getSession();</div><div class="line">Session session = subject.getSession(boolean create);</div></pre></td></tr></table></figure></p>
<p>如你所见，这些方法在概念上与HttpServletRequest API相同。第一个方法将会返回主体存在的session，如果没有，那就创建一个再返回。第二个方法接收一个bool参数，这个参数决定是否在session不存在的时候创建新的session。一旦你请求主体的session，你可以使用它和几乎使用HttpSession一样。Shiro团队考虑到HTTPSession对Java开发人员很友好，因此我们有这种感觉。最大的区别就是你可以在任何应用中使用Shiro Session，不仅限于web应用。下面的代码展示了其相同之处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Session session = subject.getSession();</div><div class="line">session.getAttribute(“key”, someValue);</div><div class="line">Date start = session.getStartTimestamp();</div><div class="line">Date timestamp = session.getLastAccessTime();</div><div class="line">session.setTimeout(millis);</div></pre></td></tr></table></figure></p>
<h4 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h4><p>密码学是隐藏或混淆数据的过程，所以窥探眼睛无法理解它。Shiro在密码学中的目标是简化和使用JDK的加密支持。要注意的是，一般来说密码学对于主体来说不是特定的，所以它是Shiro API的一个领域，和主体无关。你可以使用Shiro的加密用在任何地方，即使主体没有使用。Shiro真正关注的两个领域一个是哈希加密和密码加密。</p>
<h5 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h5><p>如果你用过JDK的MessageDigest类，你很快会发现用起来有一点笨重。它有一套基于工厂的笨重的静态方法API，而不是面向对象的，而且你被迫捕获那些永远不会被捕获的异常。假如你需要16进制或者base64编码消息摘要的输出，你得自己写–没有标准的JDK实现。Shiro以干净直观的散列API解决了这些问题。</p>
<p>打个比方，我们考虑一下比较常见的MD5散列文件并确定该哈希值的十六进制值的情况。“校验和”，这是在提供文件下载时经常使用的 - 用户可以在下载的文件上执行自己的MD5哈希，并声明其校验和与下载站点的校验和匹配。假如匹配，用户可以充分地假设该文件在传输过程中没有被篡改。</p>
<p>在不使用Shiro情况下这个过程：</p>
<ol>
<li>将文件转化为字节数组。JDK不能帮你完成，因此你得自己创建一个打开FileInputStream的方法，使用字节缓冲，然后抛出可能的异常等等。</li>
<li>用MessageDigest类来对字节数组求哈希，处理异常。</li>
<li>对哈希后的字节数组编码成16进制。JDK中也没有现成的帮你完成，因此你得创建另一个帮助类，并且可能在你的实现中使用按位操作和位移。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">    md.digest(bytes);</div><div class="line">    byte[] hashed = md.digest();</div><div class="line">&#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这么简单和相对普遍的事情来说，这是一个很繁琐的工作。<br>看看Shiro怎么做相同的事情的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String hex = new Md5Hash(myFile).toHex();</div></pre></td></tr></table></figure></p>
<p>当你使用Shiro来简化所有这些工作时，这是非常简单和容易理解的。  SHA-512散列和Base64编码的密码同样简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String encodedPassword =</div><div class="line">    new Sha512Hash(password, salt, count).toBase64();</div></pre></td></tr></table></figure>
<p>可以看到在哈希和编码上Shiro帮你简化了多少，在这个过程中节省了你不少时间。</p>
<h5 id="Ciphers"><a href="#Ciphers" class="headerlink" title="Ciphers"></a>Ciphers</h5><p>密码是可以使用密钥可逆地转换数据的加密算法。我们通常用作保护数据安全，特别在传输或者存储数据的时候，数据特别容易被窥探。</p>
<p>如果你曾经使用过JDK加密API，特别是 javax.crypto.Cipher类，你知道这可以是一个难以置信的复杂野兽驯服（翻译为这是一个很困难的过程）。对于入门者而言，每个密码配置始终由javax.crypto.Cipher的一个实例表示。需要公钥/私钥加密吗？</p>
<p>然而怎么创建你需要的Cipher 实例？你创建一个复杂的，非直观的令牌分隔的密码选项字符串，称为“转换字符串”，并将此字符串传递给Cipher.getInstance静态工厂方法。使用这种密码选项String方法，没有类型安全性来确保你使用有效的选项。这也隐含意味着没有JavaDoc帮助你了解相关选项。而且您还需要处理检查的异常情况，以防你的String配置不正确，即使你知道配置正确。正如你所看到的，使用JDK密码是一项相当麻烦的任务。这些技术曾经是Java API在很久以前的标准，但时代已经改变，我们想要一个更简单的方法。</p>
<p>Shiro尝试通过引入其CipherService API来简化加密密码的整个概念。CipherService是大多数开发人员在保护数据时所需要的：一种简单，无状态，线程安全的API，可以在一个方法调用中对数据进行全面加密或解密。所有你需要做的是提供你的密钥，可以根据需要进行加密或解密。例如，可以使用256位AES加密：</p>
<blockquote>
<p>AesCipherService cipherService = new AesCipherService();<br>cipherService.setKeySize(256);<br>//create a test key:<br>byte[] testKey = cipherService.generateNewKey();<br>//encrypt a file’s bytes:<br>byte[] encrypted =<br>    cipherService.encrypt(fileBytes, testKey);</p>
</blockquote>
<p>与JDK的Cipher API相比，Shiro示例更简单:</p>
<ul>
<li>你可以直接实例化CipherService  - 没有奇怪或混乱的工厂方法。</li>
<li>密码配置选项表示为与JavaBeans兼容的getter和setter  - 没有奇怪和难以理解的“转换字符串”。</li>
<li>加密和解密在单一方法调用中执行。</li>
<li>没有强制检查异常。 如果你想要的话，可以捕获Shiro的CryptoException。</li>
</ul>
<p>Shiro的CipherService API还有其他优点，例如支持基于字节数组的加密/解密（称为“块”操作）以及基于流的加密/解密（例如，加密音频或视频）的能力。</p>
<p>Java加密技术不必如此难受。<br>Shiro对密码的支持旨在简化你保护数据安全的付出。</p>
<h4 id="Web-Support"><a href="#Web-Support" class="headerlink" title="Web Support"></a>Web Support</h4><p>最后，但不是不重要的，我们简要介绍Shiro对web的支持。Shiro拥有强大的web支持模块，来保护web应用安全。为一个web应用设置Shiro是很简单的。仅需要在web.xml中定义一个Shiro Servlet Filter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;</div><div class="line">        org.apache.shiro.web.servlet.IniShiroFilter</div><div class="line">    &lt;/filter-class&gt;</div><div class="line">    &lt;!-- no init-param means load the INI config</div><div class="line">        from classpath:shiro.ini --&gt; </div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;</div><div class="line">     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>这个过滤器能够读之前的shiro.ini配置文件，因此无论在什么样的部署环境下，配置都是一样的。一旦配置好了，Shiro filter就会过滤一切请求，并确保在请求期间特定的请求主体可被访问。由于过滤所有请求，你可以执行指定安全的逻辑代码，以确保仅允许符合特定条件的请求。</p>
<h4 id="URL-Specific-Filter-Chains"><a href="#URL-Specific-Filter-Chains" class="headerlink" title="URL-Specific Filter Chains"></a>URL-Specific Filter Chains</h4><p>Shiro通过它特有的URL链来支持安全的过滤规则。它允许你为任何匹配的URL模式指定特殊过滤器链。这意味着在使用Shiro过滤机制的时候你有很大的灵活性–比在web.xml中定义的过滤器好很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[urls]</div><div class="line">/assets/** = anon</div><div class="line">/user/signup = anon</div><div class="line">/user/** = user</div><div class="line">/rpc/rest/** = perms[rpc:invoke], authc</div><div class="line">/** = authc</div></pre></td></tr></table></figure></p>
<p>如你所见，有一个用于web应用的[urls]部分。每一行等号的左边表示一个上下文相关的web应用路径。等号右边定义了一个过滤器链–有序的、逗号分隔的为指定路径执行servlet过滤器列表。每一个过滤器是一个servlet filter，但是你在上述看到的过滤器是特殊的，是与安全相关的由Shiro提供开箱即用的过滤器。你可以组合和匹配这些安全过滤器，以创建自定义的安全体验。你还可以指定任何其他现有的可能拥有的Servlet过滤器。</p>
<p>使用Shiro，更容易看出为给定的匹配路径执行的过滤器链。只要你想，你可以只在web.xml中定义Shiro filter然后在ini配置文件中定义其他过滤器和过滤器链，这样比web.xml更简洁，易于理解的过滤器链定义机制。即使你没有使用任何Shiro的安全特性，这个小小的方便让Shiro值得使用。</p>
<h4 id="JSP-Tag-Library"><a href="#JSP-Tag-Library" class="headerlink" title="JSP Tag Library"></a>JSP Tag Library</h4><p>Shiro还提供一套JSP标签来允许你基于当前主体的状态控制页面输出。一个常见有用的例子就是当一个用户登录后显示‘Hello <username>’文本。但是假如他们是匿名的，你就得显示点别的，像“Hello! Register Today!”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib prefix=&quot;shiro&quot;</div><div class="line">    uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</div><div class="line">...</div><div class="line">&lt;p&gt;Hello</div><div class="line">&lt;shiro:user&gt;</div><div class="line">    &lt;!-- shiro:principal prints out the Subject’s main</div><div class="line">        principal - in this case, a username: --&gt;</div><div class="line">    &lt;shiro:principal/&gt;!</div><div class="line">&lt;/shiro:user&gt;</div><div class="line">&lt;shiro:guest&gt;</div><div class="line">    &lt;!-- not logged in - considered a guest. Show</div><div class="line">        the register link: --&gt;</div><div class="line">    ! &lt;a href=”register.jsp”&gt;Register today!&lt;/a&gt;</div><div class="line">&lt;/shiro:guest&gt;</div><div class="line">&lt;/p&gt;</div></pre></td></tr></table></figure></username></p>
<p>还有其他标签基于用户有哪些角色或者没有哪些角色，分配了哪些权限，有没有被认证，“记住我”了的，或者一个匿名用户来允许你输出。<br>Shiro支持很多web特有的feature，像记住我，REST和BASIC认证，当然，如果你希望使用Shiro的本地企业会话，也可以使用透明的HttpSession支持。参见<a href="http://shiro.apache.org/web.html" target="_blank" rel="external">Apache Shiro web documentation</a></p>
<h4 id="Web-Session-Management"><a href="#Web-Session-Management" class="headerlink" title="Web Session Management"></a>Web Session Management</h4><p>最后，有趣的是探讨Shiro在web环境中对session的支持。</p>
<h5 id="Default-Http-Sessions"><a href="#Default-Http-Sessions" class="headerlink" title="Default Http Sessions"></a>Default Http Sessions</h5><p>对web应用而言，Shiro默认的session架构是我们现有常使用的Servlet Container。当你调用<code>subject.getSession()</code>和<code>subject.getSession(boolean)</code>方法的时候，Shiro会返回一个由Servlet 容器支持的session实例。这种方法的优点是调用subject.getSession（）的业务层代码与Shiro Session实例进行交互–它并不知道是和一个基于web的HTTPSession对象一起工作的。分层架构保持代码整洁是很好的做法。</p>
<h5 id="Shiro’s-Native-Sessions-in-the-Web-Tier"><a href="#Shiro’s-Native-Sessions-in-the-Web-Tier" class="headerlink" title="Shiro’s Native Sessions in the Web Tier"></a>Shiro’s Native Sessions in the Web Tier</h5><p>假如你在web应用中开启了Shiro的本地session管理，你需要Shiro的企业session特性（类似独立于容器的集群），当然你想<code>HttpServletRequest.getSession()</code> 和<code>HttpSession</code> API和本地session一起使用而不是servlet容器的session。如果你要重构任何使用HttpServletRequest和HttpSession API的代码，而不是使用Shiro的Session API，那将是非常令人沮丧的。Shiro永远不期望你这样做。相反，Shiro完全实现了Servlet规范的Session部分，以支持Web应用程序中的本机会话。这意味着每当你调用相应的HttpServletRequest或HttpSession方法调用时，Shiro会将这些调用委托给其内部本地Session API。结果就是你不需要去改动你的代码，即使你使用Shiro本地会话管理–实际上是一个非常方便和必要的特性。</p>
<h3 id="Additional-Features"><a href="#Additional-Features" class="headerlink" title="Additional Features"></a>Additional Features</h3><p>在Shiro框架中其他用于让Java应用安全的特性，例如（中文翻译太晦涩，还是直接贴原文的）：</p>
<ul>
<li>Threading and Concurrency support for maintaining Subjects across threads (Executor and ExecutorService support)</li>
<li>Callable and Runnable support for executing logic as a specific Subject</li>
<li>“Run As” support for assuming the identity of another Subject (e.g. useful in administrative applications)</li>
<li>Test harness support, making it very easy to have full testing of Shiro secured-code in unit and integration tests</li>
</ul>
<h3 id="Framework-Limitations"><a href="#Framework-Limitations" class="headerlink" title="Framework Limitations"></a>Framework Limitations</h3><p>就像我们想要的那样，Apache Shiro不是一个“银弹”–它不会轻易解决所有安全问题。Shiro没有解决这些事情:</p>
<ul>
<li>虚拟机级别的考虑：当前Shiro没有考虑虚拟机级别的安全，比如基于访问控制策略的阻止特定的class加载到类加载器中。然而Shiro和现有的JVM安全操作整合起来是不可思议的–只是没有人去为这个项目做这件事罢了。</li>
<li>多阶段认证：Shiro当前不支持‘多阶段’认证，用户可以通过一种机制登录，只能被要求使用不同的机制再次登录。这已经在基于Shiro的应用程序中完成，但应用程序通过应用程序收集所有必需的信息，然后与Shiro进行交互。很可能在未来的版本中会有这种支持。</li>
<li>写域操作：当前所有的域实现支持读操作来获取认证和授权数据用来执行登录和访问控制。写操作，像创建用户，组和角色或者将用户和角色组及权限关联起来都是不支持的。这是因为支持这些操作的数据模型在应用程序中有很大差异，所以在所有Shiro用户上执行“写入”API将是困难的。</li>
</ul>
<h3 id="Upcoming-Features"><a href="#Upcoming-Features" class="headerlink" title="Upcoming Features"></a>Upcoming Features</h3><p>Shiro的社区每天都很活跃，Shiro的特性也在变多。在接下来的版本中你将看到:</p>
<ul>
<li>简洁的web filter机制，允许更多的可插拔的过滤器支持，而不是通过子类。</li>
<li>更多可插拔的默认有利于组合继承的域实现。你将能够插拔查找身份验证和授权数据的组件，而不是要求你对Shiro Realm实现进行子类实现。</li>
<li>强大的OpenID和OAuth（或者都有）客户端支持</li>
<li>验证码支持</li>
<li>100％无状态应用程序（例如许多REST环境）更容易配置。</li>
<li>通过请求/响应协议进行多级认证。</li>
<li>通过AuthorizationRequest进行粗粒度授权。</li>
<li><a href="http://www.antlr.org/" target="_blank" rel="external">ANTLR</a>语法用于安全断言查询（例如（’role（admin）&amp;&amp;（guest ||！group（developer））’）</li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Apache Shiro是一个功能齐全，功能强大且通用的Java安全框架，可用于保护你的应用程序。通过简化应用安全性的四个方面，即认证，授权，会话管理和密码，应用安全性在实际应用中更容易理解和实现。Shiro的简单架构和JavaBeans兼容性允许在几乎任何环境中进行配置和使用。额外的网络支持和辅助功能，如对多线程和测试的支持，整合框架，为应用程序安全性提供可能是你的“一站式”服务。Apache Shiro的开发团队继续前进，改进代码库并支持社区。随着开源代码和商业化的采用，Shiro只会越来越强。</p>
<h3 id="About-the-Author"><a href="#About-the-Author" class="headerlink" title="About the Author"></a>About the Author</h3><p>Les Hazlewood是Shiro PMC主席，Katasoft的联合创始人兼首席技术官，专注于应用程序安全产品和对Apache Shiro的支持。Les拥有10年的Java开发和企业架构师经验，曾在Bloomberg, Delta Airlines, 和 JBoss担任过高级职务。Les一直在积极参与开源开发9年以上，为Spring Framework，Hibernate，JBoss，OpenSpaces以及Apache Shiro的前身JSecurity等项目提交或贡献过代码。Les目前住在加州圣马特奥，并且在不编程的时候练习剑道和研究日语。</p>
<p>查看英文原文： <a href="https://www.infoq.com/articles/apache-shiro" target="_blank" rel="external">Application Security With Apache Shiro</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的应用添加安全措施的时候有没有觉得很受挫？你有没有觉得Java在安全这一块的解决方案用起来很难，让你更加觉得困惑？这篇文章介绍&lt;a href=&quot;http://shiro.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apac
    
    </summary>
    
      <category term="Apache" scheme="http://www.wei-dong.top/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.wei-dong.top/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
