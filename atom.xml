<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DongWei&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mr-dongw.site/"/>
  <updated>2017-07-16T06:59:10.000Z</updated>
  <id>http://www.mr-dongw.site/</id>
  
  <author>
    <name>Mr-Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态代理番外篇</title>
    <link href="http://www.mr-dongw.site/2017/07/16/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    <id>http://www.mr-dongw.site/2017/07/16/动态代理番外篇/</id>
    <published>2017-07-16T06:55:23.000Z</published>
    <updated>2017-07-16T06:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中说到动态代理的实现除了JDK还有第三方的实现。现在就来瞧瞧JDK之外的动态代理的实现。<a id="more"></a> </p>
<h2 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h2><p>这个库在Github上有1390颗星星，下面是对Cglib的描述。</p>
<blockquote>
<p>cglib is a powerful, high performance and quality Code Generation Library, It is used to extend JAVA classes and implements interfaces at runtime. </p>
</blockquote>
<p>说到使用这个库的框架，其中大名鼎鼎的Hibernate就用到了，当然还有Spring。 Spring的AOP默认使用JDKProxy，如果被代理的类没有实现接口就使用Cglib去生成动态代理类。</p>
<p>它的出现是为了弥补JDK动态代理中不能对未实现接口的类进行代理。其原理也可想而知了，无非就是动态生成一个子类，这个子类继承了要代理的类，然后去重写父类（需要代理的类）的方法。这样的话，代理类就一定不能是final类型了，需要代理的方法也不能是final。因为Java不允许继承final类，不允许重写final方法。<br>下面通过一个实例来介绍Cglib实现动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 需要被代理的目标类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span>  </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello ,"</span>+ name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"TargetClass&#123;&#125;"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 目标对象拦截器，实现MethodInterceptor</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetIncerceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写方法拦截在方法前和方法后加入业务</div><div class="line">     * <span class="doctag">@param</span> o 为目标对象</div><div class="line">     * <span class="doctag">@param</span> method 为目标方法</div><div class="line">     * <span class="doctag">@param</span> objects 为参数</div><div class="line">     * <span class="doctag">@param</span> methodProxy CGlib方法代理对象 </div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"调用前"</span>);</div><div class="line">        Object result = methodProxy.invokeSuper(o, objects);</div><div class="line">        System.out.println(<span class="string">" 调用后"</span>+result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        enhancer.setSuperclass(TargetClass.class);</div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> TargetIncerceptor());</div><div class="line">        TargetClass targetClass = (TargetClass) enhancer.create();</div><div class="line"></div><div class="line">        String hello = targetClass.hello(<span class="string">"dw"</span>);</div><div class="line">        System.out.println(hello);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从表面上来看和JDK的使用还是有类似的地方的。Cglib使用<code>Enhancer</code>来去装载父类，将方法拦截器植入到生成的子类字节码中，最后创建对象。Cgilb依赖ASM字节码框架去动态生成字节码，具体生成出来的字节码文件和JDK动态代理生成出来的差别很大，区别就在于Cglib生成的代理类没有使用反射去调用要被代理的方法。从这里就可以看出Cglib在执行效率上要比JDK动态代理要高，毕竟反射效率是很低的。</p>
<h2 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte Buddy"></a>Byte Buddy</h2><p>这个类库是最近看一个RPC框架代码的时候发现的。起因是自己想尝试着写一个简单的远程方法调用的样例程序，在Github上找到了一个简单的基于Netty的实现，其中在处理动态代理的时候除了使用JDK的实现还有一个额外的实现，那就是Byte Buddy。然后稍微研究了一番，发现使用这个类库写动态代理确实很方便。</p>
<p>废话不多讲，先简单的看代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name)</span></span>;</div><div class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name,<span class="keyword">int</span> time)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span>+name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name, <span class="keyword">int</span> time)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> time+<span class="string">" Hello "</span>+name ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"nothing"</span>+i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuddyProxy</span> </span>&#123;</div><div class="line">	<span class="comment">//创建代理对象</span></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz,Object handler)</span></span>&#123;</div><div class="line"></div><div class="line">        Class&lt;? extends T&gt; cls = <span class="keyword">new</span> ByteBuddy()</div><div class="line">                .subclass(clazz)</div><div class="line">                .method(ElementMatchers.isDeclaredBy(clazz))</div><div class="line">                .intercept(MethodDelegation.to(handler))</div><div class="line">                .make()</div><div class="line">                .load(clazz.getClassLoader(), ClassLoadingStrategy.Default.INJECTION)</div><div class="line">                .getLoaded();</div><div class="line"></div><div class="line">        T t = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           t = cls.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ByteBuddyProxy proxy = <span class="keyword">new</span> ByteBuddyProxy();</div><div class="line">        Hello hello = proxy.getInstance(Hello.class, <span class="keyword">new</span> Invoker(HelloImpl.class));</div><div class="line">        hello.sayHi(<span class="number">1</span>);</div><div class="line">        String sayHi = hello.sayHi(<span class="string">"dongwei"</span>,<span class="number">9</span>);</div><div class="line">        System.out.println(sayHi);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//暂时理解为和JDK Proxy中的InvocationHandler一样的东西吧</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.clazz = clazz;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RuntimeType</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(@Origin Method method, @AllArguments @RuntimeType Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Object result = method.invoke(clazz.newInstance(),args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是一个很简单的小栗子，还有很多复杂的特性没有深入研究。我只能对写这个库的作者表示很崇高的敬佩！</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然除了文章中所介绍的生成动态代理的工具还有很多没有提及，比方说javaassit等。其原理大致类似，无非就是在JVM加载字节码的时候将字节码给替换了或者改掉了，很多都依赖于ASM库，如果对class字节码规范很熟悉的话自己也可以使用ASM来写一个字节码生成工具。<br>从阅读别人写的RPC框架的源码中发现了很多有意思的东西，从其中的动态代理可以了解到字节码生成加载。慢慢才发现写代码真的不是想象中那么简单的，变化的东西太多了，也只有时刻保持着学习的态度也才可能跟得上节奏，才不会被淘汰。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中说到动态代理的实现除了JDK还有第三方的实现。现在就来瞧瞧JDK之外的动态代理的实现。
    
    </summary>
    
      <category term="OPEN SOURCE" scheme="http://www.mr-dongw.site/categories/OPEN-SOURCE/"/>
    
    
      <category term="字节码工具" scheme="http://www.mr-dongw.site/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>动态代理之JDK实现</title>
    <link href="http://www.mr-dongw.site/2017/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BJDK%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.mr-dongw.site/2017/07/09/动态代理之JDK实现/</id>
    <published>2017-07-09T02:29:23.000Z</published>
    <updated>2017-07-09T02:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近呢，看到了一个开源的PRC FRAMEWORK，当然不是Dubbo。然后想去了解一下RPC到底是怎么去实现的。于是乎就了解了一番，发现其灵魂在于动态代理和反射。<a id="more"></a> </p>
<h5 id="What’s-Dynamic-Proxy"><a href="#What’s-Dynamic-Proxy" class="headerlink" title="What’s Dynamic Proxy ?"></a>What’s Dynamic Proxy ?</h5><p>在讲什么是动态代理前先得明白什么是代理。在日常生活中的代理其实就是委托的意思。将事情交代给委托对象去做，这就是代理。程序中的代理是什么意思呢？这里更准确的解释应该是一种设计模式–代理模式（Proxy)<br><img src="http://img.my.csdn.net/uploads/201211/29/1354197582_1664.PNG" alt="Proxy"><br>下面给出一个简单的关于代理的Java实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	<span class="comment">//主题接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	<span class="comment">//接口实现</span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"the original method!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代理类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	</div><div class="line">    <span class="keyword">private</span> Source source;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">super</span>();  </div><div class="line">        <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </div><div class="line">        before();  </div><div class="line">        source.method();  </div><div class="line">        atfer();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"after proxy!"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"before proxy!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用客户端</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Sourceable source = <span class="keyword">new</span> Proxy();  </div><div class="line">        source.method();  </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中代理类中对主题接口进行了增强—在主题方法调用前后调用了<code>before</code>和<code>after</code> 。Spring AOP中的思想正是如此。<br>这就是Java中的代理模式，只不过上面的代码实现是基于硬编码的，也就是所说的<strong>静态代理</strong>。那么区别于静态代理，那就一定有<strong>动态代理了</strong>。<br>通过以上的代码可以看出，静态代理将代码写死，是在编译阶段完成的具体代理类的绑定。但是动态代理不是这么做的，而是在程序运行时完成的这操作。下面使用动态代理方式实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用jdk动态代理实现需要实现接口InvocationHandler</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object targrt;<span class="comment">//代理的真实对象，也就是接口的实现类</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object targrt)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.targrt = targrt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * 该方法负责集中处理动态代理类上的所有方法调用。</div><div class="line">     * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</div><div class="line">     * <span class="doctag">@param</span> proxy 代理类实例</div><div class="line">     * <span class="doctag">@param</span> method 被调用的方法对象</div><div class="line">     * <span class="doctag">@param</span> args 调用参数</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//这里来处理代理的具体工作</span></div><div class="line">        <span class="comment">//假设在执行前进行一个打印日志的处理</span></div><div class="line">        before();</div><div class="line">        Object result = method.invoke(targrt, args);</div><div class="line">        <span class="comment">//假设执行结束后打印一个执行完成的通知</span></div><div class="line">        atfer();</div><div class="line">        <span class="comment">//将执行结果返回如果有的话</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"after proxy!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"before proxy!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class[] interfaceClass)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</div><div class="line">                                        interfaceClass,<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//客户端</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Sourceable s = <span class="keyword">new</span> Source();</div><div class="line"></div><div class="line">        JdkProxy proxy = <span class="keyword">new</span> JdkProxy(s);</div><div class="line"></div><div class="line">        Sourceable hello = (Sourceable) proxy.getProxy(<span class="keyword">new</span> Class[]&#123;Sourceable.class&#125;);</div><div class="line">        </div><div class="line">        hello.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可见，我们对主题对象所有的方法的调用都会变成对<code>invoke</code>方法的调用，而我们可以在这个方法中添加统一的逻辑处理。<br>所以可以看出，动态代理的几个好处：</p>
<ul>
<li>易于维护。相对于静态代理来说，只要在Proxy类中固定好处理逻辑而不用针对每个方法去编写代码了。控制了代码量，便于维护。</li>
<li>使AOP编程更加容易。在Spring的帮助下轻松添加、移除动态代理，且对源代码没有任何影响。</li>
<li>解耦。可以通过参数就能判断具体实现类，不需要事先实例化，更加灵活多变。<h5 id="The-Mechanism-of-Dynamic-Proxy"><a href="#The-Mechanism-of-Dynamic-Proxy" class="headerlink" title="The Mechanism of Dynamic Proxy"></a>The Mechanism of Dynamic Proxy</h5>谈完了什么是动态代理，现在就可以来了解一下动态代理是怎么实现的了。要去知道Jdk动态代理是怎么实现的还得去源码中找。<br>看看<code>Proxy#newProxyInstance</code>的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, interfaces);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 找缓存里有没有Proxy对象，没有就生成一个.</div><div class="line">         */</div><div class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Invoke its constructor with the designated invocation handler.</div><div class="line">         * 用指定的handler来调用构造方法</div><div class="line">         */</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</div><div class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span> &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123;</div><div class="line">                <span class="comment">// create proxy instance with doPrivilege as the proxy class may</span></div><div class="line">                <span class="comment">// implement non-public interfaces that requires a special permission</span></div><div class="line">                <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> newInstance(cons, ih);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> newInstance(cons, ih);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面的代码中不难看出其核心在于获取一个代理类对象。得到类对象后再通过反射去创建代理对象实例。看看<code>getProxyClass0</code>怎么实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Generate a proxy class.  Must call the checkProxyAccess method</div><div class="line">     * to perform permission checks before calling this.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</div><div class="line">                                           Class&lt;?&gt;... interfaces) &#123;</div><div class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></div><div class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></div><div class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></div><div class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>呃…好吧！这个方法是从一个cache对象中去拿Proxy类对象的。所以我们还是不知道代理类对象是怎么产生的。不过这里有一点有点意思，就是代理类实现的接口数不能超过65535个。看到这个数字是否很惊喜或者也有点意外？关于65535我特意去查了一下<a href="https://en.wikipedia.org/wiki/65535_(number" target="_blank" rel="external">Wiki</a>)。这是Java语言机制导致的。当然没有哪个变态去实现这么多个接口吧。<br>既然从cache中去找，那么看看这个cache到底是何方神圣。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * a cache of proxy classes</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</div></pre></td></tr></table></figure></p>
<p>具体到这个cache是怎么实现的就不去纠结了，因为纠结也没用（API文档中没有这个类的解释，因为这个类的修饰是package-private的而不是public）。仔细以看有一个<code>ProxyClassFactory</code>对象作为参数传给这个cache了。这下自貌似有搞头了。看看这个类的名字就很爽—代理类工厂嘛。实际上这是Proxy的一个静态内部类。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">private static final class ProxyClassFactory</div><div class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">    &#123;</div><div class="line">        // 生成代理类名称的前缀</div><div class="line">        private static final String proxyClassNamePrefix = "$Proxy";</div><div class="line"></div><div class="line">        // 用于生成代理类名字的计数器 </div><div class="line">        private static final AtomicLong nextUniqueNumber = new AtomicLong();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</div><div class="line">			//各种验证</div><div class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</div><div class="line">            for (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">                /*</div><div class="line">                 * Verify that the class loader resolves the name of this</div><div class="line">                 * interface to the same Class object.</div><div class="line">                 */</div><div class="line">                Class&lt;?&gt; interfaceClass = null;</div><div class="line">                try &#123;</div><div class="line">                    interfaceClass = Class.forName(intf.getName(), false, loader);</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                &#125;</div><div class="line">                if (interfaceClass != intf) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        intf + " is not visible from class loader");</div><div class="line">                &#125;</div><div class="line">                /*</div><div class="line">                 * Verify that the Class object actually represents an</div><div class="line">                 * interface.</div><div class="line">                 */</div><div class="line">                if (!interfaceClass.isInterface()) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        interfaceClass.getName() + " is not an interface");</div><div class="line">                &#125;</div><div class="line">                /*</div><div class="line">                 * Verify that this interface is not a duplicate.</div><div class="line">                 */</div><div class="line">                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        "repeated interface: " + interfaceClass.getName());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			//代理类的包名</div><div class="line">            String proxyPkg = null;     // package to define proxy class in</div><div class="line"></div><div class="line">            //对于不是public修饰的接口，代理类的包名和接口包名一致</div><div class="line">            for (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">                int flags = intf.getModifiers();</div><div class="line">                if (!Modifier.isPublic(flags)) &#123;</div><div class="line">                    String name = intf.getName();</div><div class="line">                    int n = name.lastIndexOf('.');</div><div class="line">                    String pkg = ((n == -1) ? "" : name.substring(0, n + 1));</div><div class="line">                    if (proxyPkg == null) &#123;</div><div class="line">                        proxyPkg = pkg;</div><div class="line">                    &#125; else if (!pkg.equals(proxyPkg)) &#123;</div><div class="line">                        throw new IllegalArgumentException(</div><div class="line">                            "non-public interfaces from different packages");</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			//public修饰的接口 包名统一为com.sun.proxy</div><div class="line">            if (proxyPkg == null) &#123;</div><div class="line">                // if no non-public proxy interfaces, use com.sun.proxy package</div><div class="line">                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /*</div><div class="line">             * Choose a name for the proxy class to generate.</div><div class="line">             */</div><div class="line">            long num = nextUniqueNumber.getAndIncrement();</div><div class="line">            // 默认情况下，代理类的完全限定名为：com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1……依次递增  </div><div class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</div><div class="line"></div><div class="line">            // 这里才是真正的生成代理类的字节码的地方  </div><div class="line">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</div><div class="line">                proxyName, interfaces);</div><div class="line">            try &#123;</div><div class="line">	            // 根据二进制字节码返回相应的Class实例  </div><div class="line">                return defineClass0(loader, proxyName,</div><div class="line">                                    proxyClassFile, 0, proxyClassFile.length);</div><div class="line">            &#125; catch (ClassFormatError e) &#123;</div><div class="line">                /*</div><div class="line">                 * A ClassFormatError here means that (barring bugs in the</div><div class="line">                 * proxy class generation code) there was some other</div><div class="line">                 * invalid aspect of the arguments supplied to the proxy</div><div class="line">                 * class creation (such as virtual machine limitations</div><div class="line">                 * exceeded).</div><div class="line">                 */</div><div class="line">                throw new IllegalArgumentException(e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>唉，感觉看了半天发现又被绕进去了。没办法，继续看看<code>ProxyGenerator</code>这个类怎么去实现的。这个是Jdk私有的，但是可以反编译查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class[] var1) &#123;</div><div class="line">        ProxyGenerator var2 = <span class="keyword">new</span> ProxyGenerator(var0, var1);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var3 = var2.generateClassFile();</div><div class="line">        <span class="comment">// 这里根据参数配置，决定是否把生成的字节码（.class文件）保存到本地磁盘，我们可以通过把相应的class文件保存到本地，再反编译来看看具体的实现，这样更直观  </span></div><div class="line">        <span class="keyword">if</span>(saveGeneratedFiles) &#123;</div><div class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        FileOutputStream var1 = <span class="keyword">new</span> FileOutputStream(ProxyGenerator.dotToSlash(var0) + <span class="string">".class"</span>);</div><div class="line">                        var1.write(var3);</div><div class="line">                        var1.close();</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var2);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> var3;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中，这个参数的定义是酱紫的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>))).booleanValue();</div></pre></td></tr></table></figure></p>
<p>所以我们可以设置sun.misc.ProxyGenerator.saveGeneratedFiles这个系统属性为true来把生成的class保存到本地文件来查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div></pre></td></tr></table></figure></p>
<p>加上这段代码后执行<code>main</code>会报这样的错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.InternalError: I/O exception saving generated file: java.io.FileNotFoundException: com/sun/proxy/$Proxy0.class (No such file or directory)</div><div class="line">	at sun.misc.ProxyGenerator$1.run(ProxyGenerator.java:336)</div><div class="line">	at sun.misc.ProxyGenerator$1.run(ProxyGenerator.java:327)</div><div class="line">	at java.security.AccessController.doPrivileged(Native Method)</div><div class="line">	at sun.misc.ProxyGenerator.generateProxyClass(ProxyGenerator.java:326)</div><div class="line">	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:671)</div><div class="line">	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:591)</div><div class="line">	at java.lang.reflect.WeakCache$Factory.get(WeakCache.java:244)</div><div class="line">	at java.lang.reflect.WeakCache.get(WeakCache.java:141)</div><div class="line">	at java.lang.reflect.Proxy.getProxyClass0(Proxy.java:454)</div><div class="line">	at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:736)</div><div class="line">	at com.dw.test.JdkProxy.getProxy(JdkProxy.java:45)</div><div class="line">	at com.dw.test.JdkProxyCase.main(JdkProxyCase.java:19)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div></pre></td></tr></table></figure></p>
<p>解决办法是在工程根路径下创建com/sun/proxy目录，并创建一个$Proxy0.class文件，才能够正常运行并保存class文件内容。<br>看看反编译后的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Hello</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</div><div class="line">        <span class="keyword">super</span>(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</div><div class="line">            <span class="keyword">throw</span> var3;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="comment">//调用父类的handler的invoke方法 实际上就是调用我们实现InvocationHandler接口的类的invoke 我们的逻辑在这里处理</span></div><div class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</div><div class="line">            <span class="keyword">throw</span> var3;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</div><div class="line">            m3 = Class.forName(<span class="string">"com.dw.service_api.Hello"</span>).getMethod(<span class="string">"sayHello"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</div><div class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>从生成出来的这个类中可以看到</p>
<ol>
<li>这个类继承自<code>Proxy</code>实现了代理接口。所以JDK动态代理只能对接口进行代理，而不能对实现类进行代理。这是Java语言不能多继承导致的。</li>
<li>构造方法的参数是<code>InvocationHandler</code>。这个参数是由我们调用<code>Proxy#newProxyInstance</code>方法传进去的。</li>
<li>重写了Object类的<code>equals</code>、<code>hashCode</code>、<code>toString</code>，它们都只是简单的调用了<code>InvocationHandler</code>的<code>invoke</code>方法，即可以对其进行特殊的操作，也就是说JDK的动态代理还可以代理上述三个方法。<br>从这里可以联想到Spring AOP的机制和这个原理其实是一样的，可能实现会比这个复杂的多。<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5></li>
<li>使用JDK实现动态代理需要实现<code>InvacationHandler</code>接口，使用<code>Proxy#newProxyInstacne</code>返回代理对象。</li>
<li>JDK动态代理的机制是通过在程序运行时动态地去生成字节码文件，然后加载到内存生成实例。</li>
<li>JDK动态代理只能对接口进行代理，不能对实现类代理。因为Java语言不支持多继承。要想对实现类进行代理可以使用Cglib来实现。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近呢，看到了一个开源的PRC FRAMEWORK，当然不是Dubbo。然后想去了解一下RPC到底是怎么去实现的。于是乎就了解了一番，发现其灵魂在于动态代理和反射。
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.mr-dongw.site/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.mr-dongw.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>自定义Spring Schema</title>
    <link href="http://www.mr-dongw.site/2017/07/01/spring%20schema/"/>
    <id>http://www.mr-dongw.site/2017/07/01/spring schema/</id>
    <published>2017-07-01T14:18:23.000Z</published>
    <updated>2017-07-01T14:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="What’s-schema"><a href="#What’s-schema" class="headerlink" title="What’s schema"></a>What’s schema</h5><p>schema中文翻译是概要、计划、图表。这里的schema指的是xml schema，也就是对xml的约束。在xml schema之前，对xml进行约束的是DTD。现在xml schema占据了主流。其中spring framework中xml配置文件就是使用的是xml schema，后缀名为xsd。<br><a id="more"></a> </p>
<h5 id="How-to-define-a-xml-schema"><a href="#How-to-define-a-xml-schema" class="headerlink" title="How to define a xml schema"></a>How to define a xml schema</h5><p>在spring framework中的applicationContext.xml文件中见到最多的就是<code>&lt;bean&gt;</code>标签。有时候想自己也整一个标签满足自己的需求（装逼or真的是需要自己实现）那就得自己去按照spring的标准去实现了，就好比JDK中的SPI机制，要按照JDK的规范去做。Spring是怎么要求的呢？<br>以maven工程为例，在resources目录下的META_INF下需要自己定义一个.xsd文件。这里我定义了一个以dongwei为名的dongwei.xsd文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">"http://www.dongwei.com/schema/dongwei"</span></span></div><div class="line">            <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></div><div class="line">            <span class="attr">xmlns:tool</span>=<span class="string">"http://www.springframework.org/schema/tool"</span></div><div class="line">            <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">            <span class="attr">targetNamespace</span>=<span class="string">"http://www.dongwei.com/schema/dongwei"</span>&gt;</div><div class="line">	<span class="comment">&lt;!-- 这里import有好几个schema 可同时去约束被约束的xml --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.w3.org/XML/1998/namespace"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/tool"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">"beans:identifiedType"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的xsd文件就定义了一个约束。接下来还需要在resources/META_INF下新建两个文件<code>spring.handlers</code>和<code>spring.schemas</code> 内容分别是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.dongwei.com/schema/dongwei=com.hnisi.springscheme.schema.DongweiNamespaceHandler</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.dongwei.com/schema/dongwei/dongwei.xsd=META-INF/dongwei.xsd</div></pre></td></tr></table></figure>
<p>handlers的内容可以是多条，表示对这个标签的处理器。schema表示的是xsd的文件位置，在url不能访问的时候（断网）程序可以去本地找schema。</p>
<h5 id="schema-handlers"><a href="#schema-handlers" class="headerlink" title="schema handlers"></a>schema handlers</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DongweiNamespaceHandler</span>  <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		registerBeanDefinitionParser(<span class="string">"user"</span>, <span class="keyword">new</span> UserBeanDefinitionParser());		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义的handler就是酱紫，需实现父类的<code>init</code>方法。他去调用了<code>registerBeanDefinitionParser</code>去注册标签。第一个参数是标签名，第二个是对这个标签的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanDefinitionParser</span> <span class="keyword">extends</span>  <span class="title">AbstractSingleBeanDefinitionParser</span>  </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</div><div class="line">		String id = element.getAttribute(<span class="string">"id"</span>);</div><div class="line">		String name = element.getAttribute(<span class="string">"name"</span>);</div><div class="line">		</div><div class="line">		builder.addPropertyValue(<span class="string">"id"</span>, id);</div><div class="line">		builder.addPropertyValue(<span class="string">"name"</span>, name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</div><div class="line">		<span class="keyword">return</span> User.class;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个解析器重写了父类的<code>doParse</code>和<code>getBeanClass</code>  其中<code>doParse</code>处理的就是xsd中定义的属性。<br>当然，也不能少了我们要定义的标签bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">	 <span class="keyword">private</span> String id;</div><div class="line">	 <span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">	 </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上这就是一个bean，和在applicationContext.xml中配置的<code>&lt;bean&gt;</code>是一个意思。这样定义标签去处理个人觉得是为了更加灵活，可以在xml文件中去配置bean的属性，想改就改。</p>
<h5 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h5><p>再来看看applicationContext.xml中怎么使用<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </div><div class="line">    xmlns:dongwei="http://www.dongwei.com/schema/dongwei"</div><div class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </div><div class="line">    http://www.dongwei.com/schema/dongwei</div><div class="line">    http://www.dongwei.com/schema/dongwei/dongwei.xsd"&gt;</div><div class="line">    </div><div class="line">    &lt;dongwei:user id="eric" name="123"/&gt;</div><div class="line">    </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>这里的dongwei是namespace。本质上来讲这就是一个bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringSchema</span> </span>&#123;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchame</span><span class="params">()</span></span>&#123;</div><div class="line">		ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</div><div class="line">		User bean = context.getBean(User.class);</div><div class="line">		System.out.println(bean);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Last-summary"><a href="#Last-summary" class="headerlink" title="Last summary"></a>Last summary</h5><p>这是我看到SOA框架的时候发现配置文件中有很多类似<code>&lt;mango:registry protocol=&quot;zookeeper&quot; address=&quot;localhost:2181&quot; connect-timeout=&quot;5000&quot; /&gt;</code>的东西，突然觉得好奇然后去了解了一下。不仅第三方框架中有这样的自定义标签，spring framework也有：<code>&lt;context:annotation-config/&gt;</code> 这和我们最常使用的<code>&lt;bean&gt;</code>长得还是有点不一样的。然后去看了看怎么去自定义一个这样的东西。这只是一个最简单的实现，实际上功能健全的实现是很复杂的。也可以想象spring framework想得还是很周到的，水也很深。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;What’s-schema&quot;&gt;&lt;a href=&quot;#What’s-schema&quot; class=&quot;headerlink&quot; title=&quot;What’s schema&quot;&gt;&lt;/a&gt;What’s schema&lt;/h5&gt;&lt;p&gt;schema中文翻译是概要、计划、图表。这里的schema指的是xml schema，也就是对xml的约束。在xml schema之前，对xml进行约束的是DTD。现在xml schema占据了主流。其中spring framework中xml配置文件就是使用的是xml schema，后缀名为xsd。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Framework" scheme="http://www.mr-dongw.site/categories/Spring-Framework/"/>
    
    
      <category term="Spring" scheme="http://www.mr-dongw.site/tags/Spring/"/>
    
      <category term="XML" scheme="http://www.mr-dongw.site/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JUC系列之BlockingQueue</title>
    <link href="http://www.mr-dongw.site/2017/07/01/juc_LinkedBlockingQueue/"/>
    <id>http://www.mr-dongw.site/2017/07/01/juc_LinkedBlockingQueue/</id>
    <published>2017-07-01T14:16:23.000Z</published>
    <updated>2017-07-01T14:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>JUC是jdk1.5之后一强大的工具包。其中对JAVA的并发做了很好的支持。仔细阅读源码你会发现很多代码的作者是<a href="https://en.wikipedia.org/wiki/Doug_Lea" target="_blank" rel="external">Doug Lea</a>。所以现在开始细细琢磨这位大神的鬼斧神工。<br><a id="more"></a> </p>
<h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个类继承了接口Queue，Queue继承了Collection接口，他们都是亲戚。亲戚关系很庞大，后台很硬。直接实现这个接口的类没多少个：</p>
<ul>
<li>ArrayBlockingQueue </li>
<li>DelayQueue</li>
<li>LinkedBlockingDeque</li>
<li>LinkedBlockingQueue</li>
<li>LinkedTransferQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4>那就拿最简单的实现开刀。顾名思义，这个Queue是基于链表的。看看源码文档是怎么去描述的：<blockquote>
<p>An optionally-bounded blocking queue based on linked nodes. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.<br>这是一个边界可选的基于链表的阻塞队列。这个队列按照先进先出的规则阻止元素。头节点在队列中的时间最长，尾节点在队列时间最短。新添加的元素会被放到尾部，取元素将在队列的头部取。基于链表的队列的吞吐量通常要比基于数组的高，但是在高并发场景下性能没有那么可观。<br>The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to Integer.MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.<br>可选的容量参数是为了防止队列数量膨胀，假设没有去指定这个参数那么将指定为int的最大值。在不超过容量的前提下节点也会在每次插入的时候动态的创建。 </p>
</blockquote>
</li>
</ul>
<p>先看看这个类的内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        E item;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * One of:</div><div class="line">         * - the real successor Node</div><div class="line">         * - this Node, meaning the successor is head.next</div><div class="line">         * - null, meaning there is no successor (this is the last node)</div><div class="line">         */</div><div class="line">        Node&lt;E&gt; next;</div><div class="line"></div><div class="line">        Node(E x) &#123; item = x; &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//省略实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个node内部类以及一个itr的实现，非常简单。在JAVA集合中经常看到内部实现Itr的，见怪不怪了。<br>接下来就开始正餐了，对几个核心方法进行梳理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        E x;</div><div class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">        <span class="comment">//count记录当前队列的元素数量</span></div><div class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">        takeLock.lockInterruptibly();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="comment">//当当前元素的数量为0的时候线程阻塞 直到接到通知队列有元素了才继续执行</span></div><div class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</div><div class="line">                notEmpty.await();</div><div class="line">            &#125;</div><div class="line">            x = dequeue();</div><div class="line">            <span class="comment">//头节点出队了 元素数量减去1 返回值为减1前的值 如果队列元素为1出队后队列没元素了c依旧为1</span></div><div class="line">            c = count.getAndDecrement();</div><div class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">	            <span class="comment">//如果队列中还有元素 那么通知阻塞的线程可以取了</span></div><div class="line">                notEmpty.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            takeLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (c == capacity)</div><div class="line">	        <span class="comment">//这个判断很有意思，想了好久。</span></div><div class="line">	        <span class="comment">//这种情况什么时候发生呢？当向队列中添加元素 队列容量有限比如说10个 我添加了20个 那么线程会阻塞掉，线程被阻塞了必须由别的线程来唤醒不能自己唤醒自己。当某个线程执行take的时候，第一次进来这个方法出队了一个元素 这时候c的值依旧是10（返回的是旧值）那么就执行这个操作了：将入队的阻塞线程唤醒 这时候剩下的10个元素可以继续往队列中送了（只能再送一个，因为满了依旧会阻塞）。原则只有一个：满了就通知。这个画面就容易想到了：我出一个你才能进一个，不存在我先出2个你再补2个进来的，必须是轮换的来，一人一下。</span></div><div class="line">            signalNotFull();</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>自己写了个小示例程序来控制出队和入队，写出来方便理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueCase</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">3</span>);</div><div class="line"></div><div class="line">        Thread put = <span class="keyword">new</span> Thread(<span class="keyword">new</span> F(queue));</div><div class="line">        put.start();</div><div class="line"></div><div class="line">        Thread take = <span class="keyword">new</span> Thread(<span class="keyword">new</span> T(queue));</div><div class="line">        take.start();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">F</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    queue.put(<span class="string">""</span>+i);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                System.out.println(<span class="string">"请输入要取出的数量："</span>);</div><div class="line">                <span class="keyword">int</span> t = scanner.nextInt();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        String take = queue.take();</div><div class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"取出了元素："</span>+take);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个小DEMO中有2个线程，分别去对阻塞队列存元素和取元素。阻塞队列容量我只给了3个，在存元素的线程中给了10个元素让它去入队，那么在存到第四个的时候这个线程就阻塞了，直到其他线程被唤醒。而出队线程呢会接受一个数，这个数代表着从队列中要出的元素数量。当输入为10 ，则队列中元素全部被打印出来了。这个过程这样描述：线程的执行是没有先后的（一般情况），因为出队线程中有接受控制台输入，会被阻塞。入队线程一定会执行到将10个元素中的3个放入队列（塞满了，容量只有3），这时候两个线程都被阻塞掉了。当控制台接受输入了，出队线程执行到<code>take</code>方法，进行出队操作，执行到<code>if (c == capacity)</code>的时候唤醒入队线程可以继续执行。也就是说每次去调用<code>take</code>方法出队的时候都会去检查队列有没有满，满了就通知被阻塞的线程可以往队列中添加元素了（也只有队列满了才会被阻塞掉）。<br>在看看入队的方法<code>put</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></div><div class="line">        <span class="comment">// holding count negative to indicate failure unless set.</span></div><div class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node(e);</div><div class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">        putLock.lockInterruptibly();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * Note that count is used in wait guard even though it is</div><div class="line">             * not protected by lock. This works because count can</div><div class="line">             * only decrease at this point (all other puts are shut</div><div class="line">             * out by lock), and we (or some other waiting put) are</div><div class="line">             * signalled if it ever changes from capacity. Similarly</div><div class="line">             * for all other uses of count in other wait guards.</div><div class="line">             */</div><div class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">                notFull.await();</div><div class="line">            &#125;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            <span class="comment">//如果入队一个元素队列还有位置的话唤醒被阻塞的线程可以往队列中添加元素了</span></div><div class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//只有第一次put的时候才会执行这段代码 队列初始化的时候没有元素 count为0 第一次执行put虽然加1了但是返回的是旧值0 这时候队列中有一个元素 通知因为队列为空的出队线程可以取元素了</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            signalNotEmpty();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中还有很多其他的出队入队方法类似<code>offer</code> <code>peek</code>等就不一一说明了，其中的原理都是一样的。只不过有些方法不是阻塞的，出队的时候队空了就返回false或者null或者抛异常，入队同理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，关于JUC中的<code>BlockingQueue</code>的一个实现 <code>LinkedBlockingQueue</code>主要内容就到此为止，其中很多JUC的东西还是很值得去深入琢磨的。比方说<code>ReentrantLock</code>。对于并发编程这一块，还有很多东西需要去学习的。我想说这里面水太深了，这个行业真的是要求无时无刻去学习！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JUC是jdk1.5之后一强大的工具包。其中对JAVA的并发做了很好的支持。仔细阅读源码你会发现很多代码的作者是&lt;a href=&quot;https://en.wikipedia.org/wiki/Doug_Lea&quot;&gt;Doug Lea&lt;/a&gt;。所以现在开始细细琢磨这位大神的鬼斧神工。&lt;br&gt;
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.mr-dongw.site/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.mr-dongw.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JUC之CyclicBarrier</title>
    <link href="http://www.mr-dongw.site/2017/07/01/juc_CyclicBarrier/"/>
    <id>http://www.mr-dongw.site/2017/07/01/juc_CyclicBarrier/</id>
    <published>2017-07-01T14:14:41.000Z</published>
    <updated>2017-07-01T14:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>从这个名字来理解这个东西叫做循环栅栏。也许这样翻译很生硬，但是具体什么意思大概可以很清楚地明白了。</p>
<blockquote>
<p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.<br><a id="more"></a><br>JDK文档的解释是这样的：CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。<br>看个DEMO先：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest1 &#123;</div><div class="line"></div><div class="line">    private static int SIZE = 5;</div><div class="line">    private static CyclicBarrier cb;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        cb = new CyclicBarrier(SIZE);</div><div class="line"></div><div class="line">        // 新建5个任务</div><div class="line">        for(int i=0; i&lt;SIZE; i++)</div><div class="line">            new InnerThread().start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class InnerThread extends Thread&#123;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;);</div><div class="line"></div><div class="line">                // 将cb的参与者数量加1</div><div class="line">                cb.await();</div><div class="line"></div><div class="line">                // cb的参与者数量等于5时，才继续往后执行</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;);</div><div class="line">            &#125; catch (BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>执行结果：<br><code>Thread-1 wait for CyclicBarrier.
Thread-2 wait for CyclicBarrier.
Thread-3 wait for CyclicBarrier.
Thread-4 wait for CyclicBarrier.
Thread-0 wait for CyclicBarrier.
Thread-0 continued.
Thread-4 continued.
Thread-2 continued.
Thread-3 continued.
Thread-1 continued.</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从这个名字来理解这个东西叫做循环栅栏。也许这样翻译很生硬，但是具体什么意思大概可以很清楚地明白了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.&lt;br&gt;
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.mr-dongw.site/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.mr-dongw.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>XMPP Server Vysper （Ⅰ）</title>
    <link href="http://www.mr-dongw.site/2017/05/20/xmpp-vysper-1-md/"/>
    <id>http://www.mr-dongw.site/2017/05/20/xmpp-vysper-1-md/</id>
    <published>2017-05-20T10:40:04.000Z</published>
    <updated>2017-05-20T10:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在嘀嗒清单里列出了许多计划。有阅读计划，有学习计划，还有其他的计划。其中阅读计划里就包括应用层协议，类似HTTP协议，MQTT，XMPP等。阅读协议最重要的目的就是理解设计者设计的初衷和思想。个人认为这些思想远远比实现的手段有趣。很崇拜那些定制协议的人，以及定制标准的那些巨头，例如Google等。<a id="more"></a>去看那些草案，RFC文档是一件很枯燥的事情，拿一个标准实现对着文档来分析可以让这个过程变得有趣的多。之前读过FTP的协议，看着看着就看不下去了。虽然没多少内容，但是要去读下去实在是索然无味。于是拿了一个标准实现去分析，FtpServer就是一个很简单的入门。现在开始去了解XMPP，于是拿了一个开源server Vysper来学习。 </p>
<h1 id="XMPP"><a href="#XMPP" class="headerlink" title="XMPP"></a>XMPP</h1><p>第一个x代表的是Extensible，m代表的是Messageing，第一个p是Presence。这个协议的前生是Jabber，具体的没有去研究。这个协议是基于XML的，也就是通过XML格式去传输数据。其实我觉得，应用层的协议无非两种传输方式，基于文本和基于二进制。本质上来说都是基于二进制：对于计算机而言所有的数据全是0101，没什么毛病。HTTP就是基于文本，普通人都能去阅读HTTP里的数据。而XMPP是基于XML，也就是基于文本。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于一个陌生的协议，又没耐心去看RFC文档（主要是看不懂英文），怎么去了解这个协议是怎么工作的呢？我的理解就是自己去抓包看内容。类比HTTP可以通过浏览器去查看请求头以及各种属性，同样的XMPP一样也可以通过抓包分析其指令及数据格式。首先去APACHE将Vysper下载下来（dist和src）然后自己本地将服务器跑起来。找几个XMPP客户端相互通信通过抓包工具来将XMPP协议的过滤出来，对每条请求和响应具体分析。ok，整个思路就是这样了。抓包工具使用wireshark很方便。客户端有很多，pc上使用spark（win），aduim（mac）；手机上使用bruno。openfire也是一个很不错的服务器，提供web管理页面，使用起来很方便。</p>
<h1 id="Vysper"><a href="#Vysper" class="headerlink" title="Vysper"></a>Vysper</h1><p>Vysper的发音和Whisper是一样的，是悄悄话的意思。在apache的vysper官方文档中它实现的标准是 RFC3920（现在的标准是RFC6120，具体可见<a href="http://wiki.jabbercn.org/RFC6120" target="_blank" rel="external">RFC6120</a>）和 RFC3921（只实现了80%）。其他的都是些拓展协议了。根据文档介绍，vysper的结构分为三部分：<a href="http://mina.apache.org/vysper-project/xml_processing.html" target="_blank" rel="external">XML Processing</a>、<a href="http://mina.apache.org/vysper-project/stanza_processing_layer.html" target="_blank" rel="external">Stanza Processing</a>和<a href="http://mina.apache.org/vysper-project/user_mgmt.html" target="_blank" rel="external">User Management</a>.<br>目前最新的版本是0.7，打开下载的源码，其对应的模块有这几个部分：dist、examples、nbxml、server和speccompliance。其中server下又有好几个模块。</p>
<h2 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h2><p>通过名字可以看出来是用来打包发布的。因为vysper是用maven管理的，这个模块将其他的模块引入进来，通过配置生成启动脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.0&lt;/version&gt;</div><div class="line">        &lt;configuration&gt;</div><div class="line">          &lt;includeConfigurationDirectoryInClasspath&gt;true&lt;/includeConfigurationDirectoryInClasspath&gt;</div><div class="line">          &lt;configurationDirectory&gt;config&lt;/configurationDirectory&gt;</div><div class="line">          &lt;target&gt;$&#123;project.build.directory&#125;/appassembler&lt;/target&gt;</div><div class="line">          &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;</div><div class="line">		  &lt;repositoryName&gt;lib&lt;/repositoryName&gt;</div><div class="line">          &lt;environmentSetupFileName&gt;setenv&lt;/environmentSetupFileName&gt;</div><div class="line">          &lt;!-- Generate bin scripts for windows and unix per default --&gt;</div><div class="line">          &lt;platforms&gt;</div><div class="line">            &lt;platform&gt;windows&lt;/platform&gt;</div><div class="line">            &lt;platform&gt;unix&lt;/platform&gt;</div><div class="line">          &lt;/platforms&gt;</div><div class="line">          &lt;programs&gt;</div><div class="line">            &lt;program&gt;</div><div class="line">              &lt;mainClass&gt;org.apache.vysper.spring.ServerMain&lt;/mainClass&gt;</div><div class="line">              &lt;!-- call it only run because appassemble will add .bat by default on windows --&gt;              </div><div class="line">              &lt;name&gt;run&lt;/name&gt;</div><div class="line">              &lt;!-- Only generate windows bat script for this application --&gt;</div><div class="line">              &lt;platforms&gt;</div><div class="line">                &lt;platform&gt;windows&lt;/platform&gt;</div><div class="line">              &lt;/platforms&gt;</div><div class="line">            &lt;/program&gt;</div><div class="line">            &lt;program&gt;</div><div class="line">              &lt;mainClass&gt;org.apache.vysper.spring.ServerMain&lt;/mainClass&gt;</div><div class="line">              &lt;name&gt;run.sh&lt;/name&gt;</div><div class="line">              &lt;!-- Only generate unix shell script for this application --&gt;</div><div class="line">              &lt;platforms&gt;</div><div class="line">             &lt;platform&gt;unix&lt;/platform&gt;</div><div class="line">              &lt;/platforms&gt;</div><div class="line">            &lt;/program&gt;</div><div class="line">          &lt;/programs&gt;</div><div class="line">        &lt;/configuration&gt;</div><div class="line">        &lt;executions&gt;</div><div class="line">          &lt;execution&gt;</div><div class="line">          &lt;id&gt;make-appassemble&lt;/id&gt;</div><div class="line">            &lt;phase&gt;package&lt;/phase&gt;</div><div class="line">            &lt;goals&gt;</div><div class="line">              &lt;goal&gt;assemble&lt;/goal&gt;</div><div class="line">            &lt;/goals&gt;</div><div class="line">          &lt;/execution&gt;</div><div class="line">        &lt;/executions&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><p>这个模块下有两个子模块：embedded-war和pubsub-client.分别是用作嵌入到web容器里和gui客户端的栗子。简言之就是将编译好的server-core拿来调用了一把而已。可以通过jetty或者tomcat启动它都是没问题的。而pubsub-client这个模块则是一个gui的程序，通过pom的配置看到了有smack的引用，具体的后续会慢慢研究。</p>
<h2 id="nbxml"><a href="#nbxml" class="headerlink" title="nbxml"></a>nbxml</h2><p>这个模块很奇怪，名字叫做nbxml。我想这个项目不是外国人写的吗，为何叫牛逼xml。真的是这样吗？并不是的。全名叫做Non-blocking XML，非阻塞的xml解析器。无非就是实现了org.xml.sax 的一些接口而已。自定义了一套解析规则。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>这个模块下有很多子模块。这也是vysper的核心模块了。</p>
<h3 id="admin-config"><a href="#admin-config" class="headerlink" title="admin-config"></a>admin-config</h3><p>这个模块是一个web应用，和openfire的web管理是一样的。其中使用到了velocity和springmvc</p>
<h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p>这个模块最重要的就是对xmpp协议的实现了。当然最重要的还是离不开mina，毕竟是mina的子项目。</p>
<h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p>这个模块也包含很多子模块，每个模块都是对xmpp拓展协议的实现，比如bosh，mcu等。我发现使用maven分模块来管理这种方式真的很聪明。</p>
<h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><p>顾名思义，这个模块是用来存储的。其中有个jcr和hbase。不禁让我想到了hadoop。没错其中真的还引入了hadoop的包。我理解的是这个模块用于文档存储的。具体是存储什么我觉得大概是用户信息，联系人等。openfire使用的是mysql数据库来管理的。具体怎么实现的后续会继续分析。</p>
<h2 id="speccompliance"><a href="#speccompliance" class="headerlink" title="speccompliance"></a>speccompliance</h2><p>这个模块很神秘，我看pom文件中只配置了一个jdk的jar包，这个jar包在1.8中是没有的。当初编译源码的时候还遇到了一点坑，将jdk换为1.7才编译通过。说什么使用了apt的api。具体的是干嘛的可见<a href="http://www.javacui.com/Theory/367.html" target="_blank" rel="external">JDK工具 APT</a>。简单理解就是可以帮我们少写代码。</p>
<h1 id="结尾语"><a href="#结尾语" class="headerlink" title="结尾语"></a>结尾语</h1><p>本文简要介绍了XMPP协议以及如何去学习和分析一个协议如何实现的。通过开源项目Vysper来学习XMPP是一个不错的途径。同时也简单地将Vysper的结构概述了一遍。接下来将会通过分析和调试源代码以及结合阅读RFC文档的方式来学习XMPP协议。<img src="http://7xsfwn.com1.z0.glb.clouddn.com/%E5%87%A4%E5%87%B0%E8%8A%B1.jpg" alt="凤凰花"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;在嘀嗒清单里列出了许多计划。有阅读计划，有学习计划，还有其他的计划。其中阅读计划里就包括应用层协议，类似HTTP协议，MQTT，XMPP等。阅读协议最重要的目的就是理解设计者设计的初衷和思想。个人认为这些思想远远比实现的手段有趣。很崇拜那些定制协议的人，以及定制标准的那些巨头，例如Google等。
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>ftpserver（Ⅳ）</title>
    <link href="http://www.mr-dongw.site/2017/04/10/ftpserver4/"/>
    <id>http://www.mr-dongw.site/2017/04/10/ftpserver4/</id>
    <published>2017-04-10T14:29:59.000Z</published>
    <updated>2017-04-10T14:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天就来谈谈FtpServer中的线程模型，准确来讲是MINA中的线程模型。之前一直关注于FtpServer的实现逻辑，却没去在意NIO底层的这些设计。<br><a id="more"></a><br>先看看我们用MINA简单实现一个server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws IOException &#123;</div><div class="line"></div><div class="line">        SocketAcceptor socketAcceptor = new NioSocketAcceptor();</div><div class="line"></div><div class="line">        //加上一个编码过滤器，不然客户端输入的什么服务端看到的都是buf</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new MyCodecFactory()));</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;log&quot;, new LoggingFilter());</div><div class="line"></div><div class="line">        socketAcceptor.setHandler(new MyHandler());</div><div class="line"></div><div class="line">        socketAcceptor.bind(new InetSocketAddress(&quot;localhost&quot;,9090));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中只加入了log过滤器和编码过滤器，实际上什么都不加也是可以完成启动服务器监听的。然后启动服务器我们用telnet命令去连接它，多用几个命令窗口去连接，在控制台上可以看到这样的  </p>
<blockquote>
<p>[NioProcessor-2][FTP]21:31:35,053 INFO [LoggingFilter.log]:186 - CREATED<br>created<br>[NioProcessor-2][FTP]21:31:35,058 INFO [LoggingFilter.log]:186 - OPENED</p>
</blockquote>
<p>这里我们设置了日志的格式，将最前面的置为当前线程的名称。我们再启动一个客户端去连接：</p>
<blockquote>
<p>[NioProcessor-3][FTP]21:33:14,655 DEBUG [ProtocolCodecFilter.messageReceived]:211 - Processing a MESSAGE_RECEIVED for session 2<br>[NioProcessor-3][FTP]21:33:14,657 INFO [LoggingFilter.log]:157 - RECEIVED: dada  </p>
</blockquote>
<p>很明显可以看到NioProcessor变了。如此往复，不断去启动命令行客户端去连，会发现NioProcessor后的编号只会从1到5。也许你会觉得奇怪，难道用于处理连接的线程数只有5个吗？没错，如果不对其进行设置默认就是这么多个：cpu核数加1个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/** The default pool size, when no size is provided. */</div><div class="line">private static final int DEFAULT_SIZE = Runtime.getRuntime().availableProcessors() + 1;</div></pre></td></tr></table></figure></p>
<p>这就可以聊到MINA中的线程模型了。它用于处理IO用NioProcessor来，处理handler用其他的线程来。到底怎么去用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws IOException &#123;</div><div class="line"></div><div class="line">        SocketAcceptor socketAcceptor = new NioSocketAcceptor();</div><div class="line"></div><div class="line">        //加上一个编码过滤器，不然客户端输入的什么服务端看到的都是buf</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new MyCodecFactory()));</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;log&quot;, new LoggingFilter());</div><div class="line">        //添加Executor过滤器，让其线程池处理业务逻辑</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;threadPool&quot;, new ExecutorFilter(Executors.newCachedThreadPool()));</div><div class="line"></div><div class="line">        socketAcceptor.setHandler(new MyHandler());</div><div class="line"></div><div class="line">        socketAcceptor.bind(new InetSocketAddress(&quot;localhost&quot;,9090));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这时候再启动telnet客户端去访问服务器，控制台下打印的就是这样了：</p>
<blockquote>
<p>[pool-3-thread-1][FTP]21:51:41,436 DEBUG [IoFilterEvent.fire]:117 - Event MESSAGE_RECEIVED has been fired for session 1</p>
</blockquote>
<p>因此验证了业务逻辑的处理线程不再又那可怜巴巴的只有5个处理IO连接的来分担了，而是由额外的线程来处理，至于这些线程是否和处理IO线程来自同一个线程池我没有仔细去研究。同时，这里还有一个线程值得关注：NioSocketAcceptor-1（使用jvisualvm可以看到所有线程）这个用于监听所有连接事件，只有一个。其中涉及到了什么selector模型什么的就不继续深入了。事件到达后将其封装成IoSession丢给IoProcessor处理，然后继续站岗监听，啥子都不管了，就做这一件事情。<br>这让我不禁想到一个问题，NIo模型中没有对每个连接开辟线程去处理，只用一个线程去响应连接事件，后续的都交给其他线程去处理，那么如果连接的数量很多，岂不是也需要很多线程去处理这些请求了？优势又在哪里呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天就来谈谈FtpServer中的线程模型，准确来讲是MINA中的线程模型。之前一直关注于FtpServer的实现逻辑，却没去在意NIO底层的这些设计。&lt;br&gt;
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>牢骚一篇</title>
    <link href="http://www.mr-dongw.site/2017/04/09/%E7%89%A2%E9%AA%9A%E4%B8%80%E7%AF%87/"/>
    <id>http://www.mr-dongw.site/2017/04/09/牢骚一篇/</id>
    <published>2017-04-09T03:56:18.000Z</published>
    <updated>2017-04-09T03:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>生活不仅有眼前的苟且，还有诗和远。</p>
</blockquote>
<p>在以前看到这句话的时候，觉得写得真好，给人一种特积极向上的正能量。<a id="more"></a>现在看来无非就是一种自我欺骗。或许改为“生活不仅有眼前的苟且，还有明天和后天的苟且”会更加贴近我现在的生活状态。<br>最近陷入了一种焦虑状态，每天都很担心害怕，但是也不知道具体是在担心害怕什么。具体表现就是周末担心周一，平时担心下班要加班，每天都战战兢兢的，只期望早点过完这一天。周末又担心下周一要忙的事。真是非常难受，负能量满满。<br>具体说来我觉得还是对现状不是很满意，渴望改变！<br>其实脑袋里就是一片混浊，自己到底想要什么都没搞明白，对周围的人和事真的是一点都不关心，我觉得我活在自己的封闭的世界里，找不到出路。最直观的感受就是对很多事情都没有什么兴趣了，以前还想着怎么出去走走，去旅行，去别的地方看看。现在完全没有这样的想法。以前还会想着怎么去遇见那些有趣的人，怎么和他们做朋友，现在觉得自己一个人安安静静呆着挺好的。也不愿意去主动联系一些人了，也不会主动去分享自己的生活了，每天都是天昏地暗的稀里糊涂的在过着操蛋的日子。不知道还要过多久我才会被这种生活给麻痹，然后失去知觉变成一只如同行尸走肉的僵尸一般苟活于世。<br>我觉得我依旧没变，至少内心的想法没有变，我每天都在想着改变，摆脱现在的羁绊，努力去最求自己内心所想的东西，努力去成为最想成为的人，一步一步走下去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;生活不仅有眼前的苟且，还有诗和远。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以前看到这句话的时候，觉得写得真好，给人一种特积极向上的正能量。
    
    </summary>
    
      <category term="想法" scheme="http://www.mr-dongw.site/categories/%E6%83%B3%E6%B3%95/"/>
    
    
      <category term="生活，扯淡" scheme="http://www.mr-dongw.site/tags/%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title>ftpserver(Ⅲ)</title>
    <link href="http://www.mr-dongw.site/2017/04/04/ftpserver3/"/>
    <id>http://www.mr-dongw.site/2017/04/04/ftpserver3/</id>
    <published>2017-04-04T03:09:41.000Z</published>
    <updated>2017-04-04T03:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章来解读ftpserver中的核心组件–FtpServerContext<br>在很多类中都有看到这个东西，顾名思义就是上下文。根据以往的在java web中的servlet context的理解，字面意思就是上下文。<a id="more"></a>我觉得这个翻译不是很好，通过字面意思真的很难去理解这个“上下文”是什么。反而久而久之懂其中的含义了，却难以用语言描述出来。所以说翻译不准确很害人啊。最简单粗暴的方法就是去看文档注释，拒绝二手解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * This is basically &lt;code&gt;org.apache.ftpserver.ftplet.FtpletContext&lt;/code&gt; with</div><div class="line"> * added connection manager, message resource functionalities.</div><div class="line"> *</div><div class="line"> */</div><div class="line">public interface FtpServerContext extends FtpletContext &#123;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * </div><div class="line"> * FTP server configuration implementation. It holds all the components used.</div><div class="line"> */</div><div class="line">public class DefaultFtpServerContext implements FtpServerContext &#123;</div></pre></td></tr></table></figure>
<p>看了文档的注释就很容易去读懂这个”context”是什么玩意儿了。无非就是一些配置而已。“上下文”也可以解释为“运行环境”吧。我个人理解是这个程序在跑的过程中的所需要的材料。类比servlet中，通过上下文可以拿到request、response对象。那也就可以说req、resp是属于servlet运行的材料。<br>FtpServerContext是一个接口，默认实现类是DefaultFtpServerContext：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class DefaultFtpServerContext implements FtpServerContext &#123;</div><div class="line"></div><div class="line">    private final Logger LOG = LoggerFactory</div><div class="line">            .getLogger(DefaultFtpServerContext.class);</div><div class="line"></div><div class="line">    private MessageResource messageResource = new MessageResourceFactory().createMessageResource();</div><div class="line"></div><div class="line">    private UserManager userManager = new PropertiesUserManagerFactory().createUserManager();</div><div class="line"></div><div class="line">    private FileSystemFactory fileSystemManager = new NativeFileSystemFactory();</div><div class="line"></div><div class="line">    private FtpletContainer ftpletContainer = new DefaultFtpletContainer();</div><div class="line"></div><div class="line">    private FtpStatistics statistics = new DefaultFtpStatistics();</div><div class="line"></div><div class="line">    private CommandFactory commandFactory = new CommandFactoryFactory().createCommandFactory();</div><div class="line"></div><div class="line">    private ConnectionConfig connectionConfig = new ConnectionConfigFactory().createConnectionConfig();</div><div class="line"></div><div class="line">    private Map&lt;String, Listener&gt; listeners = new HashMap&lt;String, Listener&gt;();</div><div class="line"></div><div class="line">    private static final List&lt;Authority&gt; ADMIN_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div><div class="line">    private static final List&lt;Authority&gt; ANON_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * The thread pool executor to be used by the server using this context</div><div class="line">     */</div><div class="line">    private ThreadPoolExecutor threadPoolExecutor = null;</div><div class="line">    </div><div class="line">    static &#123;</div><div class="line">        ADMIN_AUTHORITIES.add(new WritePermission());</div><div class="line">        </div><div class="line">        ANON_AUTHORITIES.add(new ConcurrentLoginPermission(20, 2));</div><div class="line">        ANON_AUTHORITIES.add(new TransferRatePermission(4800, 4800));</div><div class="line">    &#125;</div><div class="line">    //...省略...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类中包含了有很多成员变量，有消息资源的MessageResource，这个主要是用于读取ftpserver中配置的资源，类似于ftp响应502对应的文字描述这样的。并没有将这些东西硬编码，而是抽象成资源，通过文本文件去配置。UserManager用于对用户的管理，比方说哪些用户有访问的权限等。FileSystemFactory是管理文件的，不同用户的权限可能是不同的，看到的目录也有可能是不同的。FtpletContainer这个说不清楚，暂时别去管这个，后面再说。FtpStatistics这个类主要是记录各种数据，比如当前连接数，登录用户数等。CommandFactory这个很容易说了，命令工厂，上篇文章中说到根据客户端指令不同创建各种命令实例来分别处理。ConnectionConfig用于对socket的连接管理。<br>除了这些还有一个map和2个list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private Map&lt;String, Listener&gt; listeners = new HashMap&lt;String, Listener&gt;();</div><div class="line">private static final List&lt;Authority&gt; ADMIN_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div><div class="line">private static final List&lt;Authority&gt; ANON_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div></pre></td></tr></table></figure></p>
<p>listeners在context初始化的时候放进去一个default的listener，也就是NioListener的实例。只是通过工厂方式去创建的。而其他2个list则是用来装admin的权限和anon的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line">        ADMIN_AUTHORITIES.add(new WritePermission());</div><div class="line">        </div><div class="line">        ANON_AUTHORITIES.add(new ConcurrentLoginPermission(20, 2));</div><div class="line">        ANON_AUTHORITIES.add(new TransferRatePermission(4800, 4800));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在类装载的时候就将权限加进去了，admin有写权限，anon有并发登录权限，其中还对anon进行了一个传输速率的配置。<br>至此，这个“神秘”的context就基本上梳理完了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇文章来解读ftpserver中的核心组件–FtpServerContext&lt;br&gt;在很多类中都有看到这个东西，顾名思义就是上下文。根据以往的在java web中的servlet context的理解，字面意思就是上下文。
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>FtpServer(Ⅱ)</title>
    <link href="http://www.mr-dongw.site/2017/03/26/ftpserver2-md/"/>
    <id>http://www.mr-dongw.site/2017/03/26/ftpserver2-md/</id>
    <published>2017-03-26T08:27:41.000Z</published>
    <updated>2017-03-26T08:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>有了之前的总体小窥后，现在开始细细把玩其中的深邃之处了。<br>其中可以看到有不少的factory，比如FtpServerFactory、ListenerFactory等。通过名字可以看得出来，这些都是用来产生实例的工厂。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public Listener createListener() &#123;</div><div class="line">        try &#123;</div><div class="line">            InetAddress.getByName(serverAddress);</div><div class="line">        &#125; catch (UnknownHostException e) &#123;</div><div class="line">            throw new FtpServerConfigurationException(&quot;Unknown host&quot;, e);</div><div class="line">        &#125;</div><div class="line">        // Deal with the old style black list and new session Filter here.</div><div class="line">        if (sessionFilter != null) &#123;</div><div class="line">            if (blockedAddresses != null || blockedSubnets != null) &#123;</div><div class="line">                throw new IllegalStateException(</div><div class="line">                        &quot;Usage of SessionFilter in combination with blockedAddesses/subnets is not supported. &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (blockedAddresses != null || blockedSubnets != null) &#123;</div><div class="line">            return new NioListener(serverAddress, port, implicitSsl, ssl,</div><div class="line">                    dataConnectionConfig, idleTimeout, blockedAddresses,</div><div class="line">                    blockedSubnets);</div><div class="line">        &#125; else &#123;</div><div class="line">            return new NioListener(serverAddress, port, implicitSsl, ssl,</div><div class="line">                    dataConnectionConfig, idleTimeout, sessionFilter);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个listenerfactory通过createListener创建listener。同理serverFactory也是一样。<br>先看看listener工场有哪些成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private String serverAddress;</div><div class="line">    //端口默认是21，本地部署会有权限冲突</div><div class="line">    private int port = 21;</div><div class="line">    //加密配置，暂时不管</div><div class="line">    private SslConfiguration ssl;</div><div class="line"></div><div class="line">    private boolean implicitSsl = false;</div><div class="line"></div><div class="line">    private DataConnectionConfiguration dataConnectionConfig = new DataConnectionConfigurationFactory()</div><div class="line">            .createDataConnectionConfiguration();</div><div class="line"></div><div class="line">    private int idleTimeout = 300;</div><div class="line">    //黑名单</div><div class="line">    private List&lt;InetAddress&gt; blockedAddresses;</div><div class="line">    private List&lt;Subnet&gt; blockedSubnets;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * The Session filter</div><div class="line">     * 过滤器</div><div class="line">     */</div><div class="line">    private SessionFilter sessionFilter = null;</div></pre></td></tr></table></figure></p>
<p>最重要的还是哪个createListener方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">return new NioListener(serverAddress, port, implicitSsl, ssl,</div><div class="line">                    dataConnectionConfig, idleTimeout, sessionFilter);</div></pre></td></tr></table></figure></p>
<p>最后返回的是一个NioListener。这个工厂只创建Niolistener。<br>具体到NioListener就涉及到MINA了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class NioListener extends AbstractListener</div></pre></td></tr></table></figure></p>
<p>这里有个重要的接口就是Listener，AbstractListener实现了这个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void start(FtpServerContext serverContext);</div><div class="line">void stop();</div><div class="line">boolean isStopped();</div><div class="line">void suspend();</div><div class="line">void resume();</div><div class="line">boolean isSuspended();</div><div class="line">Set&lt;FtpIoSession&gt; getActiveSessions();</div><div class="line">boolean isImplicitSsl();</div><div class="line">SslConfiguration getSslConfiguration();</div><div class="line">int getPort();</div><div class="line">String getServerAddress();</div><div class="line">DataConnectionConfiguration getDataConnectionConfiguration();</div><div class="line">int getIdleTimeout();</div><div class="line">@Deprecated</div><div class="line">List&lt;InetAddress&gt; getBlockedAddresses();</div><div class="line"></div><div class="line">@Deprecated</div><div class="line">List&lt;Subnet&gt; getBlockedSubnets();</div><div class="line"></div><div class="line"></div><div class="line">SessionFilter getSessionFilter();</div></pre></td></tr></table></figure></p>
<p>无非就是定义了一些关于服务器监听状态的控制。<br>再看看Niolistenre中的核心方法start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public synchronized void start(FtpServerContext context) &#123;</div><div class="line">        if(!isStopped()) &#123;</div><div class="line">            // listener already started, don&apos;t allow</div><div class="line">            throw new IllegalStateException(&quot;Listener already started&quot;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        try &#123;</div><div class="line">            </div><div class="line">            this.context = context;</div><div class="line"></div><div class="line">            //创建一个acceptor，用来监听连接</div><div class="line">            acceptor = new NioSocketAcceptor(Runtime.getRuntime()</div><div class="line">                    .availableProcessors());</div><div class="line">    </div><div class="line">            if (getServerAddress() != null) &#123;</div><div class="line">                address = new InetSocketAddress(getServerAddress(), getPort());</div><div class="line">            &#125; else &#123;</div><div class="line">                address = new InetSocketAddress(getPort());</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            acceptor.setReuseAddress(true);</div><div class="line">            acceptor.getSessionConfig().setReadBufferSize(2048);</div><div class="line">            acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE,</div><div class="line">                    getIdleTimeout());</div><div class="line">            // Decrease the default receiver buffer size</div><div class="line">            acceptor.getSessionConfig().setReceiveBufferSize(512);</div><div class="line">    </div><div class="line">            MdcInjectionFilter mdcFilter = new MdcInjectionFilter();</div><div class="line"></div><div class="line">            //添加一系列过滤器链</div><div class="line">            acceptor.getFilterChain().addLast(&quot;mdcFilter&quot;, mdcFilter);</div><div class="line"></div><div class="line">            SessionFilter sessionFilter = getSessionFilter();</div><div class="line">            if (sessionFilter != null) &#123;</div><div class="line">                // add and IP filter to the filter chain.</div><div class="line">                acceptor.getFilterChain().addLast(&quot;sessionFilter&quot;,</div><div class="line">                        new MinaSessionFilter(sessionFilter));</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            acceptor.getFilterChain().addLast(&quot;threadPool&quot;,</div><div class="line">                    new ExecutorFilter(context.getThreadPoolExecutor()));</div><div class="line">            acceptor.getFilterChain().addLast(&quot;codec&quot;,</div><div class="line">                    new ProtocolCodecFilter(new FtpServerProtocolCodecFactory()));</div><div class="line">            acceptor.getFilterChain().addLast(&quot;mdcFilter2&quot;, mdcFilter);</div><div class="line">            acceptor.getFilterChain().addLast(&quot;logger&quot;, new FtpLoggingFilter());</div><div class="line"></div><div class="line">            //对ssl的支持</div><div class="line">            if (isImplicitSsl()) &#123;</div><div class="line">                SslConfiguration ssl = getSslConfiguration();</div><div class="line">                SslFilter sslFilter;</div><div class="line">                try &#123;</div><div class="line">                    sslFilter = new SslFilter(ssl.getSSLContext());</div><div class="line">                &#125; catch (GeneralSecurityException e) &#123;</div><div class="line">                    throw new FtpServerConfigurationException(&quot;SSL could not be initialized, check configuration&quot;);</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                if (ssl.getClientAuth() == ClientAuth.NEED) &#123;</div><div class="line">                    sslFilter.setNeedClientAuth(true);</div><div class="line">                &#125; else if (ssl.getClientAuth() == ClientAuth.WANT) &#123;</div><div class="line">                    sslFilter.setWantClientAuth(true);</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                if (ssl.getEnabledCipherSuites() != null) &#123;</div><div class="line">                    sslFilter.setEnabledCipherSuites(ssl.getEnabledCipherSuites());</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                acceptor.getFilterChain().addFirst(&quot;sslFilter&quot;, sslFilter);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //这里才是正真的核心了，用于处理消息事件</div><div class="line">            handler.init(context, this);</div><div class="line">            acceptor.setHandler(new FtpHandlerAdapter(context, handler));</div><div class="line">    </div><div class="line">            try &#123;</div><div class="line">                //绑定地址端口，然后就开始监听事件了</div><div class="line">                acceptor.bind(address);</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                throw new FtpServerConfigurationException(&quot;Failed to bind to address &quot; + address + &quot;, check configuration&quot;, e);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            updatePort();</div><div class="line">    </div><div class="line">        &#125; catch(RuntimeException e) &#123;</div><div class="line">            // clean up if we fail to start</div><div class="line">            stop();</div><div class="line">            </div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中使用到的MINA的类NioSocketAcceptor用于创建一个socket监听，说白了就是启动服务器。除了比较关键的filter之外就属handler了。<br>看看其中的一个codec过滤器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class FtpServerProtocolCodecFactory implements ProtocolCodecFactory &#123;</div><div class="line">    private final ProtocolDecoder decoder = new TextLineDecoder(Charset</div><div class="line">            .forName(&quot;UTF-8&quot;));</div><div class="line"></div><div class="line">    private final ProtocolEncoder encoder = new FtpResponseEncoder();</div><div class="line"></div><div class="line">    public ProtocolDecoder getDecoder(IoSession session) throws Exception &#123;</div><div class="line">        return decoder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ProtocolEncoder getEncoder(IoSession session) throws Exception &#123;</div><div class="line">        return encoder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>decode是解码，encode是编码。所谓解码就是服务器相对客户端来说，客户输入的东西我们来解析，相反我们服务器传给客户端的就叫编码了。可以看到，解码使用的是MINA默认的文本解码器，ftp客户端输入的也只是一些文本命令罢了。我们服务端的编码则自己定义了一个FtpResponseEncoder：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class FtpResponseEncoder extends ProtocolEncoderAdapter &#123;</div><div class="line">    private static final CharsetEncoder ENCODER = Charset.forName(&quot;UTF-8&quot;)</div><div class="line">            .newEncoder();</div><div class="line"></div><div class="line">    public void encode(IoSession session, Object message,</div><div class="line">            ProtocolEncoderOutput out) throws Exception &#123;</div><div class="line">        String value = message.toString();</div><div class="line"></div><div class="line">        IoBuffer buf = IoBuffer.allocate(value.length()).setAutoExpand(true);</div><div class="line"></div><div class="line">        buf.putString(value, ENCODER);</div><div class="line"></div><div class="line">        buf.flip();</div><div class="line">        out.write(buf);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我个人觉得这个实现和MINA中的TextLineEncoder实现区别不是很大，为什么要自己定义一个这样的实现？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception &#123;</div><div class="line">        CharsetEncoder encoder = (CharsetEncoder) session.getAttribute(ENCODER);</div><div class="line"></div><div class="line">        if (encoder == null) &#123;</div><div class="line">            encoder = charset.newEncoder();</div><div class="line">            session.setAttribute(ENCODER, encoder);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String value = (message == null ? &quot;&quot; : message.toString());</div><div class="line">        IoBuffer buf = IoBuffer.allocate(value.length()).setAutoExpand(true);</div><div class="line">        buf.putString(value, encoder);</div><div class="line"></div><div class="line">        if (buf.position() &gt; maxLineLength) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Line length: &quot; + buf.position());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buf.putString(delimiter.getValue(), encoder);</div><div class="line">        buf.flip();</div><div class="line">        out.write(buf);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>别的filter就不一一细说了。接下来看看真正核心的handler–FtpHandler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public interface FtpHandler &#123;</div><div class="line"></div><div class="line">    void init(FtpServerContext context, Listener listener);</div><div class="line"></div><div class="line">    </div><div class="line">    void sessionCreated(FtpIoSession session) throws Exception;</div><div class="line"></div><div class="line">    </div><div class="line">    void sessionOpened(FtpIoSession session) throws Exception;</div><div class="line"></div><div class="line">    </div><div class="line">    void sessionClosed(FtpIoSession session) throws Exception;</div><div class="line"></div><div class="line">    void sessionIdle(FtpIoSession session, IdleStatus status) throws Exception;</div><div class="line"></div><div class="line">    void exceptionCaught(FtpIoSession session, Throwable cause)</div><div class="line">            throws Exception;</div><div class="line"></div><div class="line">    void messageReceived(FtpIoSession session, FtpRequest request)</div><div class="line">            throws Exception;</div><div class="line"></div><div class="line">    void messageSent(FtpIoSession session, FtpReply reply) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个接口，定义了很多看似和MINA中的IoHandler中的很多接口是一模一样的，只是参数不同，一个是IoSession 一个是FtpIoSession，本质上FtpIoSession也是实现了IoSession接口的，可以说是一样的。<br>然而，acceptor的setHandler接受的参数是</p>
<blockquote>
<p>setHandler(org.apache.mina.core.service.IoHandler handler)  </p>
</blockquote>
<p>MINA中的IoHandler，这里我们自己定义的一个Handler是不可以放进去的。于是用了一个adapter来转接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public class FtpHandlerAdapter extends IoHandlerAdapter &#123;</div><div class="line">    private final FtpServerContext context;</div><div class="line"></div><div class="line">    private FtpHandler ftpHandler;</div><div class="line"></div><div class="line">    public FtpHandlerAdapter(FtpServerContext context, FtpHandler ftpHandler) &#123;</div><div class="line">        this.context = context;</div><div class="line">        this.ftpHandler = ftpHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void exceptionCaught(IoSession session, Throwable cause)</div><div class="line">            throws Exception &#123;</div><div class="line">        //发生异常，这里将Iosession重新包装了一下，叫做ftpIoSession，实际上就是实现了IoSession而已</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">//        然后这个ftpHandler就对包装后的session进行处理，下同</div><div class="line">        ftpHandler.exceptionCaught(ftpSession, cause);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void messageReceived(IoSession session, Object message)</div><div class="line">            throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //将客户端发送的命令抽象成FtpRequest，将message传进去包装成request对象</div><div class="line">        FtpRequest request = new DefaultFtpRequest(message.toString());</div><div class="line">        //处理接受消息事件</div><div class="line">        ftpHandler.messageReceived(ftpSession, request);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void messageSent(IoSession session, Object message) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //处理消息发送事件</div><div class="line">        ftpHandler.messageSent(ftpSession, (FtpReply) message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionClosed(IoSession session) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //session关闭时</div><div class="line">        ftpHandler.sessionClosed(ftpSession);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionCreated(IoSession session) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        MdcInjectionFilter.setProperty(session, &quot;session&quot;, ftpSession.getSessionId().toString());</div><div class="line">        //session创建时，先与创建再有打开</div><div class="line">        ftpHandler.sessionCreated(ftpSession);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionIdle(IoSession session, IdleStatus status)</div><div class="line">            throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //session空闲</div><div class="line">        ftpHandler.sessionIdle(ftpSession, status);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionOpened(IoSession session) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //session打开，也就是连接打开的时候</div><div class="line">        ftpHandler.sessionOpened(ftpSession);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public FtpHandler getFtpHandler() &#123;</div><div class="line">        return ftpHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setFtpHandler(FtpHandler handler) &#123;</div><div class="line">        this.ftpHandler = handler;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正真处理session的依旧是我们定义的DefaultFtpHandler。这样设计的意义何在？？我觉得是不要过度依赖于MINA的api吧。或者为了装逼。<br>接下来看看处理session的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void messageReceived(IoSession session, Object message)</div><div class="line">        throws Exception &#123;</div><div class="line">    FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">    //将客户端发送的命令抽象成FtpRequest，将message传进去包装成request对象</div><div class="line">    FtpRequest request = new DefaultFtpRequest(message.toString());</div><div class="line">    //处理接受消息事件</div><div class="line">    ftpHandler.messageReceived(ftpSession, request);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public void messageReceived(final FtpIoSession session,</div><div class="line">        final FtpRequest request) throws Exception &#123;</div><div class="line">    try &#123;</div><div class="line">        session.updateLastAccessTime();</div><div class="line">        //将客户端输入命令封装成command对象</div><div class="line">        String commandName = request.getCommand();</div><div class="line">        //这个factory很有意思，是通过factory来创建的</div><div class="line">        //private CommandFactory commandFactory = new CommandFactoryFactory().createCommandFactory();</div><div class="line">        CommandFactory commandFactory = context.getCommandFactory();</div><div class="line">        //这里获得的command根据命令不同获取的cmd对象不同</div><div class="line">        Command command = commandFactory.getCommand(commandName);</div><div class="line"></div><div class="line">        // make sure the user is authenticated before he issues commands</div><div class="line">        if (!session.isLoggedIn()</div><div class="line">                &amp;&amp; !isCommandOkWithoutAuthentication(commandName)) &#123;</div><div class="line">            session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">                    context, FtpReply.REPLY_530_NOT_LOGGED_IN,</div><div class="line">                    &quot;permission&quot;, null));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        FtpletContainer ftplets = context.getFtpletContainer();</div><div class="line"></div><div class="line">        FtpletResult ftpletRet;</div><div class="line">        try &#123;</div><div class="line">            ftpletRet = ftplets.beforeCommand(session.getFtpletSession(),</div><div class="line">                    request);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            LOG.debug(&quot;Ftplet container threw exception&quot;, e);</div><div class="line">            ftpletRet = FtpletResult.DISCONNECT;</div><div class="line">        &#125;</div><div class="line">        if (ftpletRet == FtpletResult.DISCONNECT) &#123;</div><div class="line">            LOG.debug(&quot;Ftplet returned DISCONNECT, session will be closed&quot;);</div><div class="line">            session.close(false).awaitUninterruptibly(10000);</div><div class="line">            return;</div><div class="line">        &#125; else if (ftpletRet != FtpletResult.SKIP) &#123;</div><div class="line"></div><div class="line">            if (command != null) &#123;</div><div class="line">                synchronized (session) &#123;</div><div class="line">                    command.execute(session, context, request);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">                        context,</div><div class="line">                        FtpReply.REPLY_502_COMMAND_NOT_IMPLEMENTED,</div><div class="line">                        &quot;not.implemented&quot;, null));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                ftpletRet = ftplets.afterCommand(</div><div class="line">                        session.getFtpletSession(), request, session</div><div class="line">                                .getLastReply());</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                LOG.debug(&quot;Ftplet container threw exception&quot;, e);</div><div class="line">                ftpletRet = FtpletResult.DISCONNECT;</div><div class="line">            &#125;</div><div class="line">            if (ftpletRet == FtpletResult.DISCONNECT) &#123;</div><div class="line">                LOG.debug(&quot;Ftplet returned DISCONNECT, session will be closed&quot;);</div><div class="line"></div><div class="line">                session.close(false).awaitUninterruptibly(10000);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; catch (Exception ex) &#123;</div><div class="line"></div><div class="line">        // send error reply</div><div class="line">        try &#123;</div><div class="line">            session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">                    context, FtpReply.REPLY_550_REQUESTED_ACTION_NOT_TAKEN,</div><div class="line">                    null, null));</div><div class="line">        &#125; catch (Exception ex1) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ex instanceof java.io.IOException) &#123;</div><div class="line">            throw (IOException) ex;</div><div class="line">        &#125; else &#123;</div><div class="line">            LOG.warn(&quot;RequestHandler.service()&quot;, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的一些ftp命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line">        // first populate the default command list</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;ABOR&quot;, new ABOR());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;ACCT&quot;, new ACCT());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;APPE&quot;, new APPE());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;AUTH&quot;, new AUTH());</div><div class="line">        /*省略部分*/</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;STOR&quot;, new STOR());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;STOU&quot;, new STOU());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;STRU&quot;, new STRU());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;SYST&quot;, new SYST());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;TYPE&quot;, new TYPE());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;USER&quot;, new USER());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>再看看主要的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (command != null) &#123;</div><div class="line">    synchronized (session) &#123;</div><div class="line">        command.execute(session, context, request);</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">            context,</div><div class="line">            FtpReply.REPLY_502_COMMAND_NOT_IMPLEMENTED,</div><div class="line">            &quot;not.implemented&quot;, null));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将每一个session作为一个锁，保证每个连接的同步操作。具体的execute做了一些什么操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void execute(FtpIoSession session, FtpServerContext context,</div><div class="line">            FtpRequest request) throws IOException, FtpException;</div></pre></td></tr></table></figure></p>
<p>这是一个接口，具体的操作是由这个command是什么决定的。我们挑一个最简单的实现PWD：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class PWD extends AbstractCommand &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Execute command</div><div class="line">     */</div><div class="line">    public void execute(final FtpIoSession session,</div><div class="line">            final FtpServerContext context, final FtpRequest request)</div><div class="line">            throws IOException, FtpException &#123;</div><div class="line">        session.resetState();</div><div class="line">        FileSystemView fsview = session.getFileSystemView();</div><div class="line">        String currDir = fsview.getWorkingDirectory().getAbsolutePath();</div><div class="line">        session.write(LocalizedFtpReply.translate(session, request, context,</div><div class="line">                FtpReply.REPLY_257_PATHNAME_CREATED, &quot;PWD&quot;, currDir));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个命令用来显示当前目录。很容易理解。<br>至此，整个ftp的启动流程都全部梳理完毕，从服务器启动到接受客户端命令，其中的逻辑实际上一点都不复杂。整个服务启动到与客户端交互IoSession都穿插其中，对mina的依赖也不是很明显，当然这是作者刻意将耦合降到最低，这种设计思想值得学习借鉴。<br>接下来就具体探讨各个模块的实现细节。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有了之前的总体小窥后，现在开始细细把玩其中的深邃之处了。&lt;br&gt;其中可以看到有不少的factory，比如FtpServerFactory、ListenerFactory等。通过名字可以看得出来，这些都是用来产生实例的工厂。&lt;br&gt;
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.mr-dongw.site/2017/01/08/hello-world/"/>
    <id>http://www.mr-dongw.site/2017/01/08/hello-world/</id>
    <published>2017-01-08T13:53:01.000Z</published>
    <updated>2017-01-08T13:53:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
