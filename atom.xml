<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DongWei&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mr-dongw.site/"/>
  <updated>2017-09-25T12:09:26.000Z</updated>
  <id>http://www.mr-dongw.site/</id>
  
  <author>
    <name>Mr-Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Authorization Guide with Apache Shiro[译]</title>
    <link href="http://www.mr-dongw.site/2017/09/25/Java%20Authorization%20Guide%20with%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.mr-dongw.site/2017/09/25/Java Authorization Guide with Apache Shiro[译]/</id>
    <published>2017-09-25T12:05:23.000Z</published>
    <updated>2017-09-25T12:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>授权或者说访问控制指的是为资源分配访问权限。换句话说就是谁能干什么。</p>
<p>举个授权的栗子：用户允许看网页、改数据、看按钮或者打印吗？这些都能决定用户能不能做什么。<br><a id="more"></a></p>
<h3 id="Elements-of-Authorization"><a href="#Elements-of-Authorization" class="headerlink" title="Elements of Authorization"></a>Elements of Authorization</h3><p>授权有三个我们在Shiro中使用很多的核心元素–权限、角色和用户。</p>
<h3 id="Permissions-Defined"><a href="#Permissions-Defined" class="headerlink" title="Permissions Defined"></a>Permissions Defined</h3><p>权限是安全策略的最原子级别，它们是功能语句。权限就是在你的应用中能做什么。权限描述了资源类型以及当你与这些资源进行交互时可能采取的操作。你能开门吗？你能读取文件吗？你能删除客户记录吗？你能按按钮吗？</p>
<p>数据相关资源的常见操作是创建，读取，更新和删除，通常称为CRUD。</p>
<p>重要的是要明白，权限不是谁能执行的操作 - 它们只是可以执行哪些操作的语句。</p>
<h4 id="Levels-of-permission-granularity"><a href="#Levels-of-permission-granularity" class="headerlink" title="Levels of permission granularity"></a>Levels of permission granularity</h4><p>以上权限都指定资源（门，文件，客户记录等）上的操作（打开，读取，删除等）。在Shiro，您可以定义任何您喜欢的粒度的权限。以下是粒度顺序的几个常见权限级别。</p>
<ul>
<li>资源级别 - 这最广泛最简单构建。 用户可以编辑客户记录或打开门。 资源被指定，但不是该资源的特定实例。</li>
<li>实例级别 - 权限可以指定资源的实例。 用户可以编辑IBM的客户记录或打开厨房门。</li>
<li>属性级别 - 权限现在可以指定实例或资源的属性。 用户可以编辑IBM客户记录上的地址。</li>
</ul>
<p>获取更多信息:<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external">Permissions Documentation</a></p>
<h3 id="Roles-Defined"><a href="#Roles-Defined" class="headerlink" title="Roles Defined"></a>Roles Defined</h3><p>在授权的上下文中，角色实际上是用于简化权限和用户管理的权限集合。因此，用户可以分配角色，而不是直接分配权限，这可能会使较大的用户基础和更复杂的应用程序变得复杂。因此，例如，银行应用程序可能具有管理员角色或银行出纳员角色。</p>
<p>有2中类型的角色你需要知道，Shiro同时也支持。</p>
<h4 id="Implicit-Roles（隐式的角色）"><a href="#Implicit-Roles（隐式的角色）" class="headerlink" title="Implicit Roles（隐式的角色）"></a>Implicit Roles（隐式的角色）</h4><p>代码中的角色检查通常是隐含角色的反映。你可以查看患者数据，因为你具有管理员角色。你可以创建一个帐户，因为你有银行出纳员角色。事实上这些名字的存在和软件具体能做的没有任何关系。大多数人以这种方式使用角色。这是最简单的，但它可以为所有但最简单的应用程序造成大量的维护和管理问题。</p>
<h4 id="Explicit-Roles（显式的角色）"><a href="#Explicit-Roles（显式的角色）" class="headerlink" title="Explicit Roles（显式的角色）"></a>Explicit Roles（显式的角色）</h4><p>显式角色具有明确分配给它的权限，因此是明确的权限集合。代码中的权限检查反映了明确的角色。你可以查看患者的数据，因为你将患者数据视图视为管理员角色的一部分。你可以创建一个帐户，因为你有创建帐户权限作为你的银行柜员角色的一部分。你可以执行这些操作，而不是因为基于字符串的一些隐式角色名称，而是因为相应权限被明确分配给你的角色。</p>
<p>明确角色的最大好处是易于管理，降低了应用程序的维护。如果你需要添加，删除或更改角色，则可以在不触摸源代码的情况下执行此操作。在Shiro中，你还可以在运行时动态添加，删除或更改角色，并且你的授权检查将始终具有最新值。这意味着你不必强制用户注销并重新登录以获取他们的新权限。</p>
<h3 id="Users-Defined"><a href="#Users-Defined" class="headerlink" title="Users Defined"></a>Users Defined</h3><p>用户就是谁在用这个应用程序。然而，在Shiro，用户的概念实际上是Subject实例。我们使用Subject这个词而不是用户，因为用户通常意味着人类，而在Shiro中，Subject可以与你的应用程序进行任何交互 - 无论是人类还是服务。</p>
<p>用户就是允许在你的应用程序中通过角色或者权限的关联执行某些动作。因此你可以打开一个客户的记录，因为你已经被分配了打开客户记录的权限，或者你被分配了带有权限的角色。</p>
<h3 id="How-to-perform-Authorization-in-Java-with-Shiro"><a href="#How-to-perform-Authorization-in-Java-with-Shiro" class="headerlink" title="How to perform Authorization in Java with Shiro"></a>How to perform Authorization in Java with Shiro</h3><p>在Shiro中授权有四种：</p>
<ul>
<li>以编程方式 - 你可以在java代码中执行授权检查，其结构如if和else。</li>
<li>JDK注解 - 你可以将授权注解附加到Java方法。</li>
<li>JSP / GSP TagLibs  - 你可以根据角色和权限来控制jsp或gsp页面输出</li>
</ul>
<h4 id="Programmatic-Authorization"><a href="#Programmatic-Authorization" class="headerlink" title="Programmatic Authorization"></a>Programmatic Authorization</h4><p>检查角色和权限，在你的代码中使用编程方式是一种传统方式来处理授权。</p>
<h5 id="Role-Check"><a href="#Role-Check" class="headerlink" title="Role Check"></a>Role Check</h5><p>这是一个使用编程方式来检查角色的栗子。我们想检查用户是否具有管理员角色，如果有，那么我们将显示一个特殊的按钮，否则我们不会显示它。</p>
<p>首先我们得到当前用户，也就是Subject。然后我们将admin传给Subject的<code>hasRole()</code>方法。它会返回<code>TRUE</code>或者 <code>FALSE</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get the current Subject </span></div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (currentUser.hasRole(<span class="string">"administrator"</span>)) &#123;</div><div class="line">    <span class="comment">//show a special button‏</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?)‏</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，基于角色的检查是快速和容易实现的，但它具有主要的缺点。 这是隐式的。</p>
<p>如果你只想稍后添加，删除或重新定义角色怎么办？你必须打开源代码，并更改所有角色检查以反映你的安全模型的变化。你必须关闭应用程序，破解代码，测试它，然后重新启动它。</p>
<p>在非常简单的应用程序中，这可能足够好，但对于较大的应用程序，这可能是应用程序的整个生命周期中的主要问题，并为你的软件带来大量维护成本。</p>
<h5 id="Permission-Check"><a href="#Permission-Check" class="headerlink" title="Permission Check"></a>Permission Check</h5><p>这是你如何通过权限进行安全检查的示例。我们想检查用户是否有权打印到laserjet3000n，如果是这样，那么我们将显示打印按钮，否则我们不会显示。这是一个实例级权限或实例级授权的示例。</p>
<p>再次，首先你可以访问当前的用户，Subject。然后构造一个Permission对象或者实例来表示一个动作或者资源。在这个栗子中这个实例可以命名为printPermission,资源是laserjet3000n，动作是打印。然后我们将printPermission传给Subject的<code>.isPermitted()</code>方法。它返回true或者false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">Permission printPermission = <span class="keyword">new</span> PrinterPermission(<span class="string">"laserjet3000n"</span>,<span class="string">"print"</span>);</div><div class="line"></div><div class="line">If (currentUser.isPermitted(printPermission)) &#123;</div><div class="line">    <span class="comment">//do one thing (show the print button?)‏</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Permission-Check-String-based"><a href="#Permission-Check-String-based" class="headerlink" title="Permission Check (String-based)"></a>Permission Check (String-based)</h5><p>你也可以用一个简单的字符串而不是permission类做权限检查。</p>
<p>因此，如果你不想实现我们permission 接口，你仅仅传一个string字符串就行了。在这个栗子中，我们传<code>.isPermitted()</code>一个字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String perm = <span class="string">"printer:print:laserjet4400n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(currentUser.isPermitted(perm))&#123;</div><div class="line">    <span class="comment">//show the print button?</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要你的域知道如何使用它，你可以按照你想要的方式构建权限字符串。在这个栗子中，我们使用Shiro的可选的权限语法，<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external"> WildCardPermissions</a>.WildCardPermissions功能强大直观。</p>
<p>通过使用基于字符串的权限检查，你可以获得的功能和之前的栗子是一样的。好处是你不必强制实现权限接口，你可以通过简单的字符串构造权限。缺点是你没有类型安全，如果你需要更复杂的许可权限，这些权限超出了这个处理的范围。接下来讲如何基于Permission接口实现权限对象。</p>
<h4 id="Annotation-Authorization"><a href="#Annotation-Authorization" class="headerlink" title="Annotation Authorization"></a>Annotation Authorization</h4><p>如果你不想在代码层做权限控制，你也可以使用Java注解。Shiro提供很多注解可以让你放在方法上面。</p>
<h5 id="Enabling-Annotation-Support"><a href="#Enabling-Annotation-Support" class="headerlink" title="Enabling Annotation Support"></a>Enabling Annotation Support</h5><p>在你使用Java注解之前，你需要在你的应用中开启AOP支持。有很多不同的AOP框架，因此不幸的是，在应用中没有一个标准的方式开启AOP。</p>
<p>对AspectJ而言，看栗子<a href="https://github.com/apache/shiro/tree/master/samples/aspectj" target="_blank" rel="external">AspectJ sample application</a></p>
<p>对Spring而言，看栗子<a href="http://shiro.apache.org/spring.html" target="_blank" rel="external"> Spring Integration </a></p>
<p>对Guice而言，看栗子<a href="http://shiro.apache.org/guice.html" target="_blank" rel="external"> Guice Integration</a></p>
<h5 id="Permission-Check-1"><a href="#Permission-Check-1" class="headerlink" title="Permission Check"></a>Permission Check</h5><p>在这个栗子中，我们想检查一个用户在调用<code>openAccount</code>方法之前是否有<code>account:create</code>权限。如果有，按照期望的调用，如果没得，那就抛异常。</p>
<p>和通过编程方式检查权限一样，你可以使用Permission对象或者简单的字符串方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Will throw an AuthorizationException if none</span></div><div class="line"><span class="comment">//of the caller’s roles imply the Account</span></div><div class="line"><span class="comment">//'create' permission</span></div><div class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"account:create"</span>)‏</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openAccount</span><span class="params">( Account acct )</span> </span>&#123;</div><div class="line">    <span class="comment">//create the account</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Role-Check-1"><a href="#Role-Check-1" class="headerlink" title="Role Check"></a>Role Check</h5><p>在这个栗子中，我们想检查一个用户在执行<code>openAccount</code>方法前是否有<code>teller</code>角色。如果有就按照期望的走下去，没有就抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Throws an AuthorizationException if the caller</span></div><div class="line"><span class="comment">//doesn’t have the ‘teller’ role:</span></div><div class="line"><span class="meta">@RequiresRoles</span>( <span class="string">"teller"</span> )</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openAccount</span><span class="params">( Account acct )</span> </span>&#123;</div><div class="line">    <span class="comment">//do something in here that only a teller</span></div><div class="line">    <span class="comment">//should do</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="JSP-TagLib-Authorization"><a href="#JSP-TagLib-Authorization" class="headerlink" title="JSP TagLib Authorization"></a>JSP TagLib Authorization</h4><p>对于基于JSP / GSP的Web应用程序，Shiro还提供了一个标签库供您使用。</p>
<p>在此示例中，我们将向用户显示user:manage权限,一个指向“管理用户”页面的链接。如果他们没有权限，那么我们会给他们一个友好的消息提示。</p>
<p>首先，我们需要将Shiro taglib添加到我们的Web应用程序中。接着我们为user:manage权限添加<shiro:haspermission>标签。在<shiro：haspermission>标签中，如果用户具有我们正在检查的权限，我们就放置要执行的代码。如果我们要执行一个动作假如这个用户缺少权限，我们需要添加<shiro:lackspermission> 标签，再次检查users:manage权限。如果用户缺少权限，我们想要执行的任何代码都需要放在<shiro：lackspermission>标签中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">http://shiro.apache.org/tags</span> %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"users:manage"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"manageUsers.jsp"</span>&gt;</span></div><div class="line">            Click here to manage users</div><div class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"users:manage"</span>&gt;</span></div><div class="line">        No user management for you!</div><div class="line">    <span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></shiro：lackspermission></shiro:lackspermission></shiro：haspermission></shiro:haspermission></p>
<p>当然，还有用于检查角色和其他用户数据和状态的标签。</p>
<p>有关JSP / GSP标签的更多信息，请查看JSP标签库，以及有关将应用程序集成到Web应用程序中的更多信息，请阅读<a href="http://shiro.apache.org/web.html" target="_blank" rel="external">Web集成文档</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;授权或者说访问控制指的是为资源分配访问权限。换句话说就是谁能干什么。&lt;/p&gt;
&lt;p&gt;举个授权的栗子：用户允许看网页、改数据、看按钮或者打印吗？这些都能决定用户能不能做什么。&lt;br&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.mr-dongw.site/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.mr-dongw.site/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Application Security With Apache Shiro[译]</title>
    <link href="http://www.mr-dongw.site/2017/09/21/Application%20Security%20With%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.mr-dongw.site/2017/09/21/Application Security With Apache Shiro[译]/</id>
    <published>2017-09-21T04:41:23.000Z</published>
    <updated>2017-09-21T04:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的应用添加安全措施的时候有没有觉得很受挫？你有没有觉得Java在安全这一块的解决方案用起来很难，让你更加觉得困惑？这篇文章介绍<a href="http://shiro.apache.org/" target="_blank" rel="external">Apache Shiro</a>,一个简单又强大为你应用提供安全的Java框架。本文对Apache Shiro的愿景、架构设计及怎样去使用Shiro来保护你的应用进行解释。</p>
<h3 id="Apache-Shiro是什么？"><a href="#Apache-Shiro是什么？" class="headerlink" title="Apache Shiro是什么？"></a>Apache Shiro是什么？</h3><p>Apache Shiro（发音为“歇肉”，在日本的发音是城堡的意思）是一个强大又好用的Java安全框架，它提供认证、授权、加密和会话管理，它可以被用在保护任何应用–从命令行应用、移动应用到大型的web企业级应用。</p>
<p>Shiro为以下几个方面提供应用安全的API。</p>
<ul>
<li>认证-证明用户身份，通常叫做登录</li>
<li>授权-访问控制</li>
<li>加密-保护或隐藏数据不被窥视</li>
<li>会话管理-每个用户的状态是对时间敏感的</li>
</ul>
<p>Shiro还提供辅助的特性，比如说web安全，单元测试，和多线程的支持。这些都是为了加强上面提到的几个特性。</p>
<h3 id="Apache-Shiro为什么被发明？"><a href="#Apache-Shiro为什么被发明？" class="headerlink" title="Apache Shiro为什么被发明？"></a>Apache Shiro为什么被发明？</h3><p>对于一个框架而言，它存在的意义就是它满足你的需求而找不到其他的替代方案。为了理解这些东西，我们有必要翻一番Shiro的历史以及当时的替代品。</p>
<p>在2008年加入ASF之前，Shiro都5岁了，而且和早在2003年开始的JSecurity一样有名了。在2003年，没有太多为Java开发者提供可选的安全方案。我们坚持使用Java认证和Java授权服务，称作JAAS。然而JASS有很多缺点当然认证能力是可以接受的，授权方面让人用起来觉得很崩溃。JAAS和JVM级别的安全密切相关，比方说决定一个class该不该被加载到JVM。作为一个应用开发者，我更关心的是应用程序用户能做什么，而不是我的代码在JVM里能做什么。</p>
<p>由于我当时着手的工作，我需要一个干净的和容器无关的会话机制。当时在游戏（我猜作者的工作就是写游戏）中唯一的选择就是HttpSession，这个玩意需要一个web容器或者EJB容器。我需要的是能够从容器中解耦，而且在任何环境下都好用的。</p>
<p>最后有一个密码的问题。有很多情况下我们需要加密数据，但是Java加密架构除了密码专家外普通人很难理解。它的API到处都是异常检查，用起来感觉很笨重。我迫切希望一个干净的开箱即用的可以满足我的需求的解决方案。</p>
<p>看了一下在2003年早期的安全概况，你能很快的意识到没有一款单一的框架能够满足这些需求。正因为如此，JSecurity还有后来的Shiro诞生了。</p>
<h3 id="如今你为何用Apache-Shiro"><a href="#如今你为何用Apache-Shiro" class="headerlink" title="如今你为何用Apache Shiro?"></a>如今你为何用Apache Shiro?</h3><p>自2003年来，框架的格局发生了很大的变化，因此现在有一个让人信服的理由来使用Shiro。理由如下：</p>
<ul>
<li>好用–好用是一个项目最关键的目标。应用安全可能是非常让人沮丧和困惑，因此被称作“必要的罪恶”。假如你让它变得新手程序员都容易使用，那就不那么痛苦了。</li>
<li>全面–没有比Shiro更广泛的安全框架了，因此它可以一站式满足你对安全的需要。</li>
<li>灵活–Shiro能在任何环境下工作。虽然它在web、EJB、和ioC容器中工作，但是它不依赖他们。Shiro没有太多的规定，也没有太多的依赖。</li>
<li>支持web–Shiro对web应用有全面的支持，你可以创建基于web协议和url的灵活的安全策略，同时提供一套控制页面输出的JSP库。</li>
<li>可插拔–Shiro干净的API（干净可以翻译为简洁）和设计思想可以让你很容易地集成到其他框架和应用。你可以看到Shiro和Spring、Grails等框架无缝集成。</li>
<li>支持–Shiro是ASF的一部分。这个项目的开发和用户群会友好的提供帮助。如果需要，像<a href="https://stormpath.com/" target="_blank" rel="external">Katasoft</a>商业公司也会提供专业的支持和服务。</li>
</ul>
<h3 id="谁在用Shiro？"><a href="#谁在用Shiro？" class="headerlink" title="谁在用Shiro？"></a>谁在用Shiro？</h3><p>Shiro和它的先驱JSecurity在很多行业很多公司的项目中用了很多年。在成为ASF顶级项目之后，它的网站流量和使用率大增。也有许多开源的组织使用Shiro，比方说Spring, Grails, Wicket, Tapestry, Tynamo, Mule, 和 Vaadin。</p>
<p>商业公司像Katasoft、Sonatype、MuleSoft等也使用Shiro来保护他们的商业软件和网站。</p>
<h3 id="核心概念：主体，安全管理器，域"><a href="#核心概念：主体，安全管理器，域" class="headerlink" title="核心概念：主体，安全管理器，域"></a>核心概念：主体，安全管理器，域</h3><p>目前我们讲了Shiro的优点，我们直接来看看它的API，让你直接感受它。Shiro的架构有3个核心的概念–主体、安全管理器和域。</p>
<h4 id="Subject-主体"><a href="#Subject-主体" class="headerlink" title="Subject(主体)"></a>Subject(主体)</h4><p>当你要对你的应用进行保护的时候，你最大的可能要问的问题就是“当前用户是谁？”或者“当前用户允许做这件事吗？”，我们问自己这些问题是很正常的，就像我们在写代码或者设计接口一样。应用程序通常是基于用户故事来构建，而且你想基于每个用户来构建你的功能。因此，你考虑在你应用安全最常规的思路就是基于当前用户。Shiro API中的主体概念基本上体现了这种思路。</p>
<p>主体是安全术语中的一个名词，代表的是当前执行的用户。不能仅仅只称作“用户”因为“用户”这个词通常和人类关联起来。在安全领域，主体这个词可以代表一个人，也可以代表第三方进程、一个后台账号或者类似的东西。简单来讲，就是和当前软件交互的东西。然而对于大多数目的和用途，你可以把它当做Shiro用户的概念。你能很容易地在你的代码中获取Shiro的主体，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import org.apache.shiro.subject.Subject;</div><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">...</div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div></pre></td></tr></table></figure></p>
<p>一旦你获取了主体，你就能使用Shiro为当前用户拿到90%的访问权限，比如登录，退出登录，获取session，执行权限检查等。这里关键点是Shiro的API大体上是很直观的，从中可以体现开发者在针对每个用户的安全控制中的思路（这句话实在是不知道怎么翻译）。在代码中任何地方获取主体很容易，在需要进行安全操作的地方进行控制也很容易。</p>
<h4 id="SecurityManager-安全管理器"><a href="#SecurityManager-安全管理器" class="headerlink" title="SecurityManager(安全管理器)"></a>SecurityManager(安全管理器)</h4><p>在主体背后后与之配对的是安全管理器。主体提供当前用户的安全操作，然而安全管理器为所有用户管理着安全操作。这是Shiro架构的核心，有类似于很多“伞”的作用。这些伞内部引用了很多嵌套的安全组件而形成一个伞图（翻译很晦涩，意思就是很多组件组合而成）。然而，一旦安全管理器及内部的“伞图”配置好了，应用开发者几乎将所有时间都花在了主体API上，通常这个安全管理器是独立的。</p>
<p>在每一个应用中总有一个安全管理器实例。本质上是一个单例应用（虽然不必是静态单例）。像Shiro中其他东西一样，默认的安全管理器的实现是POJO，可以通过任何与POJO兼容的配置机制–普通的Java代码、Spring XML、YAML、.properties和ini文件等等。通常来讲，能够被实例化的类和能够调用JavaBean兼容方法的都可以使用。</p>
<p>为此，Shiro借助基于文本的INI配置提供了一个缺省的“公共”解决方案。INI读起来很容易，用起来很简单，而且依赖的东西也很少。你可以看到，通过简单了解对象图导航，INI可以很高效的配置简单的对象图,像SecurityManager。注意Shiro也支持Spring XML配置合其他替代品。我们这里只谈INI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">cm = org.apache.shiro.authc.credential.HashedCredentialsMatcher</div><div class="line">cm.hashAlgorithm = SHA-512</div><div class="line">cm.hashIterations = 1024</div><div class="line">#Base64 encoding (less text):</div><div class="line">cm.storedCredentialsHexEncoded = false</div><div class="line">iniRealm.credentialsMatcher = $cm</div><div class="line">[users]</div><div class="line">jdoe = TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJpcyByZWFzb2</div><div class="line">asmith = IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbXNoZWQsIG5vdCB</div></pre></td></tr></table></figure></p>
<p>在上面的INI配置例子中，我们看到配置SecurityManager 实例。在INI配置中有2个部分：[main]和[users].</p>
<p>[main]部分用于配置SecurityManager对象或者被SecurityManager 使用的任何对象。在这个例子中，我们看到了两个对象被配置：</p>
<ol>
<li>cm对象，Shiro中的HashedCredentialsMatcher 类的一个实例。你能看到，很多cm的属性通过嵌套的点的语法被配置。清单3所示的IniSecurityManagerFactory使用的约定来表示对象图形导航和属性设置。</li>
<li>iniRealm对象，它是SecurityManager用于表示以INI格式定义的用户帐户的组件。</li>
</ol>
<p>在[users]这部分中你可以指定一个静态的用户列表，对于简单的应用是很方便来测试的。</p>
<p>介绍这些的目的不是去理解每个部分的复杂性，而是INI配置方式是一种简单的Shiro配置。更多关于INI配置的细节，详情可以参考<a href="http://shiro.apache.org/documentation.html" target="_blank" rel="external">Shiro文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</div><div class="line">import org.apache.shiro.mgt.SecurityManager;</div><div class="line">import org.apache.shiro.util.Factory;</div><div class="line">...</div><div class="line">//1. Load the INI configuration</div><div class="line">Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</div><div class="line">//2. Create the SecurityManager SecurityManager securityManager = factory.getInstance();</div><div class="line">//3. Make it accessible</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，我们有3个步骤：</p>
<ol>
<li>加载配置SecurityManager及其组件的INI配置文件。</li>
<li>基于这个配置创建SecurityManager实例(使用Shiro的工厂概念)。</li>
<li>把SecurityManager变成单例。在这个例子中，我们将它设置成VM静态单例，但是这不是必须的。你的应用配置机制可以决定你要不要使用静态内存(这段翻译真的一点都不容易理解)。</li>
</ol>
<h4 id="Realms-域"><a href="#Realms-域" class="headerlink" title="Realms(域)"></a>Realms(域)</h4><p>Shiro中第三个核心概念就是域。域在你的应用数据和Shiro中承担一个桥梁或者说是连接器的角色。也就是说，当和安全相关的数据交互，比方说认证（登录）和授权（访问控制）时，Shiro从为应用配置的一个或者多个域配置中去找这些东西。</p>
<p>在某种意义上，一个域本质上就是一个安全的DAO：它为数据源封装了连接细节以及在需要的时候让Shiro能够访问关联的数据。当在配置Shiro的时候，你必须指定至少一个域用来做认证或者授权。可以配置多个，但至少要有一个。</p>
<p>Shiro提供开箱即用的域来连接各种安全的数据源，比方说LDAP、数据库相关的（JDBC）、文本文件配置类似INI文件和properties配置文件等。如果默认的域不能满足你的需求，你也可以将你自己实现的域插入到其中。下面通过INI配置Shiro的例子就是用LDAP来作为应用的一个域实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">ldapRealm = org.apache.shiro.realm.ldap.JndiLdapRealm</div><div class="line">ldapRealm.userDnTemplate = uid=&#123;0&#125;,ou=users,dc=mycompany,dc=com</div><div class="line">ldapRealm.contextFactory.url = ldap://ldapHost:389</div><div class="line">ldapRealm.contextFactory.authenticationMechanism = DIGEST-MD5</div></pre></td></tr></table></figure></p>
<p>现在我们知道了怎么配置一个基础的Shiro环境，我们接下来一起讨论作为一个开发者你改怎么使用这个框架。</p>
<h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>认证是验证用户的唯一性的过程。就是说，当用户使用应用进行认证的时候，他们在证明他们确实是他们所说的那个人。通常有时候我们把它称作登录。典型的三个步骤：</p>
<ol>
<li>收集用户身份信息，也叫作principals，并支持身份证明，称为credentials。</li>
<li>提交principals和credentials到系统。</li>
<li>如果提交的credentials和系统期望该用户身份匹配，这个用户就可以认为认证通过。如果不匹配，那就是认证不通过。</li>
</ol>
<p>每个人都熟悉的最常见的例子就是用户名和密码的组合。当用户登录到系统，他们通常提供他的用户名（principal）和密码（credential）。如果存储在系统中的 密码和用户提供的一致，他就被认证成功。</p>
<p>Shiro以简单直观的方式支持类似的流程。正如我们说的，Shiro有一套以主体为中心的API–几乎所有在运行时你和Shiro关心的都是通过与当前执行的主体交互实现的。因此，要登录一个主体，你只需要调用它的登录方法，传一个带有principals 和credentials的AuthenticationToken实例。下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//1. Acquire submitted principals and credentials:</div><div class="line"> AuthenticationToken token = new UsernamePasswordToken(username,password);</div><div class="line">//2. Get the current Subject:</div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"> //3. Login:</div><div class="line"> currentUser.login(token);</div></pre></td></tr></table></figure></p>
<p>如你所见，Shiro的APi很简单的表示了这个流程。你可以将这种对所有主体操作的简单性作为一种特色。当登录方法被调用，SecurityManager将接收AuthenticationToken然后将其分发到一个或者多个配置好的域中用来做认证。每个域都有能力根据需要对提交的AuthenticationToken进行处理。但是假如登录失败了会发生什么呢？假如用户的密码输错了呢？你可以通过运行时的AuthenticationException 来处理这些失败，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//3. Login:</div><div class="line">try &#123;</div><div class="line">    currentUser.login(token);</div><div class="line">&#125; catch (IncorrectCredentialsException ice) &#123; …</div><div class="line">&#125; catch (LockedAccountException lae) &#123; …</div><div class="line">&#125;</div><div class="line">…</div><div class="line">catch (AuthenticationException ae) &#123;…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以选择捕获AuthenticationException的一个子类来进行具体的处理，或者统一处理任何AuthenticationException（比如说，通常显示“用户名或者密码错误”消息）。这是根据你应用的需求来选择的。</p>
<p>一个主体登录成功后，他们被认为认证通过，通常你允许他们使用你的应用。但是，由于用户仅证明了自己的身份不代表他们在应用中能做任何他们想做的事情。这就提出了下一个问题：“我如何控制用户被允许做什么？”决定用户允许做什么叫做授权。接下来我们讨论Shiro怎么启用授权。</p>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>授权是基本的访问控制–控制你的用户在你的应用中可以访问什么，比方说资源、web页面等等。大多数用户通过使用角色和权限等概念来执行访问控制。就是说，一个用户通常允许做什么事或者不允许做什么事是基于他们分配的角色或者权限的。然后，你的应用程序可以根据对这些角色和权限的检查来控制显示哪些功能。正如你期望的，主体API允许你非常容易的执行权限和角色检查。代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.hasRole(“administrator”) ) &#123;</div><div class="line">    //show the ‘Create User’ button</div><div class="line">&#125; else &#123;</div><div class="line">    //grey-out the button?</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，你的应用可以基于访问控制开启或者关闭功能。</p>
<p>权限检查是另一种执行授权的方式。在上面的例子中检查权限有一个很大的缺陷：你不能再运行的时候添加或者删除角色。你的代码是和角色名字硬编码进去的，因此假如你改变了角色名或者配置，你的代码将会爆炸！假如你需要可以在运行时改变角色的含义，或者根据需要添加删除角色，那么你就必须依靠别的东西了。</p>
<p>为此，Shiro支持权限的概念。权限是原始功能的说明，举个栗子，‘开门’、‘创建博客实体’、‘删除xx用户’等等。有权限代表你有应用的原始功能，当你更改应用程序的功能时，你只需要更改权限检查。反过来，在运行时必要的时候你可以分配权限到角色或者用户。下面的代码使用权限检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.isPermitted(“user:create”) ) &#123;</div><div class="line">    //show the ‘Create User’ button</div><div class="line">&#125; else &#123;</div><div class="line">    //grey-out the button?</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，任何分配了“user：create”权限的角色或用户可以单击“创建用户”按钮,而且这些角色和分配甚至可以在运行时更改，给你提供了一种非常灵活的安全模型。</p>
<p>“user：create”字符串是遵守某些解析约定的权限字符串的示例。Shiro通过其WildcardPermission支持这个开箱即用的约定。虽然超出本导言文章的范围，你将看到WildcardPermission在创建安全策略时可以非常灵活，甚至支持诸如实例级访问控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.isPermitted(“user:delete:jsmith”) ) &#123;</div><div class="line">    //delete the ‘jsmith’ user</div><div class="line">&#125; else &#123;</div><div class="line">    //don’t delete ‘jsmith’</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子展示了你能控制，甚至可以细化到更细粒度的级别，如果有需要可以访问单个资源。如果你想的话你也可以发明自己的权限语法。参考<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external">Shiro Permission</a>获取更多详情。最后，就像身份验证一样，上面的调用最终也进入了SecurityManager，SecurityManager将会查询一个或多个域，以作出访问控制决定。这允许领域根据需要对认证和授权操作进行响应。</p>
<p>到此就是一个队Shiro授权功能的一个简要概述。很多安全框架在认证和授权面前停了下来，而Shiro不止于此。接下来我们要讨论Shiro的高级会话管理功能。</p>
<h4 id="Session-Management"><a href="#Session-Management" class="headerlink" title="Session Management"></a>Session Management</h4><p>Shiro提供安全框架里独一无二的：可用于任何应用和任何结构层一致的会话API。也就是说，Shiro为任何应用程序启用了会话编程范例–从小的后台应用到大型集群web应用。这意味着希望使用会话的应用程序开发人员不再强制使用Servlet或EJB容器。或者，如果使用这些容器，开发人员现在可以选择在任何层中使用统一和一致的会话API，而不是使用servlet或EJB特定的机制。</p>
<p>但是或许一个最重要的好处是Shiro会话是独立于容器的。这具有微妙但非常强大的含义。例如我们考虑会话集群。有多少以指定容器的方式来集群会话以进行容错和故障转移？Tomcat和Jetty做的不一样，和Websphere也不一样。但是使用Shiro session，你可以获得一个容器无关的集群解决方案。Shiro的架构允许可插拔的会话数据存储，例如企业级缓存，关系型数据库。NoSQL等。这意味着你可以一次配置会话群集，并且无论你的部署环境如何，它都将以相同的方式工作–Tomcat、Jetty、JEE Server或者独立的应用。实在是没用必要根据你怎么部署你的应用来重新配置你的应用。</p>
<p>另一个Shiro session的好处是session数据如果需要可以跨客户端共享。举个栗子，如果需要，Swing桌面客户端可以参与相同的Web应用程序会话–如果终端用户同时使用两者，则很有用。因此你怎样在任何环境下访问主体的session？下面的代码主体的2个方法会展示出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Session session = subject.getSession();</div><div class="line">Session session = subject.getSession(boolean create);</div></pre></td></tr></table></figure></p>
<p>如你所见，这些方法在概念上与HttpServletRequest API相同。第一个方法将会返回主体存在的session，如果没有，那就创建一个再返回。第二个方法接收一个bool参数，这个参数决定是否在session不存在的时候创建新的session。一旦你请求主体的session，你可以使用它和几乎使用HttpSession一样。Shiro团队考虑到HTTPSession对Java开发人员很友好，因此我们有这种感觉。最大的区别就是你可以在任何应用中使用Shiro Session，不仅限于web应用。下面的代码展示了其相同之处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Session session = subject.getSession();</div><div class="line">session.getAttribute(“key”, someValue);</div><div class="line">Date start = session.getStartTimestamp();</div><div class="line">Date timestamp = session.getLastAccessTime();</div><div class="line">session.setTimeout(millis);</div></pre></td></tr></table></figure></p>
<h4 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h4><p>密码学是隐藏或混淆数据的过程，所以窥探眼睛无法理解它。Shiro在密码学中的目标是简化和使用JDK的加密支持。要注意的是，一般来说密码学对于主体来说不是特定的，所以它是Shiro API的一个领域，和主体无关。你可以使用Shiro的加密用在任何地方，即使主体没有使用。Shiro真正关注的两个领域一个是哈希加密和密码加密。</p>
<h5 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h5><p>如果你用过JDK的MessageDigest类，你很快会发现用起来有一点笨重。它有一套基于工厂的笨重的静态方法API，而不是面向对象的，而且你被迫捕获那些永远不会被捕获的异常。假如你需要16进制或者base64编码消息摘要的输出，你得自己写–没有标准的JDK实现。Shiro以干净直观的散列API解决了这些问题。</p>
<p>打个比方，我们考虑一下比较常见的MD5散列文件并确定该哈希值的十六进制值的情况。“校验和”，这是在提供文件下载时经常使用的 - 用户可以在下载的文件上执行自己的MD5哈希，并声明其校验和与下载站点的校验和匹配。假如匹配，用户可以充分地假设该文件在传输过程中没有被篡改。</p>
<p>在不使用Shiro情况下这个过程：</p>
<ol>
<li>将文件转化为字节数组。JDK不能帮你完成，因此你得自己创建一个打开FileInputStream的方法，使用字节缓冲，然后抛出可能的异常等等。</li>
<li>用MessageDigest类来对字节数组求哈希，处理异常。</li>
<li>对哈希后的字节数组编码成16进制。JDK中也没有现成的帮你完成，因此你得创建另一个帮助类，并且可能在你的实现中使用按位操作和位移。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">    md.digest(bytes);</div><div class="line">    byte[] hashed = md.digest();</div><div class="line">&#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这么简单和相对普遍的事情来说，这是一个很繁琐的工作。<br>看看Shiro怎么做相同的事情的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String hex = new Md5Hash(myFile).toHex();</div></pre></td></tr></table></figure></p>
<p>当你使用Shiro来简化所有这些工作时，这是非常简单和容易理解的。  SHA-512散列和Base64编码的密码同样简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String encodedPassword =</div><div class="line">    new Sha512Hash(password, salt, count).toBase64();</div></pre></td></tr></table></figure>
<p>可以看到在哈希和编码上Shiro帮你简化了多少，在这个过程中节省了你不少时间。</p>
<h5 id="Ciphers"><a href="#Ciphers" class="headerlink" title="Ciphers"></a>Ciphers</h5><p>密码是可以使用密钥可逆地转换数据的加密算法。我们通常用作保护数据安全，特别在传输或者存储数据的时候，数据特别容易被窥探。</p>
<p>如果你曾经使用过JDK加密API，特别是 javax.crypto.Cipher类，你知道这可以是一个难以置信的复杂野兽驯服（翻译为这是一个很困难的过程）。对于入门者而言，每个密码配置始终由javax.crypto.Cipher的一个实例表示。需要公钥/私钥加密吗？</p>
<p>然而怎么创建你需要的Cipher 实例？你创建一个复杂的，非直观的令牌分隔的密码选项字符串，称为“转换字符串”，并将此字符串传递给Cipher.getInstance静态工厂方法。使用这种密码选项String方法，没有类型安全性来确保你使用有效的选项。这也隐含意味着没有JavaDoc帮助你了解相关选项。而且您还需要处理检查的异常情况，以防你的String配置不正确，即使你知道配置正确。正如你所看到的，使用JDK密码是一项相当麻烦的任务。这些技术曾经是Java API在很久以前的标准，但时代已经改变，我们想要一个更简单的方法。</p>
<p>Shiro尝试通过引入其CipherService API来简化加密密码的整个概念。CipherService是大多数开发人员在保护数据时所需要的：一种简单，无状态，线程安全的API，可以在一个方法调用中对数据进行全面加密或解密。所有你需要做的是提供你的密钥，可以根据需要进行加密或解密。例如，可以使用256位AES加密：</p>
<blockquote>
<p>AesCipherService cipherService = new AesCipherService();<br>cipherService.setKeySize(256);<br>//create a test key:<br>byte[] testKey = cipherService.generateNewKey();<br>//encrypt a file’s bytes:<br>byte[] encrypted =<br>    cipherService.encrypt(fileBytes, testKey);</p>
</blockquote>
<p>与JDK的Cipher API相比，Shiro示例更简单:</p>
<ul>
<li>你可以直接实例化CipherService  - 没有奇怪或混乱的工厂方法。</li>
<li>密码配置选项表示为与JavaBeans兼容的getter和setter  - 没有奇怪和难以理解的“转换字符串”。</li>
<li>加密和解密在单一方法调用中执行。</li>
<li>没有强制检查异常。 如果你想要的话，可以捕获Shiro的CryptoException。</li>
</ul>
<p>Shiro的CipherService API还有其他优点，例如支持基于字节数组的加密/解密（称为“块”操作）以及基于流的加密/解密（例如，加密音频或视频）的能力。</p>
<p>Java加密技术不必如此难受。<br>Shiro对密码的支持旨在简化你保护数据安全的付出。</p>
<h4 id="Web-Support"><a href="#Web-Support" class="headerlink" title="Web Support"></a>Web Support</h4><p>最后，但不是不重要的，我们简要介绍Shiro对web的支持。Shiro拥有强大的web支持模块，来保护web应用安全。为一个web应用设置Shiro是很简单的。仅需要在web.xml中定义一个Shiro Servlet Filter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;</div><div class="line">        org.apache.shiro.web.servlet.IniShiroFilter</div><div class="line">    &lt;/filter-class&gt;</div><div class="line">    &lt;!-- no init-param means load the INI config</div><div class="line">        from classpath:shiro.ini --&gt; </div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;</div><div class="line">     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>这个过滤器能够读之前的shiro.ini配置文件，因此无论在什么样的部署环境下，配置都是一样的。一旦配置好了，Shiro filter就会过滤一切请求，并确保在请求期间特定的请求主体可被访问。由于过滤所有请求，你可以执行指定安全的逻辑代码，以确保仅允许符合特定条件的请求。</p>
<h4 id="URL-Specific-Filter-Chains"><a href="#URL-Specific-Filter-Chains" class="headerlink" title="URL-Specific Filter Chains"></a>URL-Specific Filter Chains</h4><p>Shiro通过它特有的URL链来支持安全的过滤规则。它允许你为任何匹配的URL模式指定特殊过滤器链。这意味着在使用Shiro过滤机制的时候你有很大的灵活性–比在web.xml中定义的过滤器好很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[urls]</div><div class="line">/assets/** = anon</div><div class="line">/user/signup = anon</div><div class="line">/user/** = user</div><div class="line">/rpc/rest/** = perms[rpc:invoke], authc</div><div class="line">/** = authc</div></pre></td></tr></table></figure></p>
<p>如你所见，有一个用于web应用的[urls]部分。每一行等号的左边表示一个上下文相关的web应用路径。等号右边定义了一个过滤器链–有序的、逗号分隔的为指定路径执行servlet过滤器列表。每一个过滤器是一个servlet filter，但是你在上述看到的过滤器是特殊的，是与安全相关的由Shiro提供开箱即用的过滤器。你可以组合和匹配这些安全过滤器，以创建自定义的安全体验。你还可以指定任何其他现有的可能拥有的Servlet过滤器。</p>
<p>使用Shiro，更容易看出为给定的匹配路径执行的过滤器链。只要你想，你可以只在web.xml中定义Shiro filter然后在ini配置文件中定义其他过滤器和过滤器链，这样比web.xml更简洁，易于理解的过滤器链定义机制。即使你没有使用任何Shiro的安全特性，这个小小的方便让Shiro值得使用。</p>
<h4 id="JSP-Tag-Library"><a href="#JSP-Tag-Library" class="headerlink" title="JSP Tag Library"></a>JSP Tag Library</h4><p>Shiro还提供一套JSP标签来允许你基于当前主体的状态控制页面输出。一个常见有用的例子就是当一个用户登录后显示‘Hello <username>’文本。但是假如他们是匿名的，你就得显示点别的，像“Hello! Register Today!”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib prefix=&quot;shiro&quot;</div><div class="line">    uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</div><div class="line">...</div><div class="line">&lt;p&gt;Hello</div><div class="line">&lt;shiro:user&gt;</div><div class="line">    &lt;!-- shiro:principal prints out the Subject’s main</div><div class="line">        principal - in this case, a username: --&gt;</div><div class="line">    &lt;shiro:principal/&gt;!</div><div class="line">&lt;/shiro:user&gt;</div><div class="line">&lt;shiro:guest&gt;</div><div class="line">    &lt;!-- not logged in - considered a guest. Show</div><div class="line">        the register link: --&gt;</div><div class="line">    ! &lt;a href=”register.jsp”&gt;Register today!&lt;/a&gt;</div><div class="line">&lt;/shiro:guest&gt;</div><div class="line">&lt;/p&gt;</div></pre></td></tr></table></figure></username></p>
<p>还有其他标签基于用户有哪些角色或者没有哪些角色，分配了哪些权限，有没有被认证，“记住我”了的，或者一个匿名用户来允许你输出。<br>Shiro支持很多web特有的feature，像记住我，REST和BASIC认证，当然，如果你希望使用Shiro的本地企业会话，也可以使用透明的HttpSession支持。参见<a href="http://shiro.apache.org/web.html" target="_blank" rel="external">Apache Shiro web documentation</a></p>
<h4 id="Web-Session-Management"><a href="#Web-Session-Management" class="headerlink" title="Web Session Management"></a>Web Session Management</h4><p>最后，有趣的是探讨Shiro在web环境中对session的支持。</p>
<h5 id="Default-Http-Sessions"><a href="#Default-Http-Sessions" class="headerlink" title="Default Http Sessions"></a>Default Http Sessions</h5><p>对web应用而言，Shiro默认的session架构是我们现有常使用的Servlet Container。当你调用<code>subject.getSession()</code>和<code>subject.getSession(boolean)</code>方法的时候，Shiro会返回一个由Servlet 容器支持的session实例。这种方法的优点是调用subject.getSession（）的业务层代码与Shiro Session实例进行交互–它并不知道是和一个基于web的HTTPSession对象一起工作的。分层架构保持代码整洁是很好的做法。</p>
<h5 id="Shiro’s-Native-Sessions-in-the-Web-Tier"><a href="#Shiro’s-Native-Sessions-in-the-Web-Tier" class="headerlink" title="Shiro’s Native Sessions in the Web Tier"></a>Shiro’s Native Sessions in the Web Tier</h5><p>假如你在web应用中开启了Shiro的本地session管理，你需要Shiro的企业session特性（类似独立于容器的集群），当然你想<code>HttpServletRequest.getSession()</code> 和<code>HttpSession</code> API和本地session一起使用而不是servlet容器的session。如果你要重构任何使用HttpServletRequest和HttpSession API的代码，而不是使用Shiro的Session API，那将是非常令人沮丧的。Shiro永远不期望你这样做。相反，Shiro完全实现了Servlet规范的Session部分，以支持Web应用程序中的本机会话。这意味着每当你调用相应的HttpServletRequest或HttpSession方法调用时，Shiro会将这些调用委托给其内部本地Session API。结果就是你不需要去改动你的代码，即使你使用Shiro本地会话管理–实际上是一个非常方便和必要的特性。</p>
<h3 id="Additional-Features"><a href="#Additional-Features" class="headerlink" title="Additional Features"></a>Additional Features</h3><p>在Shiro框架中其他用于让Java应用安全的特性，例如（中文翻译太晦涩，还是直接贴原文的）：</p>
<ul>
<li>Threading and Concurrency support for maintaining Subjects across threads (Executor and ExecutorService support)</li>
<li>Callable and Runnable support for executing logic as a specific Subject</li>
<li>“Run As” support for assuming the identity of another Subject (e.g. useful in administrative applications)</li>
<li>Test harness support, making it very easy to have full testing of Shiro secured-code in unit and integration tests</li>
</ul>
<h3 id="Framework-Limitations"><a href="#Framework-Limitations" class="headerlink" title="Framework Limitations"></a>Framework Limitations</h3><p>就像我们想要的那样，Apache Shiro不是一个“银弹”–它不会轻易解决所有安全问题。Shiro没有解决这些事情:</p>
<ul>
<li>虚拟机级别的考虑：当前Shiro没有考虑虚拟机级别的安全，比如基于访问控制策略的阻止特定的class加载到类加载器中。然而Shiro和现有的JVM安全操作整合起来是不可思议的–只是没有人去为这个项目做这件事罢了。</li>
<li>多阶段认证：Shiro当前不支持‘多阶段’认证，用户可以通过一种机制登录，只能被要求使用不同的机制再次登录。这已经在基于Shiro的应用程序中完成，但应用程序通过应用程序收集所有必需的信息，然后与Shiro进行交互。很可能在未来的版本中会有这种支持。</li>
<li>写域操作：当前所有的域实现支持读操作来获取认证和授权数据用来执行登录和访问控制。写操作，像创建用户，组和角色或者将用户和角色组及权限关联起来都是不支持的。这是因为支持这些操作的数据模型在应用程序中有很大差异，所以在所有Shiro用户上执行“写入”API将是困难的。</li>
</ul>
<h3 id="Upcoming-Features"><a href="#Upcoming-Features" class="headerlink" title="Upcoming Features"></a>Upcoming Features</h3><p>Shiro的社区每天都很活跃，Shiro的特性也在变多。在接下来的版本中你将看到:</p>
<ul>
<li>简洁的web filter机制，允许更多的可插拔的过滤器支持，而不是通过子类。</li>
<li>更多可插拔的默认有利于组合继承的域实现。你将能够插拔查找身份验证和授权数据的组件，而不是要求你对Shiro Realm实现进行子类实现。</li>
<li>强大的OpenID和OAuth（或者都有）客户端支持</li>
<li>验证码支持</li>
<li>100％无状态应用程序（例如许多REST环境）更容易配置。</li>
<li>通过请求/响应协议进行多级认证。</li>
<li>通过AuthorizationRequest进行粗粒度授权。</li>
<li><a href="http://www.antlr.org/" target="_blank" rel="external">ANTLR</a>语法用于安全断言查询（例如（’role（admin）&amp;&amp;（guest ||！group（developer））’）</li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Apache Shiro是一个功能齐全，功能强大且通用的Java安全框架，可用于保护你的应用程序。通过简化应用安全性的四个方面，即认证，授权，会话管理和密码，应用安全性在实际应用中更容易理解和实现。Shiro的简单架构和JavaBeans兼容性允许在几乎任何环境中进行配置和使用。额外的网络支持和辅助功能，如对多线程和测试的支持，整合框架，为应用程序安全性提供可能是你的“一站式”服务。Apache Shiro的开发团队继续前进，改进代码库并支持社区。随着开源代码和商业化的采用，Shiro只会越来越强。</p>
<h3 id="About-the-Author"><a href="#About-the-Author" class="headerlink" title="About the Author"></a>About the Author</h3><p>Les Hazlewood是Shiro PMC主席，Katasoft的联合创始人兼首席技术官，专注于应用程序安全产品和对Apache Shiro的支持。Les拥有10年的Java开发和企业架构师经验，曾在Bloomberg, Delta Airlines, 和 JBoss担任过高级职务。Les一直在积极参与开源开发9年以上，为Spring Framework，Hibernate，JBoss，OpenSpaces以及Apache Shiro的前身JSecurity等项目提交或贡献过代码。Les目前住在加州圣马特奥，并且在不编程的时候练习剑道和研究日语。</p>
<p>查看英文原文： <a href="https://www.infoq.com/articles/apache-shiro" target="_blank" rel="external">Application Security With Apache Shiro</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的应用添加安全措施的时候有没有觉得很受挫？你有没有觉得Java在安全这一块的解决方案用起来很难，让你更加觉得困惑？这篇文章介绍&lt;a href=&quot;http://shiro.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apac
    
    </summary>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.mr-dongw.site/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.mr-dongw.site/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Features（Part Ⅱ）</title>
    <link href="http://www.mr-dongw.site/2017/08/10/spring-boot-fatures-2/"/>
    <id>http://www.mr-dongw.site/2017/08/10/spring-boot-fatures-2/</id>
    <published>2017-08-10T13:58:23.000Z</published>
    <updated>2017-08-10T13:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇继续针对上一篇文章对spring boot 未介绍完的feature进行补充。<br><a id="more"></a> </p>
<h3 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h3><p>用过maven都知道，maven中有个profiles的设置。</p>
<blockquote>
<p>profile一个非常重要的特性就是它可以根据不同的环境来激活，比如说根据操作系统的不同激活不同的profile，也可以根据jdk版本的不同激活不同的profile.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </div><div class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>profileTest1<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">              <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的配置就是当JDK版本为1.5的时候激活profileTest1。<br>spring boot也提供这么一种机制。在特定的环境下使用特定的配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的配置就是在production环境下生效。通常在<code>application.properties</code>这个文件下配置<code>spring.profiles.active=xxx</code>属性来指定不同的profile。当然使用命令行也是可以的。</p>
<p>其实这个feature不算什么特性，很一般。</p>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>spring boot 内部的日志是使用的Common Logging，但是也提供很多其他的实现。默认还提供JUL、Log4J和Logback。</p>
<p>日志输出文本的颜色是可以设置的，假如控制台支持ANSI的话，然而我觉得并没卵用。默认情况下，日志只会输出到控制台，不会输出到文件。加入要输出到文件就需要在同样在<code>application.properties</code>文件中配置一下这几个属性了：<code>logging.file</code> <code>logging.path</code>。文件名不写的话默认为<code>spring.log</code>，路径不写的话默认在当前路径下。日志文件到10m的时候就回重新生成一个新的文件。</p>
<p>给日志设置级别就不多提了，都是很老掉牙的东西了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">logging.level.root=WARN</div><div class="line">logging.level.org.springframework.web=DEBUG</div><div class="line">logging.level.org.hibernate=ERROR</div></pre></td></tr></table></figure></p>
<p>自定义日志组件也是比较方便的，每个日志框架都有所不同嘛。spring boot提供这种热插拔式的配置。在配置文件中指定<code>logging.config</code>的值即可。这个属性代表着日志配置文件的位置。不同的日志系统有不同的配置文件。</p>
<ul>
<li><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code>是logback的。</li>
<li><code>log4j2-spring.xml</code>, <code>log4j2.xml</code>是log4j2的。</li>
<li><code>logging.properties</code>是JUL的。<br>日志系统没什么可说的，对我而言，使用默认的就完事儿了。</li>
</ul>
<p>基本上核心feature全部梳理完了。接下来看看Web Applications Features。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>spring boot也适合web开发，使用<code>spring-boot-starter-web</code>模块很快就能搭建一个HTTP应用。<br>使用过Spring MVC的开发者来讲，这个feature一点都不新鲜。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.GET)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;/customers"</span>, method=RequestMethod.GET)</div><div class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.DELETE)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个栗子使用<code>@RestController</code>注解来返回JSON数据。<br>还有很多更详细的内容，可以参见<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc" target="_blank" rel="external">spring framework 官方文档</a></p>
<h3 id="Working-with-SQL-databases"><a href="#Working-with-SQL-databases" class="headerlink" title="Working with SQL databases"></a>Working with SQL databases</h3><p>spring boot中对数据库的支持可以说是爽翻天。</p>
<p>首先得创建一个数据源，废话不多说：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"app.datasource"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FancyDataSource();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.datasource.url=jdbc:h2:mem:mydb</div><div class="line">app.datasource.username=sa</div><div class="line">app.datasource.pool-size=30</div></pre></td></tr></table></figure>
<p>意思就是这么个意思，配置方式多种多样。不仅仅可以支持外部数据库，内存数据库也是支持的。例如H2、HSQL和Derby，在spring boot中只需要提供一个依赖她就能自动配置，就是这么厉害。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在对外部数据库的连接管理中，spring boot使用的是池化的数据源。对于使用何种池化方式，策略是这样的：Tomcat的连接池&gt;HikariCP&gt;DBCP(不推荐，因为没人去维护了)&gt;DBCP2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spring.datasource.url=jdbc:mysql://localhost/test</div><div class="line">spring.datasource.username=dbuser</div><div class="line">spring.datasource.password=dbpass</div><div class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</div></pre></td></tr></table></figure></p>
<p>其中的url是一定要写的，不然的话spring boot去自动去配置内嵌的数据库了。driver可以不指定，因为可以通过url去判断driver。</p>
<p>说完数据源，再聊聊JdbcTemplate。这个东西在spring boot中用起来是非常爽，直接就能用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅此而已！</p>
<p>关于spring data和JPA 的介绍也没有多解释，文档说很多细节让我们去<a href="https://spring.io/guides/gs/accessing-data-jpa/" target="_blank" rel="external">这里</a>看看，看来还是比较复杂。</p>
<p>在传统的JPA中entity需要在<code>persistence.xml</code>中定义。但在spring boot中不需要这么麻烦，因为她能帮你扫描到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span></div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line"></div><div class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line"></div><div class="line">    <span class="comment">// ... additional members, often include @OneToMany mappings</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// no-args constructor required by JPA spec</span></div><div class="line">        <span class="comment">// this one is protected since it shouldn't be used directly</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.country = country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ... etc</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring Data JPA Repositories是一个好东西，JPA查询可以根据你方法的名字来。举个栗子，<code>CityRepository</code>接口定义一个<code>findAllByState(String state)</code>方法，你传一个state条件它就能查出来。</p>
<p>然而这仅仅只是一小部分，文档有句话细思极恐：</p>
<blockquote>
<p>We have barely scratched the surface of Spring Data JPA.</p>
</blockquote>
<p>spring boot对NoSQL也有支持。像MongoBD、Neo4J、Elasticsearch、Solr、Redis、 Gemfire、Cassandra、Couchbase 和LDAP。</p>
<p>Redis:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> StringRedisTemplate template;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.template = template;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用redis除了添加<code>spring-boot-starter-data-redis</code>依赖外，想用的话如上面代码一样简单。</p>
<p>MongoDB：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MongoDbFactory mongo;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDbFactory mongo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mongo = mongo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</div><div class="line">        DB db = mongo.getDb();</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mongodb同样也是如此，假如你的mongoDB采用分片的话，这样指定url就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</div></pre></td></tr></table></figure></p>
<p>如果使用的是2.x的版本，这样去配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.data.mongodb.host=mongoserver</div><div class="line">spring.data.mongodb.port=27017</div></pre></td></tr></table></figure></p>
<p>MongoTemplate用起来更加方便：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mongoTemplate = mongoTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他的文档中也没多去解释，丢了个链接让读者自己去看。所以这里也不多去关注了。需要的时候再整理。</p>
<p>spring boot也提供对JMS的支持，这也算是一个feature吧。</p>
<p>JMS在Java中只定义了一些接口，具体实现还是依赖各个厂商。其中ActiveMQ就是一个JMS的标准实现，spring boot对其有比较好的支持。</p>
<p>同样的，只需要添加<code>spring-boot-starter-activemq</code>依赖，spring boot就能帮你自动去配置，当然少不了最基本的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">spring.activemq.broker-url=tcp://192.168.1.210:9876</div><div class="line">spring.activemq.user=admin</div><div class="line">spring.activemq.password=secret</div></pre></td></tr></table></figure></p>
<p>当然使用连接池也是可以的，添加这个依赖即可：<code>org.apache.activemq:activemq-pool</code>，同时做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.activemq.pool.enabled=true</div><div class="line">spring.activemq.pool.max-connections=50</div></pre></td></tr></table></figure></p>
<p>至于具体怎么去使用这里不再详细描述，使用到的时候再去<a href="http://docs.spring.io/spring-boot/docs/1.5.6.RELEASE/reference/htmlsingle/#boot-features-jms" target="_blank" rel="external">这里</a>翻翻文档看看。</p>
<h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>对于一个框架来讲，测试一定是少不了的。spring boot提供了很多工具而注解来帮助开发者测试代码。有两个模块需要依赖：<code>spring-boot-test</code>和<code>spring-boot-test-autoconfigure</code>。前者提供基础支持，后者提供自动配置。许多开发者只会选择前者，前者提供JUnit、AssertJ、Hamcrest及其他有用的工具包。</p>
<p>当你添加<code>spring-boot-starter-test</code>依赖时，你会发现很多库被添加进来了：</p>
<ul>
<li>JUnit</li>
<li>Spring Test</li>
<li>AssertJ</li>
<li>Hamcrest</li>
<li>Mockito</li>
<li>JSONassert</li>
<li>JsonPath<br>依赖注入的一个最大的好处就是让单元测试变得更简单。在spring framework的测试框架中，常常使用<code>@ContextConfiguration(classes=…​)</code>这样的配置，或者在你的测试中使用嵌套的<code>@Configuration</code>类。在spring boot中不需要这么麻烦，<code>@*Test</code>会自动去找你的配置。</li>
</ul>
<p>在某些情况下，我们不需要自动去找测试的配置，我们可以自己手动指定配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="meta">@Import</span>(MyTestsConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至于其他内容都没什么可讲的，无非就是一些annotation的使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>spring boot的一些比较有意思的feature基本上都梳理一遍了，当然也有许多没有很具体描述的地方。整个篇幅太长太多，很多细节的地方也没有很注意到，有些表述和文字组织还是非常欠缺，这都是自己对英文版的技术文档拿捏不是很准造成的。我想我整理的东西也只有我自己能看懂了。当然目前只是一个profile，很多坑还需要自己去踩的，只能在以后的工作及学习中慢慢总结，我想没有谁是仅仅通过看了一下文档就能写出漂亮的代码来吧。</p>
<p>接下来spring boot系列内容可能就更全面，具体整理哪些东西以后想到在说。毕竟这次的feature只是试试水。我也希望我对英文技术文档的理解有更加质的提升。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇继续针对上一篇文章对spring boot 未介绍完的feature进行补充。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Framework" scheme="http://www.mr-dongw.site/categories/Spring-Framework/"/>
    
    
      <category term="Spring Boot" scheme="http://www.mr-dongw.site/tags/Spring-Boot/"/>
    
      <category term="翻译&amp;整理" scheme="http://www.mr-dongw.site/tags/%E7%BF%BB%E8%AF%91-%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Features（Part I）</title>
    <link href="http://www.mr-dongw.site/2017/08/05/spring-boot-fatures/"/>
    <id>http://www.mr-dongw.site/2017/08/05/spring-boot-fatures/</id>
    <published>2017-08-05T08:59:23.000Z</published>
    <updated>2017-08-05T09:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在spring boot官方文档中介绍了不少feature，我觉得有必要整理一下，还是挺有意思的。<br><a id="more"></a> </p>
<p>文档中根据功能作出了以下区分：</p>
<ul>
<li>Core Feature： SpringApplication（Spring应用）| Externalized Configuration（外部配置）| Profiles（轮廓）| Logging（日志） </li>
<li>Web Applications： MVC（不解释）| Embedded Containers（内嵌的容器）</li>
<li>Working with data：SQL | NO-SQL</li>
<li>Messaging: JMS（Java消息服务）</li>
<li>Testing: Boot Applications | Utils （测试相关）</li>
<li>Extending: Auto-configuration | @Conditions （拓展）</li>
</ul>
<p>以上的feature用中文翻译起来很不容易理解，这些专业术语用英文表示更让人觉得熟悉。现在就针对某个feature单独去理解。</p>
<h3 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h3><p>这个特性可以说是spring boot的创新。在以往的web程序开发过程中，我们通常将自己的程序部署在tomcat或者weblogic类似的中间件上的，但使用spring boot不需要依耐这样的中间件。使用spring boot启动你的应用就像启动一个简单的程序一样，类似我们刚接触Java写的一个个的main函数一样。它只需要这样的代码就能启动一个web应用了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    SpringApplication.run(MySpringConfiguration.class, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正常启动肯定是没什么可讲的，问题是出了问题就很难受了。没关系，spring boot同样为开发者提供了很好的解决方案。spring boot提供<code>FailureAnalyzers</code>帮助你修复问题。比方说，假如你在8080端口上启动web应用，然而这个端口被占用了，这时候控制台会报出这样的错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">***************************</div><div class="line">APPLICATION FAILED TO START</div><div class="line">***************************</div><div class="line"></div><div class="line">Description:</div><div class="line"></div><div class="line">Embedded servlet container failed to start. Port 8080 was already in use.</div><div class="line"></div><div class="line">Action:</div><div class="line"></div><div class="line">Identify and stop the process that&apos;s listening on port 8080 or configure this application to listen on another port.</div></pre></td></tr></table></figure></p>
<p>通过控制台打印出的错误信息，很容易知道问题出哪里了（英文水平不要太low）。当然这是使用默认的<code>FailureAnalyzers</code>，spring boot 也提供自己定义的<code>FailureAnalyzers</code>。在<code>META-INF/spring.factories</code>这个文件中有这样的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Failure Analyzers</div><div class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</div><div class="line">org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer</div></pre></td></tr></table></figure></p>
<p>发现了这个<code>PortInUseFailureAnalyzer</code>类吗？这个就是处理端口绑定失败的Analyzer。我们如果要自己定义一个这样的Analyzer很简单。创建一个类，继承<code>AbstractFailureAnalyzer</code>，其中的泛型可以是任何异常。重写其<code>analyze</code>方法，根据传入的参数进行处理，如果没办法处理那就返回一个<code>null</code>,这时候将由下一个Analyzer去处理。如果可以处理，直接返回一个<code>FailureAnalysis</code>对象即可。这个对象和<code>Execption</code>很类似，无非就是一些错误信息罢了。这个是我定义的一个Analyzer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFailureAnalyzer</span> <span class="keyword">extends</span> <span class="title">AbstractFailureAnalyzer</span>&lt;<span class="title">NullPointerException</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleFailureAnalyzer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out.println(<span class="string">"我是自定义的FailureAnalyzer，我开始搞事情了！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> FailureAnalysis <span class="title">analyze</span><span class="params">(Throwable rootFailure, NullPointerException cause)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"正在搞事情。。。"</span>);</div><div class="line">        System.out.println(<span class="string">"获取这个异常:"</span>);</div><div class="line">        String message = cause.getMessage();</div><div class="line">        System.out.println(message);</div><div class="line">        System.out.println(<span class="string">"事情搞完了，但是不想处理"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义这个类还没结束，还要创建一个<code>META-INF/spring.factories</code>文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</div><div class="line">com.dw.simpledemo.failureanalyzer.SimpleFailureAnalyzer</div></pre></td></tr></table></figure></p>
<p>除了这种方式诊断问题之外，还可以这样去发现问题。可以设置日志的级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">logging:</div><div class="line">  level:</div><div class="line">    root: WARN</div><div class="line">    org.springframework: DEBUG</div><div class="line">    org.hibernate: ERROR</div></pre></td></tr></table></figure></p>
<p>假如你使用的是Java命令行的方式去启动你的app可以在命令后加这样的参数<code>java -jar myproject-0.0.1-SNAPSHOT.jar --debug</code>，以debug的方式去启动。（我相信这种方式会让你的控制台爆炸，满屏都是日志，2333333。）<br>启动失败的问题分析我觉得不算特别有创新的feature，毕竟一般情况下通过报错也能找到问题出哪里了。</p>
<p>这个feature我觉得算是一个比较有意思的，虽然我觉得没什么屌用，只能算个彩蛋吧23333.<br>在我们点击<code>run</code>的时候控制台会打印一个ASCII的字符画。开始以为这个是spring boot自带的，其实这个也可以自定义的。<br>在类路径下创建一个banner.txt文件，内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$&#123;AnsiColor.BRIGHT_YELLOW&#125;</div><div class="line">////////////////////////////////////////////////////////////////////</div><div class="line">//                          _ooOoo_                               //</div><div class="line">//                         o8888888o                              //</div><div class="line">//                         88&quot; . &quot;88                              //</div><div class="line">//                         (| ^_^ |)                              //</div><div class="line">//                         O\  =  /O                              //</div><div class="line">//                      ____/`---&apos;\____                           //</div><div class="line">//                    .&apos;  \\|     |//  `.                         //</div><div class="line">//                   /  \\|||  :  |||//  \                        //</div><div class="line">//                  /  _||||| -:- |||||-  \                       //</div><div class="line">//                  |   | \\\  -  /// |   |                       //</div><div class="line">//                  | \_|  &apos;&apos;\---/&apos;&apos;  |   |                       //</div><div class="line">//                  \  .-\__  `-`  ___/-. /                       //</div><div class="line">//                ___`. .&apos;  /--.--\  `. . ___                     //</div><div class="line">//              .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.                  //</div><div class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</div><div class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</div><div class="line">//      ========`-.____`-.___\_____/___.-`____.-&apos;========         //</div><div class="line">//                           `=---=&apos;                              //</div><div class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</div><div class="line">//            佛祖保佑       永不宕机     永无BUG                  //</div><div class="line">////////////////////////////////////////////////////////////////////</div></pre></td></tr></table></figure></p>
<p>这样你的app在启动的时候就会打印这样的字符画了。个人觉得除了装b没有任何卵用。自己去定义这些字符画的生成程序也是可以的，<code>org.springframework.boot.Banner</code>这个接口就是定义怎么去实现banner的打印的，具体怎么处理可以看看它的实现类。闲的没事可以去折腾这些玩意儿！当然不想看到这些东西也是可以的。在yml文件中这样配置一下就完事儿了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">    main:</div><div class="line">        banner-mode: &quot;off&quot;</div></pre></td></tr></table></figure></p>
<p>同样的配置写成<code>application.properties</code>也是OK的。<br>然鹅，硬编码也是可以的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(MySpringConfiguration.class);</div><div class="line">    app.setBannerMode(Banner.Mode.OFF);</div><div class="line">    app.run(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来的这个feature就比较实用了。我们用的是spring boot当然少不了核心的spring的特性呀，毕竟都姓spring嘛2333！</p>
<p>我们有时候需要在spring容器启动的时候搞一些事情，spring framework也提供了这样的一种机制去帮助我们完成。它定义了很多事件来抽象出这些操作，比如说<code>ContextRefreshedEvent</code>这个事件就是当容器初始化或者被刷新了会触发。</p>
<p>我们注册一个bean可以通过<code>@Bean</code>去完成，bean的注册需要依赖容器被创建，但是创建之前的一些操作我们没办法通过<code>@Bean</code>来完成。spring boot中可以这样去设置<code>SpringApplication.addListeners(…​)</code>或者<code>SpringApplicationBuilder.listeners(…​)</code>去添加你关心的事件.当然这种方式是使用硬编码完成的，不够敞亮不够spring。可以在<code>META-INF/spring.factories</code>文件中去指定。这是默认配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Application Listeners</div><div class="line">org.springframework.context.ApplicationListener=\</div><div class="line">org.springframework.boot.ClearCachesApplicationListener,\</div><div class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</div><div class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</div><div class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</div><div class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</div><div class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</div><div class="line">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\</div><div class="line">org.springframework.boot.logging.ClasspathLoggingApplicationListener,\</div><div class="line">org.springframework.boot.logging.LoggingApplicationListener</div></pre></td></tr></table></figure></p>
<p>同样，自己去按照这样的写法去整一个自己定义的listener也是ok的，这很spring！文档中给了一段话：我们通常很少去用这个application event，但是我们知道他们存在是很有必要的。spring boot 通过他们完成很多任务。其实在做技术的过程中，也是这个道理，很多时候有些东西我们不常用，但是我们必须知道有这么个东西，说不定在什么时候就派上用场了。</p>
<p>这个feature我觉得没太多用处，毕竟我目前接触到spring boot不是很深入。spring boot启动入口是通过<code>main</code>函数，其中有<code>String[] args</code>作为参数传进来。spring boot提供<code>ApplicationArguments</code>接口让我们直接获取传入的参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">"debug"</span>);</div><div class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</div><div class="line">        <span class="comment">// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>个人觉得使用这种方式很low，将参数直接写到配置文件中去，让app启动时候去读配置不完了？</p>
<p>如果你需要在SpringApplication启动前去做点别的事情，spring boot同样能够实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">        <span class="comment">// Do something...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现<code>ApplicationRunner</code>接口同样也能达到效果。这个接口中的<code>run</code>方法参数就是上面提到的<code>ApplicationArguments</code>用来获取启动参数的。区别就在于一个只能获取<code>String</code>数组类型的参数，一个能获取<code>ApplicationArguments</code>类型的参数。</p>
<p>至此，关于Core Features: SpringApplication 的内容都梳理完了。下一个feature要讲的是Core Features: External Configuration。</p>
<h3 id="Externalized-Configuration"><a href="#Externalized-Configuration" class="headerlink" title="Externalized Configuration"></a>Externalized Configuration</h3><p>说实话，这个词中文翻译真的很难表达它想传达出的意思。作为名词的直译就是外部配置，作为动词翻译过来就是外部化配置。真的让人摸不到头脑。</p>
<p>仔细去读读内容，其实也就是一个关键词：配置。通过配置，可以让你的应用在不同环境中跑同一套代码。可以使用properties文件、YAML文件、environment变量、及命令行参数去使你的参数生效。配置参数可以通过使用<code>@Value</code>注解直接注入到你的bean中。spring boot中的配置属性是遵循一个优先级的：</p>
<ol>
<li>全局配置（当devtools生效的时候 ~/.spring-boot-devtools.properties文件作为全局配置文件）。</li>
<li><code>@TestPropertySource</code>注解配置在你的测试用例中。</li>
<li><code>@SpringBootTest#properties</code>注解属性值被设置在你的测试用例中。</li>
<li>命令行参数。</li>
<li>environment variable(启动时候可以设置的参数，类似于program arguments)或者系统参数。</li>
<li><code>ServletConfig</code>初始化参数。</li>
<li><code>ServletContext</code>初始化参数。</li>
<li><code>java:comp/env</code>JNDI参数。</li>
<li>Java System properties(System.getProperties()).</li>
<li>OS environment variables.</li>
<li>A <code>RandomValuePropertySource</code> that only has properties in random.*.(啥啥啥，说啥呢)</li>
<li>jar包外的<code>application-{profile}.properties</code>配置文件或者YAML文件。</li>
<li>jar包内的…(同上)。</li>
<li>jar包外的<code>application.properties</code>文件或者YAML文件。</li>
<li>jar包内的…(同上)。</li>
<li>在<code>@Configuration</code>注解过的类上的<code>@PropertySource</code>属性（貌似读不通）。</li>
<li>默认属性。<br>一个栗子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>application.properties</code>中有name这个属性就会被自动赋值给name字段。<code>java -jar app.jar --name=&quot;Spring&quot;</code>这种方式name就是从命令行中去读取。</p>
<p>我们的配置文件除了<code>application.properties</code>还有这种形式的：<code>application-{profile}.properties</code>这个profile决定你代码运行的环境。可以是dev、prod等等。具体去加载哪个配置文件取决于<code>spring.profiles.active</code>这个属性到底是什么。与之对应即可。如果有多个<code>application-{profile}.properties</code>文件出现，最后出现的生效。</p>
<p>spring推荐使用YMAL作为配置文件。它是JSON的超集。spring framework提供了2个方便的类加载YMAL文件：<code>YamlPropertiesFactoryBean</code>和<code>YamlMapFactoryBean</code>。前者加载成一个<code>Properties</code>，后者加载成一个<code>Map</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my:</div><div class="line">   servers:</div><div class="line">       - dev.bar.com</div><div class="line">       - foo.bar.com</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"my"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getServers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.servers;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上去有种很酸爽的感觉。</p>
<p>在一个YMAL文件中也可以指定不同的profile的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server:</div><div class="line">    address: 192.168.1.100</div><div class="line">---</div><div class="line">spring:</div><div class="line">    profiles: development</div><div class="line">server:</div><div class="line">    address: 127.0.0.1</div><div class="line">---</div><div class="line">spring:</div><div class="line">    profiles: production</div><div class="line">server:</div><div class="line">    address: 192.168.1.120</div></pre></td></tr></table></figure></p>
<p><code>server.address</code>属性在不同的profile中是不同的。<code>development</code>被激活了，就使用<code>127.0.0.1</code>.其他类似。都没激活就使用默认的<code>192.168.1.100</code>.<br>然而这种方式有缺点，不能通过<code>@PropertySource</code>注解直接注入到bean属性中。</p>
<p>spring针对<code>@Value(&quot;${property}&quot;)</code>这种方式去注入属性提供一个替换。那就是使用<code>@ConfigurationProperties(&quot;foo&quot;)</code>来放到你要注入的类中。字段名对应即可，即使有那种继承结构也没关系。YMAL本身对这种继承结构支持的很好。</p>
<p>关于Externalized Configuration的梳理也差不多了。各种炫酷屌炸天。</p>
<p>剩下的在以后几篇文章中继续整理。越来越有趣了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在spring boot官方文档中介绍了不少feature，我觉得有必要整理一下，还是挺有意思的。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Framework" scheme="http://www.mr-dongw.site/categories/Spring-Framework/"/>
    
    
      <category term="Spring Boot" scheme="http://www.mr-dongw.site/tags/Spring-Boot/"/>
    
      <category term="翻译&amp;整理" scheme="http://www.mr-dongw.site/tags/%E7%BF%BB%E8%AF%91-%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>动态代理番外篇</title>
    <link href="http://www.mr-dongw.site/2017/07/16/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    <id>http://www.mr-dongw.site/2017/07/16/动态代理番外篇/</id>
    <published>2017-07-16T06:55:23.000Z</published>
    <updated>2017-07-16T06:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中说到动态代理的实现除了JDK还有第三方的实现。现在就来瞧瞧JDK之外的动态代理的实现。<a id="more"></a> </p>
<h2 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h2><p>这个库在Github上有1390颗星星，下面是对Cglib的描述。</p>
<blockquote>
<p>cglib is a powerful, high performance and quality Code Generation Library, It is used to extend JAVA classes and implements interfaces at runtime. </p>
</blockquote>
<p>说到使用这个库的框架，其中大名鼎鼎的Hibernate就用到了，当然还有Spring。 Spring的AOP默认使用JDKProxy，如果被代理的类没有实现接口就使用Cglib去生成动态代理类。</p>
<p>它的出现是为了弥补JDK动态代理中不能对未实现接口的类进行代理。其原理也可想而知了，无非就是动态生成一个子类，这个子类继承了要代理的类，然后去重写父类（需要代理的类）的方法。这样的话，代理类就一定不能是final类型了，需要代理的方法也不能是final。因为Java不允许继承final类，不允许重写final方法。<br>下面通过一个实例来介绍Cglib实现动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 需要被代理的目标类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span>  </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello ,"</span>+ name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"TargetClass&#123;&#125;"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 目标对象拦截器，实现MethodInterceptor</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetIncerceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写方法拦截在方法前和方法后加入业务</div><div class="line">     * <span class="doctag">@param</span> o 为目标对象</div><div class="line">     * <span class="doctag">@param</span> method 为目标方法</div><div class="line">     * <span class="doctag">@param</span> objects 为参数</div><div class="line">     * <span class="doctag">@param</span> methodProxy CGlib方法代理对象 </div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"调用前"</span>);</div><div class="line">        Object result = methodProxy.invokeSuper(o, objects);</div><div class="line">        System.out.println(<span class="string">" 调用后"</span>+result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        enhancer.setSuperclass(TargetClass.class);</div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> TargetIncerceptor());</div><div class="line">        TargetClass targetClass = (TargetClass) enhancer.create();</div><div class="line"></div><div class="line">        String hello = targetClass.hello(<span class="string">"dw"</span>);</div><div class="line">        System.out.println(hello);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从表面上来看和JDK的使用还是有类似的地方的。Cglib使用<code>Enhancer</code>来去装载父类，将方法拦截器植入到生成的子类字节码中，最后创建对象。Cgilb依赖ASM字节码框架去动态生成字节码，具体生成出来的字节码文件和JDK动态代理生成出来的差别很大，区别就在于Cglib生成的代理类没有使用反射去调用要被代理的方法。从这里就可以看出Cglib在执行效率上要比JDK动态代理要高，毕竟反射效率是很低的。</p>
<h2 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte Buddy"></a>Byte Buddy</h2><p>这个类库是最近看一个RPC框架代码的时候发现的。起因是自己想尝试着写一个简单的远程方法调用的样例程序，在Github上找到了一个简单的基于Netty的实现，其中在处理动态代理的时候除了使用JDK的实现还有一个额外的实现，那就是Byte Buddy。然后稍微研究了一番，发现使用这个类库写动态代理确实很方便。</p>
<p>废话不多讲，先简单的看代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name)</span></span>;</div><div class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name,<span class="keyword">int</span> time)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span>+name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name, <span class="keyword">int</span> time)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> time+<span class="string">" Hello "</span>+name ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"nothing"</span>+i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuddyProxy</span> </span>&#123;</div><div class="line">	<span class="comment">//创建代理对象</span></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz,Object handler)</span></span>&#123;</div><div class="line"></div><div class="line">        Class&lt;? extends T&gt; cls = <span class="keyword">new</span> ByteBuddy()</div><div class="line">                .subclass(clazz)</div><div class="line">                .method(ElementMatchers.isDeclaredBy(clazz))</div><div class="line">                .intercept(MethodDelegation.to(handler))</div><div class="line">                .make()</div><div class="line">                .load(clazz.getClassLoader(), ClassLoadingStrategy.Default.INJECTION)</div><div class="line">                .getLoaded();</div><div class="line"></div><div class="line">        T t = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           t = cls.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ByteBuddyProxy proxy = <span class="keyword">new</span> ByteBuddyProxy();</div><div class="line">        Hello hello = proxy.getInstance(Hello.class, <span class="keyword">new</span> Invoker(HelloImpl.class));</div><div class="line">        hello.sayHi(<span class="number">1</span>);</div><div class="line">        String sayHi = hello.sayHi(<span class="string">"dongwei"</span>,<span class="number">9</span>);</div><div class="line">        System.out.println(sayHi);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//暂时理解为和JDK Proxy中的InvocationHandler一样的东西吧</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.clazz = clazz;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RuntimeType</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(@Origin Method method, @AllArguments @RuntimeType Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Object result = method.invoke(clazz.newInstance(),args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是一个很简单的小栗子，还有很多复杂的特性没有深入研究。我只能对写这个库的作者表示很崇高的敬佩！</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然除了文章中所介绍的生成动态代理的工具还有很多没有提及，比方说javaassit等。其原理大致类似，无非就是在JVM加载字节码的时候将字节码给替换了或者改掉了，很多都依赖于ASM库，如果对class字节码规范很熟悉的话自己也可以使用ASM来写一个字节码生成工具。<br>从阅读别人写的RPC框架的源码中发现了很多有意思的东西，从其中的动态代理可以了解到字节码生成加载。慢慢才发现写代码真的不是想象中那么简单的，变化的东西太多了，也只有时刻保持着学习的态度也才可能跟得上节奏，才不会被淘汰。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中说到动态代理的实现除了JDK还有第三方的实现。现在就来瞧瞧JDK之外的动态代理的实现。
    
    </summary>
    
      <category term="OPEN SOURCE" scheme="http://www.mr-dongw.site/categories/OPEN-SOURCE/"/>
    
    
      <category term="字节码工具" scheme="http://www.mr-dongw.site/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>动态代理之JDK实现</title>
    <link href="http://www.mr-dongw.site/2017/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BJDK%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.mr-dongw.site/2017/07/09/动态代理之JDK实现/</id>
    <published>2017-07-09T02:29:23.000Z</published>
    <updated>2017-07-09T02:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近呢，看到了一个开源的PRC FRAMEWORK，当然不是Dubbo。然后想去了解一下RPC到底是怎么去实现的。于是乎就了解了一番，发现其灵魂在于动态代理和反射。<a id="more"></a> </p>
<h5 id="What’s-Dynamic-Proxy"><a href="#What’s-Dynamic-Proxy" class="headerlink" title="What’s Dynamic Proxy ?"></a>What’s Dynamic Proxy ?</h5><p>在讲什么是动态代理前先得明白什么是代理。在日常生活中的代理其实就是委托的意思。将事情交代给委托对象去做，这就是代理。程序中的代理是什么意思呢？这里更准确的解释应该是一种设计模式–代理模式（Proxy)<br><img src="http://img.my.csdn.net/uploads/201211/29/1354197582_1664.PNG" alt="Proxy"><br>下面给出一个简单的关于代理的Java实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	<span class="comment">//主题接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	<span class="comment">//接口实现</span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"the original method!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代理类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	</div><div class="line">    <span class="keyword">private</span> Source source;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">super</span>();  </div><div class="line">        <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </div><div class="line">        before();  </div><div class="line">        source.method();  </div><div class="line">        atfer();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"after proxy!"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"before proxy!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用客户端</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Sourceable source = <span class="keyword">new</span> Proxy();  </div><div class="line">        source.method();  </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中代理类中对主题接口进行了增强—在主题方法调用前后调用了<code>before</code>和<code>after</code> 。Spring AOP中的思想正是如此。<br>这就是Java中的代理模式，只不过上面的代码实现是基于硬编码的，也就是所说的<strong>静态代理</strong>。那么区别于静态代理，那就一定有<strong>动态代理了</strong>。<br>通过以上的代码可以看出，静态代理将代码写死，是在编译阶段完成的具体代理类的绑定。但是动态代理不是这么做的，而是在程序运行时完成的这操作。下面使用动态代理方式实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用jdk动态代理实现需要实现接口InvocationHandler</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object targrt;<span class="comment">//代理的真实对象，也就是接口的实现类</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object targrt)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.targrt = targrt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * 该方法负责集中处理动态代理类上的所有方法调用。</div><div class="line">     * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</div><div class="line">     * <span class="doctag">@param</span> proxy 代理类实例</div><div class="line">     * <span class="doctag">@param</span> method 被调用的方法对象</div><div class="line">     * <span class="doctag">@param</span> args 调用参数</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//这里来处理代理的具体工作</span></div><div class="line">        <span class="comment">//假设在执行前进行一个打印日志的处理</span></div><div class="line">        before();</div><div class="line">        Object result = method.invoke(targrt, args);</div><div class="line">        <span class="comment">//假设执行结束后打印一个执行完成的通知</span></div><div class="line">        atfer();</div><div class="line">        <span class="comment">//将执行结果返回如果有的话</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"after proxy!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"before proxy!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class[] interfaceClass)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</div><div class="line">                                        interfaceClass,<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//客户端</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Sourceable s = <span class="keyword">new</span> Source();</div><div class="line"></div><div class="line">        JdkProxy proxy = <span class="keyword">new</span> JdkProxy(s);</div><div class="line"></div><div class="line">        Sourceable hello = (Sourceable) proxy.getProxy(<span class="keyword">new</span> Class[]&#123;Sourceable.class&#125;);</div><div class="line">        </div><div class="line">        hello.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可见，我们对主题对象所有的方法的调用都会变成对<code>invoke</code>方法的调用，而我们可以在这个方法中添加统一的逻辑处理。<br>所以可以看出，动态代理的几个好处：</p>
<ul>
<li>易于维护。相对于静态代理来说，只要在Proxy类中固定好处理逻辑而不用针对每个方法去编写代码了。控制了代码量，便于维护。</li>
<li>使AOP编程更加容易。在Spring的帮助下轻松添加、移除动态代理，且对源代码没有任何影响。</li>
<li>解耦。可以通过参数就能判断具体实现类，不需要事先实例化，更加灵活多变。<h5 id="The-Mechanism-of-Dynamic-Proxy"><a href="#The-Mechanism-of-Dynamic-Proxy" class="headerlink" title="The Mechanism of Dynamic Proxy"></a>The Mechanism of Dynamic Proxy</h5>谈完了什么是动态代理，现在就可以来了解一下动态代理是怎么实现的了。要去知道Jdk动态代理是怎么实现的还得去源码中找。<br>看看<code>Proxy#newProxyInstance</code>的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, interfaces);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 找缓存里有没有Proxy对象，没有就生成一个.</div><div class="line">         */</div><div class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Invoke its constructor with the designated invocation handler.</div><div class="line">         * 用指定的handler来调用构造方法</div><div class="line">         */</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</div><div class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span> &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123;</div><div class="line">                <span class="comment">// create proxy instance with doPrivilege as the proxy class may</span></div><div class="line">                <span class="comment">// implement non-public interfaces that requires a special permission</span></div><div class="line">                <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> newInstance(cons, ih);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> newInstance(cons, ih);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面的代码中不难看出其核心在于获取一个代理类对象。得到类对象后再通过反射去创建代理对象实例。看看<code>getProxyClass0</code>怎么实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Generate a proxy class.  Must call the checkProxyAccess method</div><div class="line">     * to perform permission checks before calling this.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</div><div class="line">                                           Class&lt;?&gt;... interfaces) &#123;</div><div class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></div><div class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></div><div class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></div><div class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>呃…好吧！这个方法是从一个cache对象中去拿Proxy类对象的。所以我们还是不知道代理类对象是怎么产生的。不过这里有一点有点意思，就是代理类实现的接口数不能超过65535个。看到这个数字是否很惊喜或者也有点意外？关于65535我特意去查了一下<a href="https://en.wikipedia.org/wiki/65535_(number" target="_blank" rel="external">Wiki</a>)。这是Java语言机制导致的。当然没有哪个变态去实现这么多个接口吧。<br>既然从cache中去找，那么看看这个cache到底是何方神圣。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * a cache of proxy classes</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</div></pre></td></tr></table></figure></p>
<p>具体到这个cache是怎么实现的就不去纠结了，因为纠结也没用（API文档中没有这个类的解释，因为这个类的修饰是package-private的而不是public）。仔细以看有一个<code>ProxyClassFactory</code>对象作为参数传给这个cache了。这下自貌似有搞头了。看看这个类的名字就很爽—代理类工厂嘛。实际上这是Proxy的一个静态内部类。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">private static final class ProxyClassFactory</div><div class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">    &#123;</div><div class="line">        // 生成代理类名称的前缀</div><div class="line">        private static final String proxyClassNamePrefix = "$Proxy";</div><div class="line"></div><div class="line">        // 用于生成代理类名字的计数器 </div><div class="line">        private static final AtomicLong nextUniqueNumber = new AtomicLong();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</div><div class="line">			//各种验证</div><div class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</div><div class="line">            for (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">                /*</div><div class="line">                 * Verify that the class loader resolves the name of this</div><div class="line">                 * interface to the same Class object.</div><div class="line">                 */</div><div class="line">                Class&lt;?&gt; interfaceClass = null;</div><div class="line">                try &#123;</div><div class="line">                    interfaceClass = Class.forName(intf.getName(), false, loader);</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                &#125;</div><div class="line">                if (interfaceClass != intf) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        intf + " is not visible from class loader");</div><div class="line">                &#125;</div><div class="line">                /*</div><div class="line">                 * Verify that the Class object actually represents an</div><div class="line">                 * interface.</div><div class="line">                 */</div><div class="line">                if (!interfaceClass.isInterface()) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        interfaceClass.getName() + " is not an interface");</div><div class="line">                &#125;</div><div class="line">                /*</div><div class="line">                 * Verify that this interface is not a duplicate.</div><div class="line">                 */</div><div class="line">                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        "repeated interface: " + interfaceClass.getName());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			//代理类的包名</div><div class="line">            String proxyPkg = null;     // package to define proxy class in</div><div class="line"></div><div class="line">            //对于不是public修饰的接口，代理类的包名和接口包名一致</div><div class="line">            for (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">                int flags = intf.getModifiers();</div><div class="line">                if (!Modifier.isPublic(flags)) &#123;</div><div class="line">                    String name = intf.getName();</div><div class="line">                    int n = name.lastIndexOf('.');</div><div class="line">                    String pkg = ((n == -1) ? "" : name.substring(0, n + 1));</div><div class="line">                    if (proxyPkg == null) &#123;</div><div class="line">                        proxyPkg = pkg;</div><div class="line">                    &#125; else if (!pkg.equals(proxyPkg)) &#123;</div><div class="line">                        throw new IllegalArgumentException(</div><div class="line">                            "non-public interfaces from different packages");</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			//public修饰的接口 包名统一为com.sun.proxy</div><div class="line">            if (proxyPkg == null) &#123;</div><div class="line">                // if no non-public proxy interfaces, use com.sun.proxy package</div><div class="line">                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /*</div><div class="line">             * Choose a name for the proxy class to generate.</div><div class="line">             */</div><div class="line">            long num = nextUniqueNumber.getAndIncrement();</div><div class="line">            // 默认情况下，代理类的完全限定名为：com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1……依次递增  </div><div class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</div><div class="line"></div><div class="line">            // 这里才是真正的生成代理类的字节码的地方  </div><div class="line">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</div><div class="line">                proxyName, interfaces);</div><div class="line">            try &#123;</div><div class="line">	            // 根据二进制字节码返回相应的Class实例  </div><div class="line">                return defineClass0(loader, proxyName,</div><div class="line">                                    proxyClassFile, 0, proxyClassFile.length);</div><div class="line">            &#125; catch (ClassFormatError e) &#123;</div><div class="line">                /*</div><div class="line">                 * A ClassFormatError here means that (barring bugs in the</div><div class="line">                 * proxy class generation code) there was some other</div><div class="line">                 * invalid aspect of the arguments supplied to the proxy</div><div class="line">                 * class creation (such as virtual machine limitations</div><div class="line">                 * exceeded).</div><div class="line">                 */</div><div class="line">                throw new IllegalArgumentException(e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>唉，感觉看了半天发现又被绕进去了。没办法，继续看看<code>ProxyGenerator</code>这个类怎么去实现的。这个是Jdk私有的，但是可以反编译查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class[] var1) &#123;</div><div class="line">        ProxyGenerator var2 = <span class="keyword">new</span> ProxyGenerator(var0, var1);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var3 = var2.generateClassFile();</div><div class="line">        <span class="comment">// 这里根据参数配置，决定是否把生成的字节码（.class文件）保存到本地磁盘，我们可以通过把相应的class文件保存到本地，再反编译来看看具体的实现，这样更直观  </span></div><div class="line">        <span class="keyword">if</span>(saveGeneratedFiles) &#123;</div><div class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        FileOutputStream var1 = <span class="keyword">new</span> FileOutputStream(ProxyGenerator.dotToSlash(var0) + <span class="string">".class"</span>);</div><div class="line">                        var1.write(var3);</div><div class="line">                        var1.close();</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var2);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> var3;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中，这个参数的定义是酱紫的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>))).booleanValue();</div></pre></td></tr></table></figure></p>
<p>所以我们可以设置sun.misc.ProxyGenerator.saveGeneratedFiles这个系统属性为true来把生成的class保存到本地文件来查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div></pre></td></tr></table></figure></p>
<p>加上这段代码后执行<code>main</code>会报这样的错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.InternalError: I/O exception saving generated file: java.io.FileNotFoundException: com/sun/proxy/$Proxy0.class (No such file or directory)</div><div class="line">	at sun.misc.ProxyGenerator$1.run(ProxyGenerator.java:336)</div><div class="line">	at sun.misc.ProxyGenerator$1.run(ProxyGenerator.java:327)</div><div class="line">	at java.security.AccessController.doPrivileged(Native Method)</div><div class="line">	at sun.misc.ProxyGenerator.generateProxyClass(ProxyGenerator.java:326)</div><div class="line">	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:671)</div><div class="line">	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:591)</div><div class="line">	at java.lang.reflect.WeakCache$Factory.get(WeakCache.java:244)</div><div class="line">	at java.lang.reflect.WeakCache.get(WeakCache.java:141)</div><div class="line">	at java.lang.reflect.Proxy.getProxyClass0(Proxy.java:454)</div><div class="line">	at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:736)</div><div class="line">	at com.dw.test.JdkProxy.getProxy(JdkProxy.java:45)</div><div class="line">	at com.dw.test.JdkProxyCase.main(JdkProxyCase.java:19)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div></pre></td></tr></table></figure></p>
<p>解决办法是在工程根路径下创建com/sun/proxy目录，并创建一个$Proxy0.class文件，才能够正常运行并保存class文件内容。<br>看看反编译后的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Hello</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</div><div class="line">        <span class="keyword">super</span>(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</div><div class="line">            <span class="keyword">throw</span> var3;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="comment">//调用父类的handler的invoke方法 实际上就是调用我们实现InvocationHandler接口的类的invoke 我们的逻辑在这里处理</span></div><div class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</div><div class="line">            <span class="keyword">throw</span> var3;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</div><div class="line">            m3 = Class.forName(<span class="string">"com.dw.service_api.Hello"</span>).getMethod(<span class="string">"sayHello"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</div><div class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>从生成出来的这个类中可以看到</p>
<ol>
<li>这个类继承自<code>Proxy</code>实现了代理接口。所以JDK动态代理只能对接口进行代理，而不能对实现类进行代理。这是Java语言不能多继承导致的。</li>
<li>构造方法的参数是<code>InvocationHandler</code>。这个参数是由我们调用<code>Proxy#newProxyInstance</code>方法传进去的。</li>
<li>重写了Object类的<code>equals</code>、<code>hashCode</code>、<code>toString</code>，它们都只是简单的调用了<code>InvocationHandler</code>的<code>invoke</code>方法，即可以对其进行特殊的操作，也就是说JDK的动态代理还可以代理上述三个方法。<br>从这里可以联想到Spring AOP的机制和这个原理其实是一样的，可能实现会比这个复杂的多。<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5></li>
<li>使用JDK实现动态代理需要实现<code>InvacationHandler</code>接口，使用<code>Proxy#newProxyInstacne</code>返回代理对象。</li>
<li>JDK动态代理的机制是通过在程序运行时动态地去生成字节码文件，然后加载到内存生成实例。</li>
<li>JDK动态代理只能对接口进行代理，不能对实现类代理。因为Java语言不支持多继承。要想对实现类进行代理可以使用Cglib来实现。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近呢，看到了一个开源的PRC FRAMEWORK，当然不是Dubbo。然后想去了解一下RPC到底是怎么去实现的。于是乎就了解了一番，发现其灵魂在于动态代理和反射。
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.mr-dongw.site/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.mr-dongw.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>自定义Spring Schema</title>
    <link href="http://www.mr-dongw.site/2017/07/01/spring%20schema/"/>
    <id>http://www.mr-dongw.site/2017/07/01/spring schema/</id>
    <published>2017-07-01T14:18:23.000Z</published>
    <updated>2017-07-01T14:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="What’s-schema"><a href="#What’s-schema" class="headerlink" title="What’s schema"></a>What’s schema</h5><p>schema中文翻译是概要、计划、图表。这里的schema指的是xml schema，也就是对xml的约束。在xml schema之前，对xml进行约束的是DTD。现在xml schema占据了主流。其中spring framework中xml配置文件就是使用的是xml schema，后缀名为xsd。<br><a id="more"></a> </p>
<h5 id="How-to-define-a-xml-schema"><a href="#How-to-define-a-xml-schema" class="headerlink" title="How to define a xml schema"></a>How to define a xml schema</h5><p>在spring framework中的applicationContext.xml文件中见到最多的就是<code>&lt;bean&gt;</code>标签。有时候想自己也整一个标签满足自己的需求（装逼or真的是需要自己实现）那就得自己去按照spring的标准去实现了，就好比JDK中的SPI机制，要按照JDK的规范去做。Spring是怎么要求的呢？<br>以maven工程为例，在resources目录下的META_INF下需要自己定义一个.xsd文件。这里我定义了一个以dongwei为名的dongwei.xsd文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">"http://www.dongwei.com/schema/dongwei"</span></span></div><div class="line">            <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></div><div class="line">            <span class="attr">xmlns:tool</span>=<span class="string">"http://www.springframework.org/schema/tool"</span></div><div class="line">            <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">            <span class="attr">targetNamespace</span>=<span class="string">"http://www.dongwei.com/schema/dongwei"</span>&gt;</div><div class="line">	<span class="comment">&lt;!-- 这里import有好几个schema 可同时去约束被约束的xml --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.w3.org/XML/1998/namespace"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/tool"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">"beans:identifiedType"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的xsd文件就定义了一个约束。接下来还需要在resources/META_INF下新建两个文件<code>spring.handlers</code>和<code>spring.schemas</code> 内容分别是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.dongwei.com/schema/dongwei=com.hnisi.springscheme.schema.DongweiNamespaceHandler</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.dongwei.com/schema/dongwei/dongwei.xsd=META-INF/dongwei.xsd</div></pre></td></tr></table></figure>
<p>handlers的内容可以是多条，表示对这个标签的处理器。schema表示的是xsd的文件位置，在url不能访问的时候（断网）程序可以去本地找schema。</p>
<h5 id="schema-handlers"><a href="#schema-handlers" class="headerlink" title="schema handlers"></a>schema handlers</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DongweiNamespaceHandler</span>  <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		registerBeanDefinitionParser(<span class="string">"user"</span>, <span class="keyword">new</span> UserBeanDefinitionParser());		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义的handler就是酱紫，需实现父类的<code>init</code>方法。他去调用了<code>registerBeanDefinitionParser</code>去注册标签。第一个参数是标签名，第二个是对这个标签的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanDefinitionParser</span> <span class="keyword">extends</span>  <span class="title">AbstractSingleBeanDefinitionParser</span>  </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</div><div class="line">		String id = element.getAttribute(<span class="string">"id"</span>);</div><div class="line">		String name = element.getAttribute(<span class="string">"name"</span>);</div><div class="line">		</div><div class="line">		builder.addPropertyValue(<span class="string">"id"</span>, id);</div><div class="line">		builder.addPropertyValue(<span class="string">"name"</span>, name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</div><div class="line">		<span class="keyword">return</span> User.class;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个解析器重写了父类的<code>doParse</code>和<code>getBeanClass</code>  其中<code>doParse</code>处理的就是xsd中定义的属性。<br>当然，也不能少了我们要定义的标签bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">	 <span class="keyword">private</span> String id;</div><div class="line">	 <span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">	 </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上这就是一个bean，和在applicationContext.xml中配置的<code>&lt;bean&gt;</code>是一个意思。这样定义标签去处理个人觉得是为了更加灵活，可以在xml文件中去配置bean的属性，想改就改。</p>
<h5 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h5><p>再来看看applicationContext.xml中怎么使用<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </div><div class="line">    xmlns:dongwei="http://www.dongwei.com/schema/dongwei"</div><div class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </div><div class="line">    http://www.dongwei.com/schema/dongwei</div><div class="line">    http://www.dongwei.com/schema/dongwei/dongwei.xsd"&gt;</div><div class="line">    </div><div class="line">    &lt;dongwei:user id="eric" name="123"/&gt;</div><div class="line">    </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>这里的dongwei是namespace。本质上来讲这就是一个bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringSchema</span> </span>&#123;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchame</span><span class="params">()</span></span>&#123;</div><div class="line">		ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</div><div class="line">		User bean = context.getBean(User.class);</div><div class="line">		System.out.println(bean);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Last-summary"><a href="#Last-summary" class="headerlink" title="Last summary"></a>Last summary</h5><p>这是我看到SOA框架的时候发现配置文件中有很多类似<code>&lt;mango:registry protocol=&quot;zookeeper&quot; address=&quot;localhost:2181&quot; connect-timeout=&quot;5000&quot; /&gt;</code>的东西，突然觉得好奇然后去了解了一下。不仅第三方框架中有这样的自定义标签，spring framework也有：<code>&lt;context:annotation-config/&gt;</code> 这和我们最常使用的<code>&lt;bean&gt;</code>长得还是有点不一样的。然后去看了看怎么去自定义一个这样的东西。这只是一个最简单的实现，实际上功能健全的实现是很复杂的。也可以想象spring framework想得还是很周到的，水也很深。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;What’s-schema&quot;&gt;&lt;a href=&quot;#What’s-schema&quot; class=&quot;headerlink&quot; title=&quot;What’s schema&quot;&gt;&lt;/a&gt;What’s schema&lt;/h5&gt;&lt;p&gt;schema中文翻译是概要、计划、图表。这里的schema指的是xml schema，也就是对xml的约束。在xml schema之前，对xml进行约束的是DTD。现在xml schema占据了主流。其中spring framework中xml配置文件就是使用的是xml schema，后缀名为xsd。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Framework" scheme="http://www.mr-dongw.site/categories/Spring-Framework/"/>
    
    
      <category term="Spring" scheme="http://www.mr-dongw.site/tags/Spring/"/>
    
      <category term="XML" scheme="http://www.mr-dongw.site/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JUC系列之BlockingQueue</title>
    <link href="http://www.mr-dongw.site/2017/07/01/juc_LinkedBlockingQueue/"/>
    <id>http://www.mr-dongw.site/2017/07/01/juc_LinkedBlockingQueue/</id>
    <published>2017-07-01T14:16:23.000Z</published>
    <updated>2017-07-01T14:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>JUC是jdk1.5之后一强大的工具包。其中对JAVA的并发做了很好的支持。仔细阅读源码你会发现很多代码的作者是<a href="https://en.wikipedia.org/wiki/Doug_Lea" target="_blank" rel="external">Doug Lea</a>。所以现在开始细细琢磨这位大神的鬼斧神工。<br><a id="more"></a> </p>
<h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个类继承了接口Queue，Queue继承了Collection接口，他们都是亲戚。亲戚关系很庞大，后台很硬。直接实现这个接口的类没多少个：</p>
<ul>
<li>ArrayBlockingQueue </li>
<li>DelayQueue</li>
<li>LinkedBlockingDeque</li>
<li>LinkedBlockingQueue</li>
<li>LinkedTransferQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4>那就拿最简单的实现开刀。顾名思义，这个Queue是基于链表的。看看源码文档是怎么去描述的：<blockquote>
<p>An optionally-bounded blocking queue based on linked nodes. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.<br>这是一个边界可选的基于链表的阻塞队列。这个队列按照先进先出的规则阻止元素。头节点在队列中的时间最长，尾节点在队列时间最短。新添加的元素会被放到尾部，取元素将在队列的头部取。基于链表的队列的吞吐量通常要比基于数组的高，但是在高并发场景下性能没有那么可观。<br>The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to Integer.MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.<br>可选的容量参数是为了防止队列数量膨胀，假设没有去指定这个参数那么将指定为int的最大值。在不超过容量的前提下节点也会在每次插入的时候动态的创建。 </p>
</blockquote>
</li>
</ul>
<p>先看看这个类的内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        E item;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * One of:</div><div class="line">         * - the real successor Node</div><div class="line">         * - this Node, meaning the successor is head.next</div><div class="line">         * - null, meaning there is no successor (this is the last node)</div><div class="line">         */</div><div class="line">        Node&lt;E&gt; next;</div><div class="line"></div><div class="line">        Node(E x) &#123; item = x; &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//省略实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个node内部类以及一个itr的实现，非常简单。在JAVA集合中经常看到内部实现Itr的，见怪不怪了。<br>接下来就开始正餐了，对几个核心方法进行梳理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        E x;</div><div class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">        <span class="comment">//count记录当前队列的元素数量</span></div><div class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">        takeLock.lockInterruptibly();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="comment">//当当前元素的数量为0的时候线程阻塞 直到接到通知队列有元素了才继续执行</span></div><div class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</div><div class="line">                notEmpty.await();</div><div class="line">            &#125;</div><div class="line">            x = dequeue();</div><div class="line">            <span class="comment">//头节点出队了 元素数量减去1 返回值为减1前的值 如果队列元素为1出队后队列没元素了c依旧为1</span></div><div class="line">            c = count.getAndDecrement();</div><div class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">	            <span class="comment">//如果队列中还有元素 那么通知阻塞的线程可以取了</span></div><div class="line">                notEmpty.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            takeLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (c == capacity)</div><div class="line">	        <span class="comment">//这个判断很有意思，想了好久。</span></div><div class="line">	        <span class="comment">//这种情况什么时候发生呢？当向队列中添加元素 队列容量有限比如说10个 我添加了20个 那么线程会阻塞掉，线程被阻塞了必须由别的线程来唤醒不能自己唤醒自己。当某个线程执行take的时候，第一次进来这个方法出队了一个元素 这时候c的值依旧是10（返回的是旧值）那么就执行这个操作了：将入队的阻塞线程唤醒 这时候剩下的10个元素可以继续往队列中送了（只能再送一个，因为满了依旧会阻塞）。原则只有一个：满了就通知。这个画面就容易想到了：我出一个你才能进一个，不存在我先出2个你再补2个进来的，必须是轮换的来，一人一下。</span></div><div class="line">            signalNotFull();</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>自己写了个小示例程序来控制出队和入队，写出来方便理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueCase</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">3</span>);</div><div class="line"></div><div class="line">        Thread put = <span class="keyword">new</span> Thread(<span class="keyword">new</span> F(queue));</div><div class="line">        put.start();</div><div class="line"></div><div class="line">        Thread take = <span class="keyword">new</span> Thread(<span class="keyword">new</span> T(queue));</div><div class="line">        take.start();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">F</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    queue.put(<span class="string">""</span>+i);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                System.out.println(<span class="string">"请输入要取出的数量："</span>);</div><div class="line">                <span class="keyword">int</span> t = scanner.nextInt();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        String take = queue.take();</div><div class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"取出了元素："</span>+take);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个小DEMO中有2个线程，分别去对阻塞队列存元素和取元素。阻塞队列容量我只给了3个，在存元素的线程中给了10个元素让它去入队，那么在存到第四个的时候这个线程就阻塞了，直到其他线程被唤醒。而出队线程呢会接受一个数，这个数代表着从队列中要出的元素数量。当输入为10 ，则队列中元素全部被打印出来了。这个过程这样描述：线程的执行是没有先后的（一般情况），因为出队线程中有接受控制台输入，会被阻塞。入队线程一定会执行到将10个元素中的3个放入队列（塞满了，容量只有3），这时候两个线程都被阻塞掉了。当控制台接受输入了，出队线程执行到<code>take</code>方法，进行出队操作，执行到<code>if (c == capacity)</code>的时候唤醒入队线程可以继续执行。也就是说每次去调用<code>take</code>方法出队的时候都会去检查队列有没有满，满了就通知被阻塞的线程可以往队列中添加元素了（也只有队列满了才会被阻塞掉）。<br>在看看入队的方法<code>put</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></div><div class="line">        <span class="comment">// holding count negative to indicate failure unless set.</span></div><div class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node(e);</div><div class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">        putLock.lockInterruptibly();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * Note that count is used in wait guard even though it is</div><div class="line">             * not protected by lock. This works because count can</div><div class="line">             * only decrease at this point (all other puts are shut</div><div class="line">             * out by lock), and we (or some other waiting put) are</div><div class="line">             * signalled if it ever changes from capacity. Similarly</div><div class="line">             * for all other uses of count in other wait guards.</div><div class="line">             */</div><div class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">                notFull.await();</div><div class="line">            &#125;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            <span class="comment">//如果入队一个元素队列还有位置的话唤醒被阻塞的线程可以往队列中添加元素了</span></div><div class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//只有第一次put的时候才会执行这段代码 队列初始化的时候没有元素 count为0 第一次执行put虽然加1了但是返回的是旧值0 这时候队列中有一个元素 通知因为队列为空的出队线程可以取元素了</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            signalNotEmpty();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中还有很多其他的出队入队方法类似<code>offer</code> <code>peek</code>等就不一一说明了，其中的原理都是一样的。只不过有些方法不是阻塞的，出队的时候队空了就返回false或者null或者抛异常，入队同理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，关于JUC中的<code>BlockingQueue</code>的一个实现 <code>LinkedBlockingQueue</code>主要内容就到此为止，其中很多JUC的东西还是很值得去深入琢磨的。比方说<code>ReentrantLock</code>。对于并发编程这一块，还有很多东西需要去学习的。我想说这里面水太深了，这个行业真的是要求无时无刻去学习！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JUC是jdk1.5之后一强大的工具包。其中对JAVA的并发做了很好的支持。仔细阅读源码你会发现很多代码的作者是&lt;a href=&quot;https://en.wikipedia.org/wiki/Doug_Lea&quot;&gt;Doug Lea&lt;/a&gt;。所以现在开始细细琢磨这位大神的鬼斧神工。&lt;br&gt;
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.mr-dongw.site/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.mr-dongw.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JUC之CyclicBarrier</title>
    <link href="http://www.mr-dongw.site/2017/07/01/juc_CyclicBarrier/"/>
    <id>http://www.mr-dongw.site/2017/07/01/juc_CyclicBarrier/</id>
    <published>2017-07-01T14:14:41.000Z</published>
    <updated>2017-07-01T14:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>从这个名字来理解这个东西叫做循环栅栏。也许这样翻译很生硬，但是具体什么意思大概可以很清楚地明白了。</p>
<blockquote>
<p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.<br><a id="more"></a><br>JDK文档的解释是这样的：CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。<br>看个DEMO先：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest1 &#123;</div><div class="line"></div><div class="line">    private static int SIZE = 5;</div><div class="line">    private static CyclicBarrier cb;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        cb = new CyclicBarrier(SIZE);</div><div class="line"></div><div class="line">        // 新建5个任务</div><div class="line">        for(int i=0; i&lt;SIZE; i++)</div><div class="line">            new InnerThread().start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class InnerThread extends Thread&#123;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;);</div><div class="line"></div><div class="line">                // 将cb的参与者数量加1</div><div class="line">                cb.await();</div><div class="line"></div><div class="line">                // cb的参与者数量等于5时，才继续往后执行</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;);</div><div class="line">            &#125; catch (BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>执行结果：<br><code>Thread-1 wait for CyclicBarrier.
Thread-2 wait for CyclicBarrier.
Thread-3 wait for CyclicBarrier.
Thread-4 wait for CyclicBarrier.
Thread-0 wait for CyclicBarrier.
Thread-0 continued.
Thread-4 continued.
Thread-2 continued.
Thread-3 continued.
Thread-1 continued.</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从这个名字来理解这个东西叫做循环栅栏。也许这样翻译很生硬，但是具体什么意思大概可以很清楚地明白了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.&lt;br&gt;
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.mr-dongw.site/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.mr-dongw.site/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>XMPP Server Vysper （Ⅰ）</title>
    <link href="http://www.mr-dongw.site/2017/05/20/xmpp-vysper-1-md/"/>
    <id>http://www.mr-dongw.site/2017/05/20/xmpp-vysper-1-md/</id>
    <published>2017-05-20T10:40:04.000Z</published>
    <updated>2017-05-20T10:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在嘀嗒清单里列出了许多计划。有阅读计划，有学习计划，还有其他的计划。其中阅读计划里就包括应用层协议，类似HTTP协议，MQTT，XMPP等。阅读协议最重要的目的就是理解设计者设计的初衷和思想。个人认为这些思想远远比实现的手段有趣。很崇拜那些定制协议的人，以及定制标准的那些巨头，例如Google等。<a id="more"></a>去看那些草案，RFC文档是一件很枯燥的事情，拿一个标准实现对着文档来分析可以让这个过程变得有趣的多。之前读过FTP的协议，看着看着就看不下去了。虽然没多少内容，但是要去读下去实在是索然无味。于是拿了一个标准实现去分析，FtpServer就是一个很简单的入门。现在开始去了解XMPP，于是拿了一个开源server Vysper来学习。 </p>
<h1 id="XMPP"><a href="#XMPP" class="headerlink" title="XMPP"></a>XMPP</h1><p>第一个x代表的是Extensible，m代表的是Messageing，第一个p是Presence。这个协议的前生是Jabber，具体的没有去研究。这个协议是基于XML的，也就是通过XML格式去传输数据。其实我觉得，应用层的协议无非两种传输方式，基于文本和基于二进制。本质上来说都是基于二进制：对于计算机而言所有的数据全是0101，没什么毛病。HTTP就是基于文本，普通人都能去阅读HTTP里的数据。而XMPP是基于XML，也就是基于文本。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于一个陌生的协议，又没耐心去看RFC文档（主要是看不懂英文），怎么去了解这个协议是怎么工作的呢？我的理解就是自己去抓包看内容。类比HTTP可以通过浏览器去查看请求头以及各种属性，同样的XMPP一样也可以通过抓包分析其指令及数据格式。首先去APACHE将Vysper下载下来（dist和src）然后自己本地将服务器跑起来。找几个XMPP客户端相互通信通过抓包工具来将XMPP协议的过滤出来，对每条请求和响应具体分析。ok，整个思路就是这样了。抓包工具使用wireshark很方便。客户端有很多，pc上使用spark（win），aduim（mac）；手机上使用bruno。openfire也是一个很不错的服务器，提供web管理页面，使用起来很方便。</p>
<h1 id="Vysper"><a href="#Vysper" class="headerlink" title="Vysper"></a>Vysper</h1><p>Vysper的发音和Whisper是一样的，是悄悄话的意思。在apache的vysper官方文档中它实现的标准是 RFC3920（现在的标准是RFC6120，具体可见<a href="http://wiki.jabbercn.org/RFC6120" target="_blank" rel="external">RFC6120</a>）和 RFC3921（只实现了80%）。其他的都是些拓展协议了。根据文档介绍，vysper的结构分为三部分：<a href="http://mina.apache.org/vysper-project/xml_processing.html" target="_blank" rel="external">XML Processing</a>、<a href="http://mina.apache.org/vysper-project/stanza_processing_layer.html" target="_blank" rel="external">Stanza Processing</a>和<a href="http://mina.apache.org/vysper-project/user_mgmt.html" target="_blank" rel="external">User Management</a>.<br>目前最新的版本是0.7，打开下载的源码，其对应的模块有这几个部分：dist、examples、nbxml、server和speccompliance。其中server下又有好几个模块。</p>
<h2 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h2><p>通过名字可以看出来是用来打包发布的。因为vysper是用maven管理的，这个模块将其他的模块引入进来，通过配置生成启动脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.0&lt;/version&gt;</div><div class="line">        &lt;configuration&gt;</div><div class="line">          &lt;includeConfigurationDirectoryInClasspath&gt;true&lt;/includeConfigurationDirectoryInClasspath&gt;</div><div class="line">          &lt;configurationDirectory&gt;config&lt;/configurationDirectory&gt;</div><div class="line">          &lt;target&gt;$&#123;project.build.directory&#125;/appassembler&lt;/target&gt;</div><div class="line">          &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;</div><div class="line">		  &lt;repositoryName&gt;lib&lt;/repositoryName&gt;</div><div class="line">          &lt;environmentSetupFileName&gt;setenv&lt;/environmentSetupFileName&gt;</div><div class="line">          &lt;!-- Generate bin scripts for windows and unix per default --&gt;</div><div class="line">          &lt;platforms&gt;</div><div class="line">            &lt;platform&gt;windows&lt;/platform&gt;</div><div class="line">            &lt;platform&gt;unix&lt;/platform&gt;</div><div class="line">          &lt;/platforms&gt;</div><div class="line">          &lt;programs&gt;</div><div class="line">            &lt;program&gt;</div><div class="line">              &lt;mainClass&gt;org.apache.vysper.spring.ServerMain&lt;/mainClass&gt;</div><div class="line">              &lt;!-- call it only run because appassemble will add .bat by default on windows --&gt;              </div><div class="line">              &lt;name&gt;run&lt;/name&gt;</div><div class="line">              &lt;!-- Only generate windows bat script for this application --&gt;</div><div class="line">              &lt;platforms&gt;</div><div class="line">                &lt;platform&gt;windows&lt;/platform&gt;</div><div class="line">              &lt;/platforms&gt;</div><div class="line">            &lt;/program&gt;</div><div class="line">            &lt;program&gt;</div><div class="line">              &lt;mainClass&gt;org.apache.vysper.spring.ServerMain&lt;/mainClass&gt;</div><div class="line">              &lt;name&gt;run.sh&lt;/name&gt;</div><div class="line">              &lt;!-- Only generate unix shell script for this application --&gt;</div><div class="line">              &lt;platforms&gt;</div><div class="line">             &lt;platform&gt;unix&lt;/platform&gt;</div><div class="line">              &lt;/platforms&gt;</div><div class="line">            &lt;/program&gt;</div><div class="line">          &lt;/programs&gt;</div><div class="line">        &lt;/configuration&gt;</div><div class="line">        &lt;executions&gt;</div><div class="line">          &lt;execution&gt;</div><div class="line">          &lt;id&gt;make-appassemble&lt;/id&gt;</div><div class="line">            &lt;phase&gt;package&lt;/phase&gt;</div><div class="line">            &lt;goals&gt;</div><div class="line">              &lt;goal&gt;assemble&lt;/goal&gt;</div><div class="line">            &lt;/goals&gt;</div><div class="line">          &lt;/execution&gt;</div><div class="line">        &lt;/executions&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><p>这个模块下有两个子模块：embedded-war和pubsub-client.分别是用作嵌入到web容器里和gui客户端的栗子。简言之就是将编译好的server-core拿来调用了一把而已。可以通过jetty或者tomcat启动它都是没问题的。而pubsub-client这个模块则是一个gui的程序，通过pom的配置看到了有smack的引用，具体的后续会慢慢研究。</p>
<h2 id="nbxml"><a href="#nbxml" class="headerlink" title="nbxml"></a>nbxml</h2><p>这个模块很奇怪，名字叫做nbxml。我想这个项目不是外国人写的吗，为何叫牛逼xml。真的是这样吗？并不是的。全名叫做Non-blocking XML，非阻塞的xml解析器。无非就是实现了org.xml.sax 的一些接口而已。自定义了一套解析规则。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>这个模块下有很多子模块。这也是vysper的核心模块了。</p>
<h3 id="admin-config"><a href="#admin-config" class="headerlink" title="admin-config"></a>admin-config</h3><p>这个模块是一个web应用，和openfire的web管理是一样的。其中使用到了velocity和springmvc</p>
<h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p>这个模块最重要的就是对xmpp协议的实现了。当然最重要的还是离不开mina，毕竟是mina的子项目。</p>
<h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p>这个模块也包含很多子模块，每个模块都是对xmpp拓展协议的实现，比如bosh，mcu等。我发现使用maven分模块来管理这种方式真的很聪明。</p>
<h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><p>顾名思义，这个模块是用来存储的。其中有个jcr和hbase。不禁让我想到了hadoop。没错其中真的还引入了hadoop的包。我理解的是这个模块用于文档存储的。具体是存储什么我觉得大概是用户信息，联系人等。openfire使用的是mysql数据库来管理的。具体怎么实现的后续会继续分析。</p>
<h2 id="speccompliance"><a href="#speccompliance" class="headerlink" title="speccompliance"></a>speccompliance</h2><p>这个模块很神秘，我看pom文件中只配置了一个jdk的jar包，这个jar包在1.8中是没有的。当初编译源码的时候还遇到了一点坑，将jdk换为1.7才编译通过。说什么使用了apt的api。具体的是干嘛的可见<a href="http://www.javacui.com/Theory/367.html" target="_blank" rel="external">JDK工具 APT</a>。简单理解就是可以帮我们少写代码。</p>
<h1 id="结尾语"><a href="#结尾语" class="headerlink" title="结尾语"></a>结尾语</h1><p>本文简要介绍了XMPP协议以及如何去学习和分析一个协议如何实现的。通过开源项目Vysper来学习XMPP是一个不错的途径。同时也简单地将Vysper的结构概述了一遍。接下来将会通过分析和调试源代码以及结合阅读RFC文档的方式来学习XMPP协议。<img src="http://7xsfwn.com1.z0.glb.clouddn.com/%E5%87%A4%E5%87%B0%E8%8A%B1.jpg" alt="凤凰花"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;在嘀嗒清单里列出了许多计划。有阅读计划，有学习计划，还有其他的计划。其中阅读计划里就包括应用层协议，类似HTTP协议，MQTT，XMPP等。阅读协议最重要的目的就是理解设计者设计的初衷和思想。个人认为这些思想远远比实现的手段有趣。很崇拜那些定制协议的人，以及定制标准的那些巨头，例如Google等。
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>ftpserver（Ⅳ）</title>
    <link href="http://www.mr-dongw.site/2017/04/10/ftpserver4/"/>
    <id>http://www.mr-dongw.site/2017/04/10/ftpserver4/</id>
    <published>2017-04-10T14:29:59.000Z</published>
    <updated>2017-04-10T14:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天就来谈谈FtpServer中的线程模型，准确来讲是MINA中的线程模型。之前一直关注于FtpServer的实现逻辑，却没去在意NIO底层的这些设计。<br><a id="more"></a><br>先看看我们用MINA简单实现一个server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws IOException &#123;</div><div class="line"></div><div class="line">        SocketAcceptor socketAcceptor = new NioSocketAcceptor();</div><div class="line"></div><div class="line">        //加上一个编码过滤器，不然客户端输入的什么服务端看到的都是buf</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new MyCodecFactory()));</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;log&quot;, new LoggingFilter());</div><div class="line"></div><div class="line">        socketAcceptor.setHandler(new MyHandler());</div><div class="line"></div><div class="line">        socketAcceptor.bind(new InetSocketAddress(&quot;localhost&quot;,9090));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中只加入了log过滤器和编码过滤器，实际上什么都不加也是可以完成启动服务器监听的。然后启动服务器我们用telnet命令去连接它，多用几个命令窗口去连接，在控制台上可以看到这样的  </p>
<blockquote>
<p>[NioProcessor-2][FTP]21:31:35,053 INFO [LoggingFilter.log]:186 - CREATED<br>created<br>[NioProcessor-2][FTP]21:31:35,058 INFO [LoggingFilter.log]:186 - OPENED</p>
</blockquote>
<p>这里我们设置了日志的格式，将最前面的置为当前线程的名称。我们再启动一个客户端去连接：</p>
<blockquote>
<p>[NioProcessor-3][FTP]21:33:14,655 DEBUG [ProtocolCodecFilter.messageReceived]:211 - Processing a MESSAGE_RECEIVED for session 2<br>[NioProcessor-3][FTP]21:33:14,657 INFO [LoggingFilter.log]:157 - RECEIVED: dada  </p>
</blockquote>
<p>很明显可以看到NioProcessor变了。如此往复，不断去启动命令行客户端去连，会发现NioProcessor后的编号只会从1到5。也许你会觉得奇怪，难道用于处理连接的线程数只有5个吗？没错，如果不对其进行设置默认就是这么多个：cpu核数加1个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/** The default pool size, when no size is provided. */</div><div class="line">private static final int DEFAULT_SIZE = Runtime.getRuntime().availableProcessors() + 1;</div></pre></td></tr></table></figure></p>
<p>这就可以聊到MINA中的线程模型了。它用于处理IO用NioProcessor来，处理handler用其他的线程来。到底怎么去用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws IOException &#123;</div><div class="line"></div><div class="line">        SocketAcceptor socketAcceptor = new NioSocketAcceptor();</div><div class="line"></div><div class="line">        //加上一个编码过滤器，不然客户端输入的什么服务端看到的都是buf</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;codec&quot;, new ProtocolCodecFilter(new MyCodecFactory()));</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;log&quot;, new LoggingFilter());</div><div class="line">        //添加Executor过滤器，让其线程池处理业务逻辑</div><div class="line">        socketAcceptor.getFilterChain().addLast(&quot;threadPool&quot;, new ExecutorFilter(Executors.newCachedThreadPool()));</div><div class="line"></div><div class="line">        socketAcceptor.setHandler(new MyHandler());</div><div class="line"></div><div class="line">        socketAcceptor.bind(new InetSocketAddress(&quot;localhost&quot;,9090));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这时候再启动telnet客户端去访问服务器，控制台下打印的就是这样了：</p>
<blockquote>
<p>[pool-3-thread-1][FTP]21:51:41,436 DEBUG [IoFilterEvent.fire]:117 - Event MESSAGE_RECEIVED has been fired for session 1</p>
</blockquote>
<p>因此验证了业务逻辑的处理线程不再又那可怜巴巴的只有5个处理IO连接的来分担了，而是由额外的线程来处理，至于这些线程是否和处理IO线程来自同一个线程池我没有仔细去研究。同时，这里还有一个线程值得关注：NioSocketAcceptor-1（使用jvisualvm可以看到所有线程）这个用于监听所有连接事件，只有一个。其中涉及到了什么selector模型什么的就不继续深入了。事件到达后将其封装成IoSession丢给IoProcessor处理，然后继续站岗监听，啥子都不管了，就做这一件事情。<br>这让我不禁想到一个问题，NIo模型中没有对每个连接开辟线程去处理，只用一个线程去响应连接事件，后续的都交给其他线程去处理，那么如果连接的数量很多，岂不是也需要很多线程去处理这些请求了？优势又在哪里呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天就来谈谈FtpServer中的线程模型，准确来讲是MINA中的线程模型。之前一直关注于FtpServer的实现逻辑，却没去在意NIO底层的这些设计。&lt;br&gt;
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>牢骚一篇</title>
    <link href="http://www.mr-dongw.site/2017/04/09/%E7%89%A2%E9%AA%9A%E4%B8%80%E7%AF%87/"/>
    <id>http://www.mr-dongw.site/2017/04/09/牢骚一篇/</id>
    <published>2017-04-09T03:56:18.000Z</published>
    <updated>2017-04-09T03:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>生活不仅有眼前的苟且，还有诗和远。</p>
</blockquote>
<p>在以前看到这句话的时候，觉得写得真好，给人一种特积极向上的正能量。<a id="more"></a>现在看来无非就是一种自我欺骗。或许改为“生活不仅有眼前的苟且，还有明天和后天的苟且”会更加贴近我现在的生活状态。<br>最近陷入了一种焦虑状态，每天都很担心害怕，但是也不知道具体是在担心害怕什么。具体表现就是周末担心周一，平时担心下班要加班，每天都战战兢兢的，只期望早点过完这一天。周末又担心下周一要忙的事。真是非常难受，负能量满满。<br>具体说来我觉得还是对现状不是很满意，渴望改变！<br>其实脑袋里就是一片混浊，自己到底想要什么都没搞明白，对周围的人和事真的是一点都不关心，我觉得我活在自己的封闭的世界里，找不到出路。最直观的感受就是对很多事情都没有什么兴趣了，以前还想着怎么出去走走，去旅行，去别的地方看看。现在完全没有这样的想法。以前还会想着怎么去遇见那些有趣的人，怎么和他们做朋友，现在觉得自己一个人安安静静呆着挺好的。也不愿意去主动联系一些人了，也不会主动去分享自己的生活了，每天都是天昏地暗的稀里糊涂的在过着操蛋的日子。不知道还要过多久我才会被这种生活给麻痹，然后失去知觉变成一只如同行尸走肉的僵尸一般苟活于世。<br>我觉得我依旧没变，至少内心的想法没有变，我每天都在想着改变，摆脱现在的羁绊，努力去最求自己内心所想的东西，努力去成为最想成为的人，一步一步走下去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;生活不仅有眼前的苟且，还有诗和远。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以前看到这句话的时候，觉得写得真好，给人一种特积极向上的正能量。
    
    </summary>
    
      <category term="想法" scheme="http://www.mr-dongw.site/categories/%E6%83%B3%E6%B3%95/"/>
    
    
      <category term="生活，扯淡" scheme="http://www.mr-dongw.site/tags/%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title>ftpserver(Ⅲ)</title>
    <link href="http://www.mr-dongw.site/2017/04/04/ftpserver3/"/>
    <id>http://www.mr-dongw.site/2017/04/04/ftpserver3/</id>
    <published>2017-04-04T03:09:41.000Z</published>
    <updated>2017-04-04T03:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章来解读ftpserver中的核心组件–FtpServerContext<br>在很多类中都有看到这个东西，顾名思义就是上下文。根据以往的在java web中的servlet context的理解，字面意思就是上下文。<a id="more"></a>我觉得这个翻译不是很好，通过字面意思真的很难去理解这个“上下文”是什么。反而久而久之懂其中的含义了，却难以用语言描述出来。所以说翻译不准确很害人啊。最简单粗暴的方法就是去看文档注释，拒绝二手解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * This is basically &lt;code&gt;org.apache.ftpserver.ftplet.FtpletContext&lt;/code&gt; with</div><div class="line"> * added connection manager, message resource functionalities.</div><div class="line"> *</div><div class="line"> */</div><div class="line">public interface FtpServerContext extends FtpletContext &#123;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * </div><div class="line"> * FTP server configuration implementation. It holds all the components used.</div><div class="line"> */</div><div class="line">public class DefaultFtpServerContext implements FtpServerContext &#123;</div></pre></td></tr></table></figure>
<p>看了文档的注释就很容易去读懂这个”context”是什么玩意儿了。无非就是一些配置而已。“上下文”也可以解释为“运行环境”吧。我个人理解是这个程序在跑的过程中的所需要的材料。类比servlet中，通过上下文可以拿到request、response对象。那也就可以说req、resp是属于servlet运行的材料。<br>FtpServerContext是一个接口，默认实现类是DefaultFtpServerContext：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public class DefaultFtpServerContext implements FtpServerContext &#123;</div><div class="line"></div><div class="line">    private final Logger LOG = LoggerFactory</div><div class="line">            .getLogger(DefaultFtpServerContext.class);</div><div class="line"></div><div class="line">    private MessageResource messageResource = new MessageResourceFactory().createMessageResource();</div><div class="line"></div><div class="line">    private UserManager userManager = new PropertiesUserManagerFactory().createUserManager();</div><div class="line"></div><div class="line">    private FileSystemFactory fileSystemManager = new NativeFileSystemFactory();</div><div class="line"></div><div class="line">    private FtpletContainer ftpletContainer = new DefaultFtpletContainer();</div><div class="line"></div><div class="line">    private FtpStatistics statistics = new DefaultFtpStatistics();</div><div class="line"></div><div class="line">    private CommandFactory commandFactory = new CommandFactoryFactory().createCommandFactory();</div><div class="line"></div><div class="line">    private ConnectionConfig connectionConfig = new ConnectionConfigFactory().createConnectionConfig();</div><div class="line"></div><div class="line">    private Map&lt;String, Listener&gt; listeners = new HashMap&lt;String, Listener&gt;();</div><div class="line"></div><div class="line">    private static final List&lt;Authority&gt; ADMIN_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div><div class="line">    private static final List&lt;Authority&gt; ANON_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * The thread pool executor to be used by the server using this context</div><div class="line">     */</div><div class="line">    private ThreadPoolExecutor threadPoolExecutor = null;</div><div class="line">    </div><div class="line">    static &#123;</div><div class="line">        ADMIN_AUTHORITIES.add(new WritePermission());</div><div class="line">        </div><div class="line">        ANON_AUTHORITIES.add(new ConcurrentLoginPermission(20, 2));</div><div class="line">        ANON_AUTHORITIES.add(new TransferRatePermission(4800, 4800));</div><div class="line">    &#125;</div><div class="line">    //...省略...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类中包含了有很多成员变量，有消息资源的MessageResource，这个主要是用于读取ftpserver中配置的资源，类似于ftp响应502对应的文字描述这样的。并没有将这些东西硬编码，而是抽象成资源，通过文本文件去配置。UserManager用于对用户的管理，比方说哪些用户有访问的权限等。FileSystemFactory是管理文件的，不同用户的权限可能是不同的，看到的目录也有可能是不同的。FtpletContainer这个说不清楚，暂时别去管这个，后面再说。FtpStatistics这个类主要是记录各种数据，比如当前连接数，登录用户数等。CommandFactory这个很容易说了，命令工厂，上篇文章中说到根据客户端指令不同创建各种命令实例来分别处理。ConnectionConfig用于对socket的连接管理。<br>除了这些还有一个map和2个list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private Map&lt;String, Listener&gt; listeners = new HashMap&lt;String, Listener&gt;();</div><div class="line">private static final List&lt;Authority&gt; ADMIN_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div><div class="line">private static final List&lt;Authority&gt; ANON_AUTHORITIES = new ArrayList&lt;Authority&gt;();</div></pre></td></tr></table></figure></p>
<p>listeners在context初始化的时候放进去一个default的listener，也就是NioListener的实例。只是通过工厂方式去创建的。而其他2个list则是用来装admin的权限和anon的权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line">        ADMIN_AUTHORITIES.add(new WritePermission());</div><div class="line">        </div><div class="line">        ANON_AUTHORITIES.add(new ConcurrentLoginPermission(20, 2));</div><div class="line">        ANON_AUTHORITIES.add(new TransferRatePermission(4800, 4800));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在类装载的时候就将权限加进去了，admin有写权限，anon有并发登录权限，其中还对anon进行了一个传输速率的配置。<br>至此，这个“神秘”的context就基本上梳理完了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇文章来解读ftpserver中的核心组件–FtpServerContext&lt;br&gt;在很多类中都有看到这个东西，顾名思义就是上下文。根据以往的在java web中的servlet context的理解，字面意思就是上下文。
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>FtpServer(Ⅱ)</title>
    <link href="http://www.mr-dongw.site/2017/03/26/ftpserver2-md/"/>
    <id>http://www.mr-dongw.site/2017/03/26/ftpserver2-md/</id>
    <published>2017-03-26T08:27:41.000Z</published>
    <updated>2017-03-26T08:36:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>有了之前的总体小窥后，现在开始细细把玩其中的深邃之处了。<br>其中可以看到有不少的factory，比如FtpServerFactory、ListenerFactory等。通过名字可以看得出来，这些都是用来产生实例的工厂。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public Listener createListener() &#123;</div><div class="line">        try &#123;</div><div class="line">            InetAddress.getByName(serverAddress);</div><div class="line">        &#125; catch (UnknownHostException e) &#123;</div><div class="line">            throw new FtpServerConfigurationException(&quot;Unknown host&quot;, e);</div><div class="line">        &#125;</div><div class="line">        // Deal with the old style black list and new session Filter here.</div><div class="line">        if (sessionFilter != null) &#123;</div><div class="line">            if (blockedAddresses != null || blockedSubnets != null) &#123;</div><div class="line">                throw new IllegalStateException(</div><div class="line">                        &quot;Usage of SessionFilter in combination with blockedAddesses/subnets is not supported. &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (blockedAddresses != null || blockedSubnets != null) &#123;</div><div class="line">            return new NioListener(serverAddress, port, implicitSsl, ssl,</div><div class="line">                    dataConnectionConfig, idleTimeout, blockedAddresses,</div><div class="line">                    blockedSubnets);</div><div class="line">        &#125; else &#123;</div><div class="line">            return new NioListener(serverAddress, port, implicitSsl, ssl,</div><div class="line">                    dataConnectionConfig, idleTimeout, sessionFilter);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个listenerfactory通过createListener创建listener。同理serverFactory也是一样。<br>先看看listener工场有哪些成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private String serverAddress;</div><div class="line">    //端口默认是21，本地部署会有权限冲突</div><div class="line">    private int port = 21;</div><div class="line">    //加密配置，暂时不管</div><div class="line">    private SslConfiguration ssl;</div><div class="line"></div><div class="line">    private boolean implicitSsl = false;</div><div class="line"></div><div class="line">    private DataConnectionConfiguration dataConnectionConfig = new DataConnectionConfigurationFactory()</div><div class="line">            .createDataConnectionConfiguration();</div><div class="line"></div><div class="line">    private int idleTimeout = 300;</div><div class="line">    //黑名单</div><div class="line">    private List&lt;InetAddress&gt; blockedAddresses;</div><div class="line">    private List&lt;Subnet&gt; blockedSubnets;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * The Session filter</div><div class="line">     * 过滤器</div><div class="line">     */</div><div class="line">    private SessionFilter sessionFilter = null;</div></pre></td></tr></table></figure></p>
<p>最重要的还是哪个createListener方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">return new NioListener(serverAddress, port, implicitSsl, ssl,</div><div class="line">                    dataConnectionConfig, idleTimeout, sessionFilter);</div></pre></td></tr></table></figure></p>
<p>最后返回的是一个NioListener。这个工厂只创建Niolistener。<br>具体到NioListener就涉及到MINA了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class NioListener extends AbstractListener</div></pre></td></tr></table></figure></p>
<p>这里有个重要的接口就是Listener，AbstractListener实现了这个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void start(FtpServerContext serverContext);</div><div class="line">void stop();</div><div class="line">boolean isStopped();</div><div class="line">void suspend();</div><div class="line">void resume();</div><div class="line">boolean isSuspended();</div><div class="line">Set&lt;FtpIoSession&gt; getActiveSessions();</div><div class="line">boolean isImplicitSsl();</div><div class="line">SslConfiguration getSslConfiguration();</div><div class="line">int getPort();</div><div class="line">String getServerAddress();</div><div class="line">DataConnectionConfiguration getDataConnectionConfiguration();</div><div class="line">int getIdleTimeout();</div><div class="line">@Deprecated</div><div class="line">List&lt;InetAddress&gt; getBlockedAddresses();</div><div class="line"></div><div class="line">@Deprecated</div><div class="line">List&lt;Subnet&gt; getBlockedSubnets();</div><div class="line"></div><div class="line"></div><div class="line">SessionFilter getSessionFilter();</div></pre></td></tr></table></figure></p>
<p>无非就是定义了一些关于服务器监听状态的控制。<br>再看看Niolistenre中的核心方法start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public synchronized void start(FtpServerContext context) &#123;</div><div class="line">        if(!isStopped()) &#123;</div><div class="line">            // listener already started, don&apos;t allow</div><div class="line">            throw new IllegalStateException(&quot;Listener already started&quot;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        try &#123;</div><div class="line">            </div><div class="line">            this.context = context;</div><div class="line"></div><div class="line">            //创建一个acceptor，用来监听连接</div><div class="line">            acceptor = new NioSocketAcceptor(Runtime.getRuntime()</div><div class="line">                    .availableProcessors());</div><div class="line">    </div><div class="line">            if (getServerAddress() != null) &#123;</div><div class="line">                address = new InetSocketAddress(getServerAddress(), getPort());</div><div class="line">            &#125; else &#123;</div><div class="line">                address = new InetSocketAddress(getPort());</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            acceptor.setReuseAddress(true);</div><div class="line">            acceptor.getSessionConfig().setReadBufferSize(2048);</div><div class="line">            acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE,</div><div class="line">                    getIdleTimeout());</div><div class="line">            // Decrease the default receiver buffer size</div><div class="line">            acceptor.getSessionConfig().setReceiveBufferSize(512);</div><div class="line">    </div><div class="line">            MdcInjectionFilter mdcFilter = new MdcInjectionFilter();</div><div class="line"></div><div class="line">            //添加一系列过滤器链</div><div class="line">            acceptor.getFilterChain().addLast(&quot;mdcFilter&quot;, mdcFilter);</div><div class="line"></div><div class="line">            SessionFilter sessionFilter = getSessionFilter();</div><div class="line">            if (sessionFilter != null) &#123;</div><div class="line">                // add and IP filter to the filter chain.</div><div class="line">                acceptor.getFilterChain().addLast(&quot;sessionFilter&quot;,</div><div class="line">                        new MinaSessionFilter(sessionFilter));</div><div class="line">            &#125;</div><div class="line">    </div><div class="line">            acceptor.getFilterChain().addLast(&quot;threadPool&quot;,</div><div class="line">                    new ExecutorFilter(context.getThreadPoolExecutor()));</div><div class="line">            acceptor.getFilterChain().addLast(&quot;codec&quot;,</div><div class="line">                    new ProtocolCodecFilter(new FtpServerProtocolCodecFactory()));</div><div class="line">            acceptor.getFilterChain().addLast(&quot;mdcFilter2&quot;, mdcFilter);</div><div class="line">            acceptor.getFilterChain().addLast(&quot;logger&quot;, new FtpLoggingFilter());</div><div class="line"></div><div class="line">            //对ssl的支持</div><div class="line">            if (isImplicitSsl()) &#123;</div><div class="line">                SslConfiguration ssl = getSslConfiguration();</div><div class="line">                SslFilter sslFilter;</div><div class="line">                try &#123;</div><div class="line">                    sslFilter = new SslFilter(ssl.getSSLContext());</div><div class="line">                &#125; catch (GeneralSecurityException e) &#123;</div><div class="line">                    throw new FtpServerConfigurationException(&quot;SSL could not be initialized, check configuration&quot;);</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                if (ssl.getClientAuth() == ClientAuth.NEED) &#123;</div><div class="line">                    sslFilter.setNeedClientAuth(true);</div><div class="line">                &#125; else if (ssl.getClientAuth() == ClientAuth.WANT) &#123;</div><div class="line">                    sslFilter.setWantClientAuth(true);</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                if (ssl.getEnabledCipherSuites() != null) &#123;</div><div class="line">                    sslFilter.setEnabledCipherSuites(ssl.getEnabledCipherSuites());</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">                acceptor.getFilterChain().addFirst(&quot;sslFilter&quot;, sslFilter);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //这里才是正真的核心了，用于处理消息事件</div><div class="line">            handler.init(context, this);</div><div class="line">            acceptor.setHandler(new FtpHandlerAdapter(context, handler));</div><div class="line">    </div><div class="line">            try &#123;</div><div class="line">                //绑定地址端口，然后就开始监听事件了</div><div class="line">                acceptor.bind(address);</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                throw new FtpServerConfigurationException(&quot;Failed to bind to address &quot; + address + &quot;, check configuration&quot;, e);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            updatePort();</div><div class="line">    </div><div class="line">        &#125; catch(RuntimeException e) &#123;</div><div class="line">            // clean up if we fail to start</div><div class="line">            stop();</div><div class="line">            </div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中使用到的MINA的类NioSocketAcceptor用于创建一个socket监听，说白了就是启动服务器。除了比较关键的filter之外就属handler了。<br>看看其中的一个codec过滤器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class FtpServerProtocolCodecFactory implements ProtocolCodecFactory &#123;</div><div class="line">    private final ProtocolDecoder decoder = new TextLineDecoder(Charset</div><div class="line">            .forName(&quot;UTF-8&quot;));</div><div class="line"></div><div class="line">    private final ProtocolEncoder encoder = new FtpResponseEncoder();</div><div class="line"></div><div class="line">    public ProtocolDecoder getDecoder(IoSession session) throws Exception &#123;</div><div class="line">        return decoder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ProtocolEncoder getEncoder(IoSession session) throws Exception &#123;</div><div class="line">        return encoder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>decode是解码，encode是编码。所谓解码就是服务器相对客户端来说，客户输入的东西我们来解析，相反我们服务器传给客户端的就叫编码了。可以看到，解码使用的是MINA默认的文本解码器，ftp客户端输入的也只是一些文本命令罢了。我们服务端的编码则自己定义了一个FtpResponseEncoder：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class FtpResponseEncoder extends ProtocolEncoderAdapter &#123;</div><div class="line">    private static final CharsetEncoder ENCODER = Charset.forName(&quot;UTF-8&quot;)</div><div class="line">            .newEncoder();</div><div class="line"></div><div class="line">    public void encode(IoSession session, Object message,</div><div class="line">            ProtocolEncoderOutput out) throws Exception &#123;</div><div class="line">        String value = message.toString();</div><div class="line"></div><div class="line">        IoBuffer buf = IoBuffer.allocate(value.length()).setAutoExpand(true);</div><div class="line"></div><div class="line">        buf.putString(value, ENCODER);</div><div class="line"></div><div class="line">        buf.flip();</div><div class="line">        out.write(buf);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我个人觉得这个实现和MINA中的TextLineEncoder实现区别不是很大，为什么要自己定义一个这样的实现？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception &#123;</div><div class="line">        CharsetEncoder encoder = (CharsetEncoder) session.getAttribute(ENCODER);</div><div class="line"></div><div class="line">        if (encoder == null) &#123;</div><div class="line">            encoder = charset.newEncoder();</div><div class="line">            session.setAttribute(ENCODER, encoder);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String value = (message == null ? &quot;&quot; : message.toString());</div><div class="line">        IoBuffer buf = IoBuffer.allocate(value.length()).setAutoExpand(true);</div><div class="line">        buf.putString(value, encoder);</div><div class="line"></div><div class="line">        if (buf.position() &gt; maxLineLength) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Line length: &quot; + buf.position());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buf.putString(delimiter.getValue(), encoder);</div><div class="line">        buf.flip();</div><div class="line">        out.write(buf);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>别的filter就不一一细说了。接下来看看真正核心的handler–FtpHandler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public interface FtpHandler &#123;</div><div class="line"></div><div class="line">    void init(FtpServerContext context, Listener listener);</div><div class="line"></div><div class="line">    </div><div class="line">    void sessionCreated(FtpIoSession session) throws Exception;</div><div class="line"></div><div class="line">    </div><div class="line">    void sessionOpened(FtpIoSession session) throws Exception;</div><div class="line"></div><div class="line">    </div><div class="line">    void sessionClosed(FtpIoSession session) throws Exception;</div><div class="line"></div><div class="line">    void sessionIdle(FtpIoSession session, IdleStatus status) throws Exception;</div><div class="line"></div><div class="line">    void exceptionCaught(FtpIoSession session, Throwable cause)</div><div class="line">            throws Exception;</div><div class="line"></div><div class="line">    void messageReceived(FtpIoSession session, FtpRequest request)</div><div class="line">            throws Exception;</div><div class="line"></div><div class="line">    void messageSent(FtpIoSession session, FtpReply reply) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个接口，定义了很多看似和MINA中的IoHandler中的很多接口是一模一样的，只是参数不同，一个是IoSession 一个是FtpIoSession，本质上FtpIoSession也是实现了IoSession接口的，可以说是一样的。<br>然而，acceptor的setHandler接受的参数是</p>
<blockquote>
<p>setHandler(org.apache.mina.core.service.IoHandler handler)  </p>
</blockquote>
<p>MINA中的IoHandler，这里我们自己定义的一个Handler是不可以放进去的。于是用了一个adapter来转接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">public class FtpHandlerAdapter extends IoHandlerAdapter &#123;</div><div class="line">    private final FtpServerContext context;</div><div class="line"></div><div class="line">    private FtpHandler ftpHandler;</div><div class="line"></div><div class="line">    public FtpHandlerAdapter(FtpServerContext context, FtpHandler ftpHandler) &#123;</div><div class="line">        this.context = context;</div><div class="line">        this.ftpHandler = ftpHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void exceptionCaught(IoSession session, Throwable cause)</div><div class="line">            throws Exception &#123;</div><div class="line">        //发生异常，这里将Iosession重新包装了一下，叫做ftpIoSession，实际上就是实现了IoSession而已</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">//        然后这个ftpHandler就对包装后的session进行处理，下同</div><div class="line">        ftpHandler.exceptionCaught(ftpSession, cause);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void messageReceived(IoSession session, Object message)</div><div class="line">            throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //将客户端发送的命令抽象成FtpRequest，将message传进去包装成request对象</div><div class="line">        FtpRequest request = new DefaultFtpRequest(message.toString());</div><div class="line">        //处理接受消息事件</div><div class="line">        ftpHandler.messageReceived(ftpSession, request);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void messageSent(IoSession session, Object message) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //处理消息发送事件</div><div class="line">        ftpHandler.messageSent(ftpSession, (FtpReply) message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionClosed(IoSession session) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //session关闭时</div><div class="line">        ftpHandler.sessionClosed(ftpSession);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionCreated(IoSession session) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        MdcInjectionFilter.setProperty(session, &quot;session&quot;, ftpSession.getSessionId().toString());</div><div class="line">        //session创建时，先与创建再有打开</div><div class="line">        ftpHandler.sessionCreated(ftpSession);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionIdle(IoSession session, IdleStatus status)</div><div class="line">            throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //session空闲</div><div class="line">        ftpHandler.sessionIdle(ftpSession, status);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void sessionOpened(IoSession session) throws Exception &#123;</div><div class="line">        FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">        //session打开，也就是连接打开的时候</div><div class="line">        ftpHandler.sessionOpened(ftpSession);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public FtpHandler getFtpHandler() &#123;</div><div class="line">        return ftpHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setFtpHandler(FtpHandler handler) &#123;</div><div class="line">        this.ftpHandler = handler;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正真处理session的依旧是我们定义的DefaultFtpHandler。这样设计的意义何在？？我觉得是不要过度依赖于MINA的api吧。或者为了装逼。<br>接下来看看处理session的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void messageReceived(IoSession session, Object message)</div><div class="line">        throws Exception &#123;</div><div class="line">    FtpIoSession ftpSession = new FtpIoSession(session, context);</div><div class="line">    //将客户端发送的命令抽象成FtpRequest，将message传进去包装成request对象</div><div class="line">    FtpRequest request = new DefaultFtpRequest(message.toString());</div><div class="line">    //处理接受消息事件</div><div class="line">    ftpHandler.messageReceived(ftpSession, request);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">public void messageReceived(final FtpIoSession session,</div><div class="line">        final FtpRequest request) throws Exception &#123;</div><div class="line">    try &#123;</div><div class="line">        session.updateLastAccessTime();</div><div class="line">        //将客户端输入命令封装成command对象</div><div class="line">        String commandName = request.getCommand();</div><div class="line">        //这个factory很有意思，是通过factory来创建的</div><div class="line">        //private CommandFactory commandFactory = new CommandFactoryFactory().createCommandFactory();</div><div class="line">        CommandFactory commandFactory = context.getCommandFactory();</div><div class="line">        //这里获得的command根据命令不同获取的cmd对象不同</div><div class="line">        Command command = commandFactory.getCommand(commandName);</div><div class="line"></div><div class="line">        // make sure the user is authenticated before he issues commands</div><div class="line">        if (!session.isLoggedIn()</div><div class="line">                &amp;&amp; !isCommandOkWithoutAuthentication(commandName)) &#123;</div><div class="line">            session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">                    context, FtpReply.REPLY_530_NOT_LOGGED_IN,</div><div class="line">                    &quot;permission&quot;, null));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        FtpletContainer ftplets = context.getFtpletContainer();</div><div class="line"></div><div class="line">        FtpletResult ftpletRet;</div><div class="line">        try &#123;</div><div class="line">            ftpletRet = ftplets.beforeCommand(session.getFtpletSession(),</div><div class="line">                    request);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            LOG.debug(&quot;Ftplet container threw exception&quot;, e);</div><div class="line">            ftpletRet = FtpletResult.DISCONNECT;</div><div class="line">        &#125;</div><div class="line">        if (ftpletRet == FtpletResult.DISCONNECT) &#123;</div><div class="line">            LOG.debug(&quot;Ftplet returned DISCONNECT, session will be closed&quot;);</div><div class="line">            session.close(false).awaitUninterruptibly(10000);</div><div class="line">            return;</div><div class="line">        &#125; else if (ftpletRet != FtpletResult.SKIP) &#123;</div><div class="line"></div><div class="line">            if (command != null) &#123;</div><div class="line">                synchronized (session) &#123;</div><div class="line">                    command.execute(session, context, request);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">                        context,</div><div class="line">                        FtpReply.REPLY_502_COMMAND_NOT_IMPLEMENTED,</div><div class="line">                        &quot;not.implemented&quot;, null));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                ftpletRet = ftplets.afterCommand(</div><div class="line">                        session.getFtpletSession(), request, session</div><div class="line">                                .getLastReply());</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                LOG.debug(&quot;Ftplet container threw exception&quot;, e);</div><div class="line">                ftpletRet = FtpletResult.DISCONNECT;</div><div class="line">            &#125;</div><div class="line">            if (ftpletRet == FtpletResult.DISCONNECT) &#123;</div><div class="line">                LOG.debug(&quot;Ftplet returned DISCONNECT, session will be closed&quot;);</div><div class="line"></div><div class="line">                session.close(false).awaitUninterruptibly(10000);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; catch (Exception ex) &#123;</div><div class="line"></div><div class="line">        // send error reply</div><div class="line">        try &#123;</div><div class="line">            session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">                    context, FtpReply.REPLY_550_REQUESTED_ACTION_NOT_TAKEN,</div><div class="line">                    null, null));</div><div class="line">        &#125; catch (Exception ex1) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ex instanceof java.io.IOException) &#123;</div><div class="line">            throw (IOException) ex;</div><div class="line">        &#125; else &#123;</div><div class="line">            LOG.warn(&quot;RequestHandler.service()&quot;, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的一些ftp命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line">        // first populate the default command list</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;ABOR&quot;, new ABOR());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;ACCT&quot;, new ACCT());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;APPE&quot;, new APPE());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;AUTH&quot;, new AUTH());</div><div class="line">        /*省略部分*/</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;STOR&quot;, new STOR());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;STOU&quot;, new STOU());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;STRU&quot;, new STRU());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;SYST&quot;, new SYST());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;TYPE&quot;, new TYPE());</div><div class="line">        DEFAULT_COMMAND_MAP.put(&quot;USER&quot;, new USER());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>再看看主要的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (command != null) &#123;</div><div class="line">    synchronized (session) &#123;</div><div class="line">        command.execute(session, context, request);</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    session.write(LocalizedFtpReply.translate(session, request,</div><div class="line">            context,</div><div class="line">            FtpReply.REPLY_502_COMMAND_NOT_IMPLEMENTED,</div><div class="line">            &quot;not.implemented&quot;, null));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将每一个session作为一个锁，保证每个连接的同步操作。具体的execute做了一些什么操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void execute(FtpIoSession session, FtpServerContext context,</div><div class="line">            FtpRequest request) throws IOException, FtpException;</div></pre></td></tr></table></figure></p>
<p>这是一个接口，具体的操作是由这个command是什么决定的。我们挑一个最简单的实现PWD：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class PWD extends AbstractCommand &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Execute command</div><div class="line">     */</div><div class="line">    public void execute(final FtpIoSession session,</div><div class="line">            final FtpServerContext context, final FtpRequest request)</div><div class="line">            throws IOException, FtpException &#123;</div><div class="line">        session.resetState();</div><div class="line">        FileSystemView fsview = session.getFileSystemView();</div><div class="line">        String currDir = fsview.getWorkingDirectory().getAbsolutePath();</div><div class="line">        session.write(LocalizedFtpReply.translate(session, request, context,</div><div class="line">                FtpReply.REPLY_257_PATHNAME_CREATED, &quot;PWD&quot;, currDir));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个命令用来显示当前目录。很容易理解。<br>至此，整个ftp的启动流程都全部梳理完毕，从服务器启动到接受客户端命令，其中的逻辑实际上一点都不复杂。整个服务启动到与客户端交互IoSession都穿插其中，对mina的依赖也不是很明显，当然这是作者刻意将耦合降到最低，这种设计思想值得学习借鉴。<br>接下来就具体探讨各个模块的实现细节。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有了之前的总体小窥后，现在开始细细把玩其中的深邃之处了。&lt;br&gt;其中可以看到有不少的factory，比如FtpServerFactory、ListenerFactory等。通过名字可以看得出来，这些都是用来产生实例的工厂。&lt;br&gt;
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.mr-dongw.site/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.mr-dongw.site/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.mr-dongw.site/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.mr-dongw.site/2017/01/08/hello-world/"/>
    <id>http://www.mr-dongw.site/2017/01/08/hello-world/</id>
    <published>2017-01-08T13:53:01.000Z</published>
    <updated>2017-01-08T13:53:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
