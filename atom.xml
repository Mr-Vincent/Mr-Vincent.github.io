<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DongWei&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wei-dong.top/"/>
  <updated>2022-01-08T08:22:50.334Z</updated>
  <id>http://www.wei-dong.top/</id>
  
  <author>
    <name>Mr-Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>迪士尼的第六十部动画电影，稍微让人失望了</title>
    <link href="http://www.wei-dong.top/2022/01/08/Encanto/"/>
    <id>http://www.wei-dong.top/2022/01/08/Encanto/</id>
    <published>2022-01-08T03:33:18.000Z</published>
    <updated>2022-01-08T08:22:50.334Z</updated>
    
    <content type="html"><![CDATA[<p>年前就被人安利了一波《魔法满屋》，那时候还没国内上映。今天看到手机消息推送有购票优惠，本着四舍五入约等于不要钱的想法就买票去看了。这次去之前特意看了一下豆瓣评分，确实不太高。院线的排片也不是很多，这部片子可以算坐了冷板凳了。</p>
<p>我想，既然是迪士尼出品的片子，也不会差到哪里去吧。毕竟有像《心灵奇旅》《寻梦环游记》《超能陆战队》《Up》这些优秀的作品来加持，对《魔法满屋》的期待就更高了。心想着豆瓣那群打低分的，会不会有失偏颇。</p>
<p>影院里除了我也就只有两个带孩子的家长。我不理解三四岁的小孩如何能看懂这部电影，这不是相当于给小学生讲高数吗。观影体验并不是那么糟糕，虽然偶尔听到小朋友问妈妈他说的是什么意思呀之类的话。</p>
<p>影片开头用一段很长很长的歌舞介绍了马利加家族的整体情况，看到这段歌舞我一度怀疑导演是不是个印度人。心想着这只是开头，后面应该会好很多吧。<br>​</p>
<p>整个家族都有魔法蜡烛赋予的【天赋】。女主姐姐就有控制花的魔法，类似《冰雪奇缘》里的Lisa一样；她姨妈有根据情绪控制天气的魔法…可是唯独女主米拉贝没有魔法。看到这里的时候我以为这部片子应该是讲女主的自我接纳和成长的故事，如果真是这样，那么这个主题就显得很俗套。我开始耐着性子看它怎么讲好这个故事，甚至有点期待。</p>
<p>米拉贝因为没有魔法天赋，在家庭生活中似乎很不被待见。看到这里居然也会联想到自己的人生境遇，平庸地活着，没有人在乎…而米贝拉的母亲是很爱她的。看到这里，我心里想这部片子该不会是讲的是家人和爱吧。</p>
<p>没错，影片中许多镜头都在表达这个主旨。米贝拉鼓励弟弟安东尼，和舅舅布鲁诺一起看预言的走势，最后和外婆达成和解，这些片段都在讲一个主题：家人和爱。</p>
<p>魔法屋的魔法消失是整个影片的核心脉络，米贝拉为了拯救【奇迹】，自己去寻找答案。在舅舅的预言里，米贝拉是让魔法消失的原因，因此外婆对米贝拉很严厉，甚至带着有色眼镜去对待她。影片里预言碎片在不同角度呈现出来的结果是不同的，也就是说米贝拉是让魔法消失的原因，也能拯救魔法屋。这个细节在影片最后有呼应。</p>
<p>但米贝拉是让魔法消失的原因吗？显然不是。这里影片中没明确去说明，但看过影片后肯定能想到答案。魔法消失是一条明线，暗线是米贝拉和家人的关系，即她和外婆的关系，她和姐姐的关系。</p>
<p>她和舅舅一起看预言走势的时候，看到能拯救魔法屋让蜡烛不灭的方法是拥抱她讨厌的姐姐，这段剧情埋了一个伏笔，直接推动剧情走向高潮，魔法屋真的毁灭了。她向不喜欢她的外婆说了内心真实的想法：你才是让魔法消失的原因。米贝拉也自责，因为魔法消失她有责任。</p>
<p>接着外婆被这一句话给点醒了，然后找米贝拉和解，在小河边讲故事。这段剧情我看的十分迷惑，向来专横强势的外婆，就突然被一句话给说服了，这个转变是不是有点太突兀，本来可以让人泪目的桥段，我硬生生憋了回去。</p>
<p>最后一大家子来重新盖房子，让米贝拉去安把手，安上的那一瞬间女主似乎获得了所谓的【天赋】，但是这个天赋具体是什么，影片没讲。在影片前期的时候，我一度以为这个没【天赋】的女主，最终影片会表达她自己本身就是【天赋/奇迹】吧，可惜没有。然后其乐融融地Happy Ending。总觉得少了点什么，结尾生硬了点，似乎为了HE而HE。</p>
<p>整部片子看下来，优点和缺点都十分明显。动画特效就不用多讲，尤其是女主姐姐操控花就像Lisa操控冰雪一样。前半段的剧情节奏也合情合理，埋下的伏笔基本都有解释。如果说影片主题不是家庭和解而是女主自我成长，这部片子应该会产生更多共鸣。相比优点，缺点显得十分明显。歌舞场景太多太多，有股咖喱味儿。我寻思着影片人物也不是印度人，听口音可能是南美，就为啥总爱唱唱跳跳呢。不唱不跳不也能讲好故事吗。其次是最后主题的升华，过于生硬和突兀，人物感情处理的不太自然和谐，没办法让人共鸣。</p>
<p>最后我给打3颗星，勉强及格，没达到预期，不推荐去看。</p>
<p>导演不是印度裔，是个美国人，可能他比较喜欢印度吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年前就被人安利了一波《魔法满屋》，那时候还没国内上映。今天看到手机消息推送有购票优惠，本着四舍五入约等于不要钱的想法就买票去看了。这次去之前特意看了一下豆瓣评分，确实不太高。院线的排片也不是很多，这部片子可以算坐了冷板凳了。&lt;/p&gt;
&lt;p&gt;我想，既然是迪士尼出品的片子，也不
    
    </summary>
    
      <category term="影评" scheme="http://www.wei-dong.top/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="movie" scheme="http://www.wei-dong.top/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>从Timer到时间轮</title>
    <link href="http://www.wei-dong.top/2021/10/16/%E4%BB%8ETimer%E5%88%B0%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    <id>http://www.wei-dong.top/2021/10/16/从Timer到时间轮/</id>
    <published>2021-10-16T10:03:18.000Z</published>
    <updated>2021-10-16T10:03:09.678Z</updated>
    
    <content type="html"><![CDATA[<p>太阳东升西落，海水潮涨潮落，四季交替，万事万物都有其周期。而衡量这些周期的重要维度就是时间。</p>
<p>时间的存在对于现实中的事物显得十分重要。在程序的世界里依旧如此。如订单未付款30分钟后自动取消，每天凌晨1点执行数据抽取任务…</p>
<p>在Java中Timer作为最易于使用的定时调度API，提供在未来某个时间执行任务的接口，也支持执行周期性任务的能力。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Timer timer=<span class="keyword">new</span> Timer();</div><div class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"我执行了"</span>+<span class="string">"  "</span>+System.currentTimeMillis());</div><div class="line">        &#125;</div><div class="line">    &#125;,<span class="number">1000</span>,<span class="number">2000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Timer的优势在于使用方便，实现也很简单。Timer的内部维持一个小顶堆的数据结构，每次添加任务都会根据任务延期的时间来构建小顶堆，任务最快到期的永远在根节点，这样定时器每次取任务直接取根节点就好了，这样时间复杂度在O(logn)级别。除此之外Timer内部还有一个线程，这个线程通过死循环一直取小顶堆的根节点，如果这个节点的执行时间比当前时间早，说明这个任务需要执行了，如果根节点任务的执行时间还没到，那就wait一下，直到下个循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimerTask task;</div><div class="line">                <span class="keyword">boolean</span> taskFired;</div><div class="line">                <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                    <span class="comment">// Wait for queue to become non-empty</span></div><div class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</div><div class="line">                        queue.wait();</div><div class="line">                    <span class="keyword">if</span> (queue.isEmpty())</div><div class="line">                        <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></div><div class="line"></div><div class="line">                    <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></div><div class="line">                    <span class="keyword">long</span> currentTime, executionTime;</div><div class="line">                    task = queue.getMin();</div><div class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</div><div class="line">                            queue.removeMin();</div><div class="line">                            <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></div><div class="line">                        &#125;</div><div class="line">                        currentTime = System.currentTimeMillis();</div><div class="line">                        executionTime = task.nextExecutionTime;</div><div class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</div><div class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></div><div class="line">                                queue.removeMin();</div><div class="line">                                task.state = TimerTask.EXECUTED;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></div><div class="line">                                queue.rescheduleMin(</div><div class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</div><div class="line">                                                : executionTime + task.period);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></div><div class="line">                        queue.wait(executionTime - currentTime);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></div><div class="line">                    task.run();</div><div class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当然缺点也十分明显，由于是单线程执行任务，如果某个任务耗时很严重，例如去读取网络中的流，那么后续的任务的调度时间不会那么准确。</p>
<p>从源码中可以发现，如果任务执行出现异常，那么后续的任务也不会执行了。这个代码片段可以说明问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,<span class="number">2</span>);</div><div class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"================="</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;,<span class="number">20</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>除此之外，还有一个问题：当任务数过多的时候，再向Timer中添加任务会导致小顶堆重建，在数据量大的情况下对性能也是有所损耗。</p>
<p>综上来讲，Timer适合简单的调度任务。而复杂任务则需要考虑其他的实现。</p>
<p>相比Timer，基于时间轮的定时器就显得高级很多。高级带来的代价就是复杂。时间轮算法基于一篇论文:<a href="https://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z" target="_blank" rel="external">https://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z</a></p>
<p>在Netty中，<code>HashedWheelTimer</code>实现了时间轮算法。</p>
<p>时间轮的核心在于其中的轮。这个轮如同时钟的表盘一样，每个刻度代表一个时间间隔，而任务放在这些刻度上，时间每走一个刻度，都会去检查对应的任务是不是要执行了。如此看来，对于执行任务的时间复杂度要比Timer要小，为O(N)。</p>
<p><code>HashedWheelTimer</code>的核心数据结构为数组加链表。数组代表之前提到的‘表盘’，每个刻度放置一个链表，这种结构和<code>HashMap</code>很像。除此之外还有一个重要参数<code>duration</code>，这个参数表示每个刻度的间隔时间。如果给1秒，那么代表这个时间轮每次走一秒。而数组的长度代表着表盘的大小，如果给12那么这个表盘和我们现实中的时钟一样，如果不指定，默认为512。<br><img src="https://img-blog.csdnimg.cn/20200614184706180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5zaGFuMjAxMA==,size_16,color_FFFFFF,t_70" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></div><div class="line">            ThreadFactory threadFactory,</div><div class="line">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection,</div><div class="line">            <span class="keyword">long</span> maxPendingTimeouts) &#123;</div><div class="line"></div><div class="line">        checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</div><div class="line">        checkNotNull(unit, <span class="string">"unit"</span>);</div><div class="line">        checkPositive(tickDuration, <span class="string">"tickDuration"</span>);</div><div class="line">        checkPositive(ticksPerWheel, <span class="string">"ticksPerWheel"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Normalize ticksPerWheel to power of two and initialize the wheel.</span></div><div class="line">        <span class="comment">// 数组长度搞成2的n次方，这样方便用位运算计算取模，基本操作了</span></div><div class="line">        wheel = createWheel(ticksPerWheel);</div><div class="line">        mask = wheel.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Convert tickDuration to nanos.</span></div><div class="line">        <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</div><div class="line"></div><div class="line">        <span class="comment">// Prevent overflow.</span></div><div class="line">        <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</div><div class="line">                    <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</div><div class="line">                    tickDuration, Long.MAX_VALUE / wheel.length));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</div><div class="line">            logger.warn(<span class="string">"Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms."</span>,</div><div class="line">                        tickDuration, MILLISECOND_NANOS);</div><div class="line">            <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.tickDuration = duration;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        workerThread = threadFactory.newThread(worker);</div><div class="line"></div><div class="line">        leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</div><div class="line">            WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            reportTooManyInstances();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在<code>HashedWheelTimer</code>初始化的时候，同时也实例化了一个工作线程。这个线程用于做时钟的tick操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> tick;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Initialize the startTime.</span></div><div class="line">    startTime = System.nanoTime();</div><div class="line">    <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// We use 0 as an indicator for the uninitialized value here, so make sure it's not 0 when initialized.</span></div><div class="line">        startTime = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Notify the other threads waiting for the initialization at start().</span></div><div class="line">    startTimeInitialized.countDown();</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</div><div class="line">        <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</div><div class="line">            processCancelledTasks();</div><div class="line">            HashedWheelBucket bucket =</div><div class="line">                    wheel[idx];</div><div class="line">            transferTimeoutsToBuckets();</div><div class="line">            bucket.expireTimeouts(deadline);</div><div class="line">            tick++;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</div><div class="line"></div><div class="line">    <span class="comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span></div><div class="line">    <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</div><div class="line">        bucket.clearTimeouts(unprocessedTimeouts);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        HashedWheelTimeout timeout = timeouts.poll();</div><div class="line">        <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</div><div class="line">            unprocessedTimeouts.add(timeout);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    processCancelledTasks();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如Timer的设计，一定会有一个死循环来不断轮询到期任务。<code>HashedWheelTimer</code>使用cas操作定时器状态，如果定时器关闭了，那么这个死循环就结束了。</p>
<p><code>waitForNextTick</code>用来计算是否要进行下次tick，如果不出意外，返回的是这个定时器已经跑了多久了。本质上也是一个死循环，要么睡一下，要么返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</div><div class="line">        <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</div><div class="line">                <span class="keyword">return</span> -Long.MAX_VALUE;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> currentTime;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Check if we run on windows, as if thats the case we will need</span></div><div class="line">        <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></div><div class="line">        <span class="comment">// the JVM if it runs on windows.</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">// See https://github.com/netty/netty/issues/356</span></div><div class="line">        <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</div><div class="line">            sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</div><div class="line">            <span class="keyword">if</span> (sleepTimeMs == <span class="number">0</span>) &#123;</div><div class="line">                sleepTimeMs = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(sleepTimeMs);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</div><div class="line">                <span class="keyword">return</span> Long.MIN_VALUE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>transferTimeoutsToBuckets</code>方法用于将任务重新放到轮子上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just</span></div><div class="line">    <span class="comment">// adds new timeouts in a loop.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</div><div class="line">        HashedWheelTimeout timeout = timeouts.poll();</div><div class="line">        <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// all processed</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</div><div class="line">            <span class="comment">// Was cancelled in the meantime.</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</div><div class="line">        timeout.remainingRounds = (calculated - tick) / wheel.length;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></div><div class="line">        <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</div><div class="line"></div><div class="line">        HashedWheelBucket bucket = wheel[stopIndex];</div><div class="line">        bucket.addTimeout(timeout);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很好奇一个问题，为什么不是在添加任务的时候就确定这些任务的位置，而是单独去做这样的操作。我想是因为链表的缘故，因为在一个格子中的任务不是每次tick到就一定执行的，需要确定这个任务的轮数，到了第0轮才会取出来执行，再说了，<code>timeouts</code>队列里没任务也不会有什么影响。<code>timeouts</code>是一个队列，每次添加任务的时候先入队，每次tick的时候才会去确定这个任务放在轮子的哪个刻度。</p>
<p>这里循环了10w次，目的就是防止任务太多而影响了任务的执行。试想有上百万任务在队列里等待被分配到轮上，需要计算‘圈数’，需要去构建链表，这些操作如果时间过长，自然会影响到当前tick到的任务执行的准确度。</p>
<p>任务的执行逻辑在<code>expireTimeouts</code>中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</div><div class="line">    HashedWheelTimeout timeout = head;</div><div class="line"></div><div class="line">    <span class="comment">// process all timeouts</span></div><div class="line">    <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</div><div class="line">        HashedWheelTimeout next = timeout.next;</div><div class="line">        <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</div><div class="line">            next = remove(timeout);</div><div class="line">            <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</div><div class="line">                timeout.expire();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</div><div class="line">                        <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</div><div class="line">            next = remove(timeout);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            timeout.remainingRounds --;</div><div class="line">        &#125;</div><div class="line">        timeout = next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为任务是放在链表中的，这里直接一个循环遍历链表，取出当前轮数为0的，且已经到期的任务，同时要将这个任务移出链表。如果当前轮数还没到，那么还得减一轮，这里代表语义为时间指针已经走了一圈了，下次再走到这里就要少一圈。</p>
<p>整个时间的tick如此自然和简洁。这个算法设计简直惊艳！</p>
<p>抛开剂量谈毒性就是耍流氓，正如抛开场景谈架构一样。在Netty中，时间轮定时器主要用于针对IO的超时检测。因为Netty作为高性能网络服务库，随随便便就支撑上十万的连接，每个连接都要对心跳，空闲做检测，如果使用Timer那么十分消耗资源而且低效。而对IO的一些定时操作，对精度要求也没那么高，晚一点执行也没什么关系。因此，在对任务的执行时间精度没那么高且不是耗时的前提下，使用<code>HashedWheelTimer</code>是比较合适的。有优点也会有缺点，比如时间间隔设置多少比较合适，短了会导致迟迟等不到任务频繁tick浪费cpu，长了会对准确度有影响，软件设计中没有银弹，根据实际场景做好tradeoff。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文针对<code>Timer</code>和<code>HashedWheelTimer</code>的描述大多都是泛泛而谈，并没有针对细节去深入剖析，比如APi怎么使用，比如核心接口定义，比如链表的操作…我以为这些东西都比较浅显和容易理解。而真正核心是其中的思想：怎么设计的，为什么这样设计，好处和缺点等等。我想带着问题去读源码才是最高效的学习方式。</p>
<p>源码之下无秘密。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/tianshan2010/article/details/106749830/" target="_blank" rel="external">HashedWheelTimer时间轮原理分析</a></p>
<p><a href="https://www.cnblogs.com/boanxin/p/13059004.html" target="_blank" rel="external">kafka时间轮的原理（一）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;太阳东升西落，海水潮涨潮落，四季交替，万事万物都有其周期。而衡量这些周期的重要维度就是时间。&lt;/p&gt;
&lt;p&gt;时间的存在对于现实中的事物显得十分重要。在程序的世界里依旧如此。如订单未付款30分钟后自动取消，每天凌晨1点执行数据抽取任务…&lt;/p&gt;
&lt;p&gt;在Java中Timer作
    
    </summary>
    
      <category term="源码" scheme="http://www.wei-dong.top/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy入门</title>
    <link href="http://www.wei-dong.top/2021/08/01/Scrapy_beike/"/>
    <id>http://www.wei-dong.top/2021/08/01/Scrapy_beike/</id>
    <published>2021-08-01T04:50:18.000Z</published>
    <updated>2021-08-01T04:52:20.671Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为工作上有数据采集相关内容，特地研究了一下Scrapy相关使用。总结了一下Scrapy的一些入门和实践经验。</p>
<p>考虑到想在武汉上车，因此就去采集了贝壳找房上的一些数据。具体的字段可以存到数据库或者文件中。这里是我定义的一些字段。<br><img src="/2021/08/01/Scrapy_beike/data_structure.png" alt="数据结构"></p>
<p>最终采集完数据之后，一般会对数据进行一些分析。如果会sql的直接写语句处理就好了，更友好的方式是用可视化展示出来，这样更直观。因此这里采用了pandas来处理数据，用pyecharts展示数据。这里是一个简单的效果图。<br><img src="/2021/08/01/Scrapy_beike/bar_loupan.png" alt="柱状图"></p>
<h2 id="Scrapy安装"><a href="#Scrapy安装" class="headerlink" title="Scrapy安装"></a>Scrapy安装</h2><p>对于使用过Python的同学而言，这些内容可以忽略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy</div></pre></td></tr></table></figure></p>
<p>使用scrapy创建工程，这个脚本很方便，可以一键生成模板。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy genspider [你的工程名称]</div></pre></td></tr></table></figure></p>
<p>最终的工程结构是这样的：<br><img src="/2021/08/01/Scrapy_beike/project_structrure.png" alt="工程结构"></p>
<h2 id="Scrapy使用"><a href="#Scrapy使用" class="headerlink" title="Scrapy使用"></a>Scrapy使用</h2><p>生成的文件都有自己的作用。<code>items.py</code>中定义数据字段。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeikeWuhanItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    name = scrapy.Field()</div><div class="line">    lp_type = scrapy.Field()</div><div class="line">    image = scrapy.Field()</div><div class="line">    block = scrapy.Field()</div><div class="line">    address = scrapy.Field()</div><div class="line">    room_type = scrapy.Field()</div><div class="line">    spec = scrapy.Field()</div><div class="line">    ava_price = scrapy.Field()</div><div class="line">    total_range = scrapy.Field()</div><div class="line">    tags = scrapy.Field()</div><div class="line">    detail_url = scrapy.Field()</div><div class="line">    create_time = scrapy.Field()</div></pre></td></tr></table></figure></p>
<p>可以发现这里的字段和在数据库中定义的一模一样。</p>
<p><code>settings.py</code>中定义一些设置属性。具体如何使用可以点击注释中的链接详细研究，scrapy的文档写的很全，对新手很友好。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载间隔 10秒一次 太频繁了网站会给你封掉 要么用代理池</span></div><div class="line">DOWNLOAD_DELAY = <span class="number">10</span></div><div class="line"><span class="comment"># 后面的数字代表顺序</span></div><div class="line">DOWNLOADER_MIDDLEWARES = &#123;</div><div class="line">   <span class="string">'BeikeSpider.middlewares.IPProxyMiddleware'</span>: <span class="number">100</span>,</div><div class="line">   <span class="string">'BeikeSpider.middlewares.BeikespiderDownloaderMiddleware'</span>: <span class="number">543</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pipelines.py</code>中定义对采集到的数据的处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeikespiderPipeline</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.connection = pymysql.connect(</div><div class="line">            host=MYSQL_HOST,</div><div class="line">            user=MYSQL_USER,</div><div class="line">            password=MYSQL_PASS,</div><div class="line">            db=MYSQL_DB,</div><div class="line">            charset=<span class="string">"utf8mb4"</span>,</div><div class="line">            cursorclass=pymysql.cursors.DictCursor,</div><div class="line">        )</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></div><div class="line">        <span class="keyword">if</span> isinstance(item, BeikeWuhanItem):</div><div class="line">            self.insert(item)</div><div class="line">        <span class="keyword">return</span> item</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, item)</span>:</span></div><div class="line">        cursor = self.connection.cursor()</div><div class="line">        keys = item.keys()</div><div class="line">        values = tuple(item.values())</div><div class="line">        fields = <span class="string">","</span>.join(keys)</div><div class="line">        temp = <span class="string">","</span>.join([<span class="string">"%s"</span>] * len(keys))</div><div class="line">        sql = <span class="string">"INSERT INTO wh_loupan (%s) VALUES (%s)"</span> % (fields, temp)</div><div class="line">        cursor.execute(sql, values)</div><div class="line">        self.connection.commit()</div></pre></td></tr></table></figure></p>
<p>这里的逻辑是将采集到的数据写入mysql，当然也可以写文件到excel也是没问题的。需要注意的是，这个pipeline写完了一定要在settings中配置一下。</p>
<p>最后就是自己的爬取逻辑了，<code>beike_wuhan.py</code>这个文件不会被自动生成出来，需要自己定义。这里是爬虫的入口。<br><code>start_requests</code>方法是父类中的定义，这个方法中定义爬虫的名称，以及从哪个url出发。最后通过yield关键字将这个请求交给Scrapy的下载器处理，其中还有一个callback函数，表示处理完请求后要做什么操作。<br><code>parse</code>函数也是父类的，通过参数response可以看出在这里做返回数据的解析。</p>
<p>在解析页面数据的时候使用xpath是比较快捷的。不过对于眼神不好的还是考虑别的选择器，因为层级多了容易看花。至于如何使用xpath这里不细说，不过浏览器中打开调试器能直接选择元素复制其xpath，非常好用。提取出元素信息将其值填充到<code>BeikeWuhanItem</code>中，这个过程还是比较繁琐的，需要点耐心。item构建完依然通过yield出去。这里的item就传递到了pipline中了，可以直接被<code>process_item</code>函数处理。</p>
<p>因为爬取的不仅仅只有这一页数据，还要继续接着爬。这里涉及到了翻页动作。贝壳页面中虽然有下一页按钮，但是这个按钮的渲染是通过JS动态生成的，直接通过请求地址是不会反悔这个按钮的元素的。这点值得注意一下，最简答的办法是查看网页源代码，如果能找到这个元素说明通过xpath可以取到，否则怎么都取不到。因此这里不能去通过判断是不是有下一页按钮去做翻页，而是得通过具体的总数去判断到底要不要继续爬。观察到如果到了最后一页，页面元素上的总条数就变成了0，这时候就不用继续翻页了。翻页的url也是通过yield传递给下载器，类似for循环，一直去下载解析。<br>这里也发现了贝壳的bug，显示有80页，其实到了40页就没数据了。导致我开始计算总页数的时候以为总页数就那么多，实际上的bug在有的页显示10条，有的页显示20条，不讲武德。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">p_room_type = re.compile(<span class="string">'[0-9]+'</span>)</div><div class="line">p_room_spec = re.compile(<span class="string">'[\s\S]*㎡$'</span>)</div><div class="line"></div><div class="line">root_url = <span class="string">'https://wh.fang.ke.com/'</span></div><div class="line">default_schema = <span class="string">'https:'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeikeWuhanSpider</span><span class="params">(Spider)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></div><div class="line">        super().__init__(**kwargs)</div><div class="line">        self.curr_page = <span class="number">1</span></div><div class="line">        self.url_template = <span class="string">"https://wh.fang.ke.com/loupan/nhs1pg%s"</span></div><div class="line"></div><div class="line">    name = <span class="string">"beike_wuhan"</span></div><div class="line">    allowed_domains = [<span class="string">"wh.fang.ke.com"</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 武汉楼盘的首页</span></div><div class="line">        baseurl = <span class="string">"https://wh.fang.ke.com/loupan/nhs1pg1"</span></div><div class="line"></div><div class="line">        UserAgents = [</div><div class="line">            <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 Edg/92.0.902.62'</span>,</div><div class="line">            <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 QIHU 360SE'</span>,</div><div class="line">            <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36'</span>]</div><div class="line">        UserAgent = random.choice(UserAgents)</div><div class="line"></div><div class="line">        headers = &#123;<span class="string">'User-Agent'</span>: UserAgent&#125;</div><div class="line">        <span class="keyword">yield</span> Request(</div><div class="line">            url=baseurl,</div><div class="line">            headers=headers,</div><div class="line">            callback=self.parse)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        <span class="comment"># next_page = response.xpath('/html/body/div[7]/div[2]/')</span></div><div class="line">        <span class="comment"># if next_page is not None:</span></div><div class="line">        <span class="comment">#     next_page = response.urljoin(next_page)</span></div><div class="line">        <span class="comment">#     yield Request(next_page, callback=self.parse)</span></div><div class="line">        <span class="comment"># 每页的数量还不是固定的 有的是10个每页 有的是20个每页</span></div><div class="line">        content = response.xpath(<span class="string">'/html/body/div[6]/ul[2]/li'</span>)</div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> content:</div><div class="line">            image = item.xpath(<span class="string">'./a/img/@src'</span>)[<span class="number">0</span>].extract()</div><div class="line">            name = item.xpath(<span class="string">'./div[1]/div[1]/a/@title'</span>)[<span class="number">0</span>].extract()</div><div class="line">            detail_url = item.xpath(<span class="string">'./div[1]/div[1]/a/@href'</span>)[<span class="number">0</span>].extract()</div><div class="line">            lp_type = item.xpath(<span class="string">'./div[1]/div[1]/span[2]/text()'</span>).extract_first()</div><div class="line">            address = item.xpath(<span class="string">'./div[1]/a[1]/text()'</span>)[<span class="number">1</span>].extract()</div><div class="line">            block = <span class="string">''</span></div><div class="line">            <span class="keyword">if</span> address:</div><div class="line">                block = address.split(<span class="string">'/'</span>)[<span class="number">0</span>]</div><div class="line">            room_type_texts = item.xpath(<span class="string">'./div[1]/a[2]/span/text()'</span>).extract()</div><div class="line">            room_types = []</div><div class="line">            room_spec = <span class="string">''</span></div><div class="line">            <span class="keyword">for</span> room_type_text <span class="keyword">in</span> room_type_texts:</div><div class="line">                <span class="keyword">if</span> re.match(p_room_type, room_type_text):</div><div class="line">                    room_types.append(room_type_text)</div><div class="line">                <span class="keyword">if</span> re.match(p_room_spec, room_type_text):</div><div class="line">                    room_spec = room_type_text.split(<span class="string">' '</span>)[<span class="number">1</span>]</div><div class="line"></div><div class="line">            room_type = <span class="string">'/'</span>.join(room_types)</div><div class="line">            t = item.xpath(<span class="string">'./div[1]/div[3]/span/text()'</span>).getall()</div><div class="line">            tags = <span class="string">','</span>.join(t)</div><div class="line"></div><div class="line">            ava_price = item.xpath(<span class="string">'./div[1]/div[4]/div[1]/span[1]/text()'</span>).extract_first()</div><div class="line">            total = item.xpath(<span class="string">'./div[1]/div[4]/div[2]/text()'</span>).extract_first()</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> total:</div><div class="line">                total = <span class="string">''</span></div><div class="line"></div><div class="line">            wuhan_item = BeikeWuhanItem()</div><div class="line">            wuhan_item[<span class="string">'name'</span>] = name</div><div class="line">            wuhan_item[<span class="string">'lp_type'</span>] = lp_type</div><div class="line">            wuhan_item[<span class="string">'image'</span>] = default_schema + image</div><div class="line">            wuhan_item[<span class="string">'block'</span>] = block</div><div class="line">            wuhan_item[<span class="string">'address'</span>] = address</div><div class="line">            wuhan_item[<span class="string">'room_type'</span>] = room_type</div><div class="line">            wuhan_item[<span class="string">'spec'</span>] = room_spec</div><div class="line">            wuhan_item[<span class="string">'ava_price'</span>] = ava_price</div><div class="line">            wuhan_item[<span class="string">'total_range'</span>] = total</div><div class="line">            wuhan_item[<span class="string">'tags'</span>] = tags</div><div class="line">            wuhan_item[<span class="string">'detail_url'</span>] = root_url + detail_url</div><div class="line">            wuhan_item[<span class="string">'create_time'</span>] = datetime.datetime.now()</div><div class="line">            <span class="keyword">yield</span> wuhan_item</div><div class="line"></div><div class="line">        <span class="comment"># 楼盘总数  如果为0了 那么说明没有下一页了</span></div><div class="line">        count = response.xpath(<span class="string">'/html/body/div[6]/div[2]/span[2]/text()'</span>).get()</div><div class="line">        print(<span class="string">'==================================================================='</span>, count)</div><div class="line">        <span class="keyword">if</span> int(count) &gt; <span class="number">0</span>:</div><div class="line">            self.curr_page += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.crawler.engine.close_spider(self, <span class="string">'任务完成'</span>)</div><div class="line">        next_page = self.url_template % self.curr_page</div><div class="line">        <span class="keyword">yield</span> Request(next_page, callback=self.parse)</div></pre></td></tr></table></figure>
<p>贝壳对频繁请求做了限制，因此最好使用代理池，否则很容易被禁IP，得苦哈哈去点击“我不是人机”的识别码才能解除限制。<br>到这里，基本上整个采集的环节都描述完了。接下来就是对数据进行处理和展示。</p>
<h2 id="pandas数据处理"><a href="#pandas数据处理" class="headerlink" title="pandas数据处理"></a>pandas数据处理</h2><p>pandas也能读取数据库中的记录，几行代码就搞定。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</div><div class="line"></div><div class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = <span class="string">'SimHei'</span></div><div class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:123456@localhost:3306/beike_spider'</span>)</div><div class="line">sql = <span class="string">''' select * from wh_loupan; '''</span></div><div class="line"><span class="comment"># 将查到的数据 load到pd</span></div><div class="line">df = pd.read_sql_query(sql, engine)</div></pre></td></tr></table></figure></p>
<p>接着对数据进行过滤，因为我们采集的楼盘有很多类型，如写字楼，底商等等。目前我只关心住宅，因此通过这个操作实现过滤。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 过滤掉其他的类型 只拿住宅做分析 同时只保留了4个列</span></div><div class="line">houses = df.loc[df[<span class="string">"lp_type"</span>] == <span class="string">"住宅"</span>, [<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'ava_price'</span>, <span class="string">'block'</span>]]</div></pre></td></tr></table></figure></p>
<p>不过话说回来，干嘛不用sql直接写过滤条件呢？当然可以，但这里是为了展示一下pandas的使用。</p>
<p>接着对住宅的区域进行分组，看看这些区的住宅楼盘的分布情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 通过区来做分组 这里返回的是一个series类型 索引为区，值为区下楼盘的数量 因此需要将对应的值取出来</span></div><div class="line">group_num = houses.groupby(<span class="string">"block"</span>).size()</div><div class="line">index = []</div><div class="line">val = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> group_num.items():</div><div class="line">    index.append(i[<span class="number">0</span>])</div><div class="line">    val.append(i[<span class="number">1</span>])</div><div class="line"></div><div class="line">bar = Bar()</div><div class="line">bar.add_xaxis(index)</div><div class="line">bar.add_yaxis(<span class="string">"楼盘数"</span>, val)</div><div class="line"><span class="comment"># render 会生成本地 HTML 文件，默认会在当前目录生成 render.html 文件</span></div><div class="line"><span class="comment"># 也可以传入路径参数，如 bar.render("mycharts.html")</span></div><div class="line">bar.render(<span class="string">"./figures/楼盘分布.html"</span>)</div></pre></td></tr></table></figure>
<p>最后生成图表，直观的呈现出来。</p>
<p>完整代码请参考 <a href="https://github.com/Mr-Vincent/Spider_Beike" target="_blank" rel="external">Spider_Beike</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在很早以前都是使用request库直接请求网页，需要处理连接，解析，重试之类的业务无关的脏活累活。代码写的又多又丑，目前使用了scrapy后发现瞬间清爽很多，效率提升了不少。<br>在习惯了Java这种强类型的语言后，再去写Python这种弱类型的有时候会很抓狂，比如做除法运算，虽然你知道你的除数是数字，但是解释器告诉你这是字符类型，不给你除，还得手动转一下类型，太气人了。还有在使用类方法的时候，根本不知道怎么去传参，各种花里胡哨的参数列表，对于强类型语言使用者来说，编程思维转变过来还是需要点时间。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pandas.pydata.org/docs/reference/series.html" target="_blank" rel="external">pandas doc</a><br><a href="https://docs.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="external">scrapy tutorial</a><br><a href="https://wh.fang.ke.com/loupan/nhs1pg2/" target="_blank" rel="external">贝壳新房</a><br><a href="https://github.com/Mr-Vincent/Spider_Beike" target="_blank" rel="external">代码地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为工作上有数据采集相关内容，特地研究了一下Scrapy相关使用。总结了一下Scrapy的一些入门和实践经验。&lt;/p&gt;
&lt;p&gt;考虑到想在武汉上车，因此就去采集了贝壳找房上的一些数据。具体的字段可以存到数据库或者文件中。这里是我定义的一些字段。&lt;br&gt;&lt;img src=&quot;
    
    </summary>
    
      <category term="scrapy" scheme="http://www.wei-dong.top/categories/scrapy/"/>
    
    
      <category term="code" scheme="http://www.wei-dong.top/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>阿胖相亲记</title>
    <link href="http://www.wei-dong.top/2021/07/10/xiangqin/"/>
    <id>http://www.wei-dong.top/2021/07/10/xiangqin/</id>
    <published>2021-07-10T10:50:18.000Z</published>
    <updated>2021-07-10T13:23:56.033Z</updated>
    
    <content type="html"><![CDATA[<p>在一个平静的午后，阿胖收到他叔的微信语音：“阿胖呀，给你介绍一个女孩子，父母人品都不错blabla…”，“好的，可以认识认识，微信名片分享一下”，阿胖回复道。</p>
<p>阿胖踏入社会以来，都没有过任何恋情，自己也不慌不忙的还怡然自得，身边的亲戚每次过年都得敲打他几次，他也不以为然。不过也很正常，由于工作性质，身边异性也比较少，接触异性机会不多，更何况遇到相互喜欢的。不过就自身素质而言，阿胖的优势并不明显，能找到合适的伴侣似乎比较困难。当阿胖打电话告诉我说终于有人给介绍对象的时候，我仿佛听到他颤抖的声音。不过作为多年的老朋友，我还是劝告他不要有太多期待，失败才是人生常态。</p>
<p>微信消息通知显示着“Oriana请求添加您为好友”，阿胖点了同意。“你婶子分享给我你的微信的”，“我知道这事”，阿胖不紧不慢回复着。</p>
<p>“请问怎么称呼？”</p>
<p>“欧阳晴子，大家都叫我欧阳”</p>
<p>“好的，晴子小姐”</p>
<p>“ … ”</p>
<p>阿胖总喜欢给人起别名，不管对方和他关系好不好。他的室友也有着和他类似的别名：阿华，阿斐。他觉得取别名才能拉近距离。</p>
<p>“你抽烟吗？”</p>
<p>“不抽烟，偶尔喝点酒，咋啦？”</p>
<p>“我无法忍受抽烟”</p>
<p>“抽烟对身体不好，我想多活几年”</p>
<p>就这样，阿胖和他的女嘉宾有一搭没一搭地聊着。其实对方的处境都差不多：接触异性少，而且周围的异性基本都成家了，因此交际圈很窄。</p>
<p>在一个城市的好处是见面很方便。经历过几天断断续续的闲聊，阿胖对女嘉宾的基本情况也了解差不多，提出在一个周末线下见面。这个建议是被迫于他叔他婶的疯狂催促，这也是后来阿胖向我哭诉的。</p>
<p>“那是周六的一个下午，天气很好，因为我们约的是一起吃晚饭，我把时间定在6点，我离那边很近，走路过去也就10来分钟，我打算吃四季同仁的椰子鸡”，阿胖语无伦次地对我讲述第一次面基的经历，“后来她先到了，然后在那里等了一会儿，因为我们没见过面，根本认不出对方，而且那广场挺大，我就语音她”。“接着呢？”，我很好奇地听故事一样急促问道。“她声音很好听，咬字很清晰，普通话很标准，认出她后我也是这样夸她的，这也的确是我真实的想法，不算恭维取悦吧”。<br>“你说假话的时候眼睛会一直眨，骗不了人，继续讲吧”，我对他说道。“她的样子离我的想象中还是有点差距的，身高大概155，身型看起来不是太瘦，看得出来家庭条件还是挺不错的，长得很好”，阿胖嘴角带着笑容道。“你也好意思说别人胖，你瞧瞧你自己一身肥肉…”，我忍不住想怼一下他：“你没有把这话直接对人家讲吧？”。“怎么可能？我好歹也是一个懂礼貌的人，这点情商还是有的，只是这种和想象之间的落差，让我仿佛患上了失语症，你说的没错，不能有太多期待”，阿胖回复道。“接着你们一起去吃椰子鸡了？相处怎么样？尬不尬？哈哈哈”，我继续问道。“她话倒是蛮多的，能一直讲下去，不需要我刻意去制造话题，也有可能她也害怕尴尬，于是自己讲个不停。这种场合算是我第一次遇到，线下面基其实还是有点紧张，我甚至和她表达了我有点紧张的情绪，其实主要为了缓解一下尴尬…”,”说重点！然后你们都聊了一些什么？”，我打断他。阿胖总是喜欢哔哔一些无关紧要的，我再不收回来他肯定要跑偏。“我就问她有没有类似的线下面基的经历，然后她讲了很多关于她去年过年回去相亲的奇葩故事，貌似那顿火锅吃了大概一个半小时，我就记住了这些，哦对了她还在减脂，我看她这也不吃那也不吃，不过也正常，毕竟…”,阿胖又被我打断了：“行了行了，你真是够了，你的礼貌呢？”。“可能吃饭的时候讲的话太多了，导致吃完后等车我们一直沉默不语，我感觉我们聊了很多，又好像什么都没聊，好像对她很了解，又好像一无所知”，阿胖又开始感慨起来。</p>
<p>阿胖一开始并不把这次接触当作相亲的，只是单纯的认为一次认识接触的机会，但是他叔婶不是这么想。我时常收到他的抱怨：我叔老是说你要是觉得可以就把这件事定了吧。在他看来，父辈对婚姻的理解就如此简单，简单到不需要多方面的考虑，长时间的相处等等。其实对他叔婶的婚姻，失败地就像一坨晒干的猪粪，一碰就散。我甚至觉得让一个有着失败婚姻的人来指导晚辈很讽刺。阿胖饱受这些唐僧般的唠叨：“你要主动“，”多关心人家”，“给人家多花点钱”，“带人家出去玩”…阿胖后来告诉我，虽然知道长辈的这些话不正确，但是隔三差五地给你语音灌输，你还不能拒绝反驳，一旦反驳就给你扣上怎么这么不知好歹，我们长辈还会害你吗的帽子。时间久了也会产生影响，不知不觉把这种单纯的接触认识似乎真的演绎成一场相亲，而自己却浑然不知，甚至代入到了角色当中。</p>
<p>后来的后来，阿胖回忆道：和晴子小姐后来的接触仿佛带着某种使命一样，浑身不踏实，仿佛只要对方不满意就是自己的错，那种难受让我不再想和她接触。其实更主观的想法是对方时不时透露出一点点优越感，让我很不适。我能理解阿胖的感受，但也没觉得有什么值得可惜的地方。没有结果也不是一件坏事，但是也算给年轻的阿胖积累了一次人生经历。我后来开玩笑问他这次算不算舔狗行为，他目光坚定地告诉我不算，理由是又没有喜欢的情绪，就没有舔狗的行为。我不得不佩服他倒是拎得很清。</p>
<p>阿胖的这次经历离现在已经过了差不多半年时间，最近才愿意和我分享这些琐碎的细节。和他认识这么多年，他一直以来大大小小的情绪都喜欢自己先消化掉，然后像牛反刍一样再慢慢释放出来，再讲起来这些故事的时候明显感觉他眼神更加笃定了。</p>
<p>阿胖的这次不算相亲的相亲记就这样波澜不惊的结束了，也算是给他平淡无奇的人生旅程添加了一点小风小浪。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个平静的午后，阿胖收到他叔的微信语音：“阿胖呀，给你介绍一个女孩子，父母人品都不错blabla…”，“好的，可以认识认识，微信名片分享一下”，阿胖回复道。&lt;/p&gt;
&lt;p&gt;阿胖踏入社会以来，都没有过任何恋情，自己也不慌不忙的还怡然自得，身边的亲戚每次过年都得敲打他几次，他
    
    </summary>
    
      <category term="BEYOND CODING" scheme="http://www.wei-dong.top/categories/BEYOND-CODING/"/>
    
    
      <category term="生活" scheme="http://www.wei-dong.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>包饺子</title>
    <link href="http://www.wei-dong.top/2021/04/18/bao-jiaozi/"/>
    <id>http://www.wei-dong.top/2021/04/18/bao-jiaozi/</id>
    <published>2021-04-18T09:50:18.000Z</published>
    <updated>2021-04-18T09:34:59.862Z</updated>
    
    <content type="html"><![CDATA[<p>介于前几个周末做冬瓜汆丸子失败，今天突发奇想为什么不试试包饺子呢。这个想法并不是自己想到的，而是上次卖肉热心摊主问是不是回去包饺子。对于我而言，饺子麻烦而且没那么好吃，肯定不会自己尝试去折腾的。这次去尝试还是因为自己做菜太麻烦，毕竟想尝试的菜都尝试个遍了，倒也没那么大的耐性去钻研如何做得更好吃了。随着年龄的增加，我觉得对味道的依赖也没那么明显了。平时下班回来楼下的打工人套餐就足以慰藉我一天的辛勤劳作了，而且价格也很实惠，没有花里胡哨的各种讲究，用顶饱来描述最恰当不过。</p>
<p>在我印象中的包饺子一定是自己和面，擀皮，准备肉馅，包陷，下水煮这一系列过程。光是去想我都觉得麻烦，简直太麻烦了。一般来说，吃的时候绝不嫌弃麻烦，毕竟动动筷子张张嘴的事情，读书人怎么能称之麻烦呢。在我的记忆之中，曾经有次自家包饺子就是这个流程，最后出来的饺子皮大陷薄，吃两个就差不多饱了。然而缺点也十分明显，皮很容易破，没什么韧性。现在商品丰富了，自家想包饺子也不必如此麻烦。</p>
<p>今天我去超市买了40张饺子皮，一斤梅头上肉，一根大葱和一小块生姜。之前的经验是肉给热心摊主绞一下，葱姜回来自己切碎拌陷儿。这次想着热心摊主也应该热心地帮我把葱姜一块和肉给绞了，摊主当真热心，满脸写着高兴给我将葱姜切块洗净跟着肉一起绞了，把食材递给我的时候我大声说了句谢谢，心里想着这下子给我省了好多事情，回去路上都觉得今天的风都格外温柔。</p>
<p>之前路边有个手工饺子店，店老板娘总是坐在门口“表演”着包饺子。只看她一手拿皮一手拿勺子，肉馅和皮接触不到一秒一个饺子就出来了。有时候会很惊叹竟然会有如此的速度，有时候又会不以为然，对自己说如果我勤加练习也能达到这般出神入化的地步。虽然我不能做到一秒一个，但是至少能五秒一个吧，十秒一个也不那么丢人。</p>
<p>回来后先对肉馅调味，酱油、盐、鸡精、胡椒粉这些都是必备的。接着就开始当一个无情的拌肉机器，一遍又一遍地顺时针去搅拌肉馅，差不多拌了十来分钟封住保鲜膜放进冰箱静置一段时间。静置一下主要是为了让自己休息一下，拌肉也挺累的。接着就开始正儿八经的包饺子了：准备一碗清水，一把小勺子，一个大一点的盛放容器。将饺子皮放在左手摊开，右手指沾点清水，均匀地涂抹在饺子皮边缘，这样做是为了皮更容易粘合而不至于“露馅”，肉馅不能太多也不能太少，太多皮包不住，太少吃起来不得劲。将肉馅放到皮中心位置，沿着皮中心轴位置折起来，将边缘用力捏紧，然后通过双手虎口处捏合住边角，最后检查一下有没有没捏紧的位置。自此一个饺子就成功诞生了。当我捏完一个饺子后发现，实际上和自己想象之中的包饺子，复杂程度其实也没那么大，究其原因还是自己太懒了，没有耐心。随着一个个饺子的落地，我发现这个过程还是很治愈的。这种一直重复同一个动作，完全不用思考其他问题，真真切切的沉浸感是非常令人愉悦的。</p>
<p>我一直认为饺子代表的含义是阖家团圆，毕竟每年过年都要吃上饺子。我记得往年过年年饭上都有一锅饺子，我母亲每次年前都要包上一些，能吃到初五。而每次我都嘴上说太麻烦了但吃起来却从来不犹豫。当然也不是她一个人去包，我也会参与到其中。我现在回忆起往事，一起包饺子才是真正有趣的事情。那种参与感，让我更觉得我们是一个不可分割的整体，更容易感受到属于家的温馨。而这种感觉，身处异地他乡的我已经很久很久没体会到了，每年的相处，也就那匆匆忙忙的几天，现实的无奈夹杂着对生活的期许，也随着年龄增长而慢慢褪去，仅剩下儿时的记忆支撑着自己内心深处的向往。而这也就是我想着即使自己独自在外也要尝试包一次饺子的理由吧。</p>
<p>生活或许是残酷的，但我想有必要找个精神寄托来抵御这世间的荒诞，勇敢去生活。</p>
<p><img src="/2021/04/18/bao-jiaozi/jiaozi.jpg" alt="不好看还能吃的饺子"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介于前几个周末做冬瓜汆丸子失败，今天突发奇想为什么不试试包饺子呢。这个想法并不是自己想到的，而是上次卖肉热心摊主问是不是回去包饺子。对于我而言，饺子麻烦而且没那么好吃，肯定不会自己尝试去折腾的。这次去尝试还是因为自己做菜太麻烦，毕竟想尝试的菜都尝试个遍了，倒也没那么大的耐性
    
    </summary>
    
      <category term="BEYOND CODING" scheme="http://www.wei-dong.top/categories/BEYOND-CODING/"/>
    
    
      <category term="生活" scheme="http://www.wei-dong.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>2021 少糖去冰</title>
    <link href="http://www.wei-dong.top/2020/12/31/2021-no-suger/"/>
    <id>http://www.wei-dong.top/2020/12/31/2021-no-suger/</id>
    <published>2020-12-31T15:50:18.000Z</published>
    <updated>2020-12-31T16:58:50.893Z</updated>
    
    <content type="html"><![CDATA[<p>也不晓得从什么时候起，开始有了写年度总结的习惯了。我记得上次写年度总结还是在一年前。是啊，岁月转瞬即逝，一年又一年。我不禁陷入了回忆，这一年做了些啥，收获了些啥。</p>
<p>要是用关键字来概述这一年，我思前想后挤出这么几个词：焦虑，热爱，孤独，和解，期待。</p>
<p>自从步入打工人行列以来，焦虑情绪一直伴随左右。年初的疫情算是年度影响范围最大的事情了，从二月份延续到现在。疫情导致焦虑情绪加重很多。我记得年三十那一天，武汉紧急封城，室友阿华刚离开武汉就宣布封城，在晚一点估计就得呆在武汉过年了。我如同往年一样，坚守到除夕最后一天，然后匆匆忙忙回去和爹妈团聚，能赶上吃晚饭。不知道从什么时候起，春节这个假期就变得很无趣了，我感受不到丝毫节日的氛围，丝毫不觉得有什么仪式感。后来我明白了，成年人的世界本身就是无趣的，和节日无关。封城消息一出后，接着各地都变得十分紧张，尤其是湖北各个地区。我没回去，因此也错过了这一场“隔离狂欢”。后来想到很多湖北的同事朋友隔离在家办公，相当于放了一个暑假，内心无比羡慕。春节没过完我就急匆匆的回到了深圳，因为听到很多人过年一回去就连夜折返了，就是害怕疫情蔓延导致持续封锁耽误工作（挣钱）。我大概是初五就返深了，带着爹妈准备的猪蹄香肠以及腊鱼。机场里很空旷，地铁里广播播放着疫情防范须知，外面太阳很大，穿秋裤的我冒着汗，心里想着赶紧回去换衣服。似乎看不出这是冬天，来来往往的人戴着口罩，表情无法言喻。接着就是一段异常艰难的独居求生时光了。</p>
<p>我带着“存货”大约坚持了两周左右，最长坚持10天没出门，后来就美团买菜了。因为假期延后，春节之后的那几天在家办公可以算加班费的。即使一个人呆在这边，也是有事情做的，不会太无聊。基本上每天9点起来找点吃的，接着就开始搬砖了。远程办公效率不如当面沟通，因此产出有限。但满打满算一天也有差不多8小时的工作时间。到了11点就需要准备午饭了，切菜，洗菜，炒菜，一顿忙活之后做出来的像屎一样，正如我当前的人生。疫情带来的必然结果就是经济衰退，后来封锁解除，路边的很多门店都贴出了转让通知。随之而来的是复工。</p>
<p>然后的然后就是ko总和亮华的离职了。我记得亮华最后一天的时候，我还弄出了一个生产事故，原因是表没加索引，也算是值得记录的一件事吧。他们是我遇到的最让人信服的leader之二。ko总传递出很多价值，很多技巧，我受益很多。我觉得以后很难再遇到这样的leader了，这是十分遗憾的事情。虽然工作不是生活的全部，但是我们在工作的时候依然能感受到生活的乐趣，我觉得这是在云集，在那个团队里最值得怀念的事情。他们的离开导致了组织架构的变化，我们被划分到了隔壁业务线下，总之就是有点人心惶惶了。再后来就是人员优化了，也就是裁员。当时的情形是都想争取被优化的名额，因为公司的增长却是不咋地了，都想走了，被优化好歹也能拿到一笔不错的赔偿，那可比年终奖香多了。当然我也很幸运的在其中，这时候我们原有的团队几乎解散，当时我发了一条朋友圈“让我再看你眼，从南到北”。<br><img src="/2020/12/31/2021-no-suger/farewell.jpeg" alt="farewell"></p>
<p>比较遗憾的是留下来的，在此之前我都假象了好多次，万一我不在名单之中我心态是不是得爆炸。云集算是我踏入搬砖人行业以来经历时常最多的一个东家，也是我认为目前工作氛围和成长最多的一个东家。也许若干年后，我会想起六楼的天台，在某个晴朗的下午，坐在长椅上望着天空什么都不做，发呆就好。</p>
<p>当我拿到了赔偿，直接给自己直接放假一个月。我回家玩了俩星期，第一个星期每天啥都不干，就是玩，纯粹的玩，纯粹的浪费时间，丝毫没有焦虑的情绪了。那时候我发现，原来焦虑是来源于工作，只要工作就会焦虑。焦虑着这个迭代能否完成需求，焦虑着晚上要不要加班，焦虑着下班后有没得人又在群里艾特你…接下来的一个星期就觉得没那么好玩了，发现吃饭也不香了，睡觉也睡不着了，得找点事情做体现一下价值了。人生真是奇妙，快乐是短暂的。后来我明白了一个道理，随着年龄的增长，获取快乐的成本会增加，再也回不到小时候吃到一颗糖就能高兴很久的那段岁月了。失业也是一件很难过的事情，因为找工作也让人感到焦虑。有时候不出去面试一把，是真不知道自己几斤几两。虽然很难，但是为了吃饭还是得硬着头皮往前冲。后来也如愿以偿，虽然不是自己想象之中的，但是赚钱吧，不丢人。</p>
<p>现实和理想差距太大，容易让人产生情绪。当然也是这一次经历让我第一次和自己达成了和解。我总算明白了万事不顺遂人意的真正含义，也开始变得不那么纯粹，开始学着演戏。每次意难平的时候，我总是安慰自己：赚钱嘛，不丢人。后来我明白了，原来是我的生活里缺少了一样东西：热爱。</p>
<p>前几个月爱上了跑步，又在前几个月办了健身卡。本着一周两次的频率，每次去的成本就变成了10块钱的打算，后来发现我并不喜欢健身房里的空气。原因很简单：户外更带劲。跑步机上持续慢跑40分钟大气都不怎么喘一下，户外最多20分钟心脏就跳个不停。因此我爱上了户外慢跑。这种慢而持续的反馈带来的是走路带风了。我开始明显感受步子变得轻快起来了，这种感觉很微妙，这种快乐虽然不强烈，但是却能刺激着我坚持下去，我姑且可以称之为热爱。</p>
<p><img src="/2020/12/31/2021-no-suger/run.jpeg" alt="farewell"></p>
<p>我又记得几年前觉得会画画的人特别酷，于是自己买来纸笔开始学习。我记得当时也是处于失业状态，想寄托这种无法排解的孤独，找到一点生活的乐趣。最后的坚持是画完了一个苹果就放弃了，那时候心里想着，如果可以我一定要捡起来，也要成为很酷的人。后来明白了原来成年人的世界里并不是无趣的，拥有热爱才能变得有趣。于是现在真捡起来了。现在我几乎每天抽点时间练习一下，十分解压，还能获得那么一点点成就感。虽然走的很慢，但是我认为很值得。我想等我那一天回头翻到曾经练习的点点滴滴，一定会很骄傲。我觉得快乐很短暂是因为获取的成本太低了，一个沙雕视频能让我快乐几秒钟，却不能让我高兴一天。因此需要找到热爱，找到能让我只要一提起来，就让我高兴很久的事情，虽然很难，但值得去尝试。</p>
<p><img src="/2020/12/31/2021-no-suger/pic01.jpeg" alt="farewell"><br><img src="/2020/12/31/2021-no-suger/pic02.jpeg" alt="farewell"></p>
<p>热爱一件事是很孤独的，因为身边不会有那么多和我相似热爱的人。每当我听到有人讲一个不太好笑的笑话一群人跟着大笑点时候，脑袋里就出现鲁迅的那句“人类的悲欢并不相通，我只觉得他们吵闹”。我可能不合群，也可能是过于冷漠，成年人的世界里谁不冷漠呢，大家只是喜欢演戏罢了，也许我可能是脱离了低级趣味的人。这一年我明白了一个道理，从他人身上获取快乐太难，要降低对他人的期许，给自己找快乐。我时常一个人看电影，看到感人的场景会热泪盈眶，看到幽默的情节会会心一笑，有时候想分享这些情节发现别人或许无法理解这些情绪，索性只能自己独享了。我的快乐是孤独的，但是独孤也是一种快乐，因为直面自己，无需演戏，这种感觉是真实的。</p>
<p>八月份行情不错，大盘冲到了3200点，情绪很高涨。于是我心急火燎去开证券账户，开始跑步进场。接着就是一顿瞎操作，每天盯着账户上的几分几毛的浮动盈亏纠结不已，都没心思搬砖。后来一次大回调，全部清仓，浮动亏损38块！不自己亲身经历一番根本不知道这种心态多么重要。现在开始理性化，不再受情绪左右，开始学着控制仓位，控制成本。最终操作下来只盈利了800来块，受益在3个点左右。这么一通折腾还不如买基金躺着呢。虽然折腾，但是也有趣呀。毕竟赚钱嘛，不嫌折腾。</p>
<p><img src="/2020/12/31/2021-no-suger/money.jpeg" alt="farewell"></p>
<p><img src="/2020/12/31/2021-no-suger/money1.jpeg" alt="farewell"></p>
<p>关于期待，那就是坚持自己的热爱，保持生活的热情，降低对他人的期许，接受自己的平凡，让无趣的生活变得闪闪发光来抵抗永恒的孤独。</p>
<p>2021，去糖少冰！</p>
<p><img src="/2020/12/31/2021-no-suger/bye.png" alt="farewell"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也不晓得从什么时候起，开始有了写年度总结的习惯了。我记得上次写年度总结还是在一年前。是啊，岁月转瞬即逝，一年又一年。我不禁陷入了回忆，这一年做了些啥，收获了些啥。&lt;/p&gt;
&lt;p&gt;要是用关键字来概述这一年，我思前想后挤出这么几个词：焦虑，热爱，孤独，和解，期待。&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="BEYOND CODING" scheme="http://www.wei-dong.top/categories/BEYOND-CODING/"/>
    
    
      <category term="生活" scheme="http://www.wei-dong.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊编码外的乐趣</title>
    <link href="http://www.wei-dong.top/2020/12/05/%E8%81%8A%E4%B8%80%E8%81%8A%E7%BC%96%E7%A0%81%E5%A4%96%E7%9A%84%E4%B9%90%E8%B6%A3/"/>
    <id>http://www.wei-dong.top/2020/12/05/聊一聊编码外的乐趣/</id>
    <published>2020-12-05T07:37:23.000Z</published>
    <updated>2020-12-06T04:31:52.513Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在思考一个问题，步入码农行业这么久了，除了编码带来的乐趣，到底还有没有别的乐趣。因为我本身专业就是计算机，从小对计算器有着很大的兴趣，即使存在着傻逼业务傻逼产品经理会提出奇葩的要求，也不会觉得编码很枯燥。纯粹的编码不会枯燥，纯粹的技术也不会枯燥。我觉得学习新技术就像攀登一座山峰，等到站在山顶一览纵山小的时候，那种成就感会扑面而来，当然这种成就感也就存在那几分钟或者几秒钟，随之而来的就是索然无味，接着就是马上关掉电脑，轻叹一声“真没意思”。</p>
<p>学习和了解新技术是一回事，工作日常中搬砖又是另外一回事。工作中会出现各种让人抓狂的瞬间，比如产品设计不合理，导致原来的实现全部推翻重做；比如产品某个细节没想清楚，写着写着发现逻辑没发自洽，然后就…反正所有编码中的问题都是产品不行导致的，和开发没半点关系。因此日常工作中的枯燥由此而来，会让人产生编码本身是否枯燥的疑虑。我可能理解很多人口中说到的枯燥应该是无休止的添删改查，但这也只是业务上的枯燥，和编码没任何关系。我觉得编码就像盖一座高楼，图纸都给你画好了，按着图纸去实现，也可以添加一点自己的设计，最终的作品就是带着自己的思想的成果，那种满足感是很愉悦的。除此之外也能去看看其他人的实现，当发现某个巧夺天工的设计思想的时候，犹如打开了一箱宝藏，心里忍不住直呼：“妙呀”！编码中的乐趣无处不在，需要有一颗永不止步的心，stay hungry stay foolish！</p>
<p>虽然编码中能找到乐趣，但生活永远不止编码。</p>
<p>对于大龄单身男青年程序员我而言，生活的乐趣在于找到自己的热爱，那种可以长伴一生的热爱，那种能让你保持专注，忘乎所以的热爱。目前能让我有那种感觉的事情有仨：做菜、画画和塞尔达。</p>
<p>我记忆中常常会出现这样的场景：放学后饿的很慌，急不可耐去厨房问母亲啥时候能吃饭，接着就是围在母亲旁边，看着她把一些食材变成一道道佳肴。她会告诉我这个要先放油，那个要最后放盐…随着年龄增长以及口味的挑剔，很多时候外卖和打工人套餐仅仅只能做到果腹，曾经的那种味道也仅存在记忆当中了。当然做菜肯定也还原不了曾经的味道，我觉得仅仅是对生活的一种态度。做菜最重要的是能让我感受到人间烟火，我很喜欢那种菜市场里人来人往熙熙攘攘的氛围，大爷大妈讨价还价，卖鱼卖肉的摊贩大声吆喝…这些远离了高楼林立的写字楼，逼仄昏暗的格子间，人潮攒动的地铁站，更能让我觉得我是在生活，而不是一只打工机器。其次是做菜过程中的专注。买完菜后需要洗菜，切菜，炒菜等一系列步骤。尤其是切菜能让我保持专注，特别是切肉的时候，有时候切块肉能耗费半小时。切肉的过程其实是很解压的，因为需要保持高度注意力，否则要么手遭殃，要么切肉难看，做出来的菜会很让人失望。做菜也是一种低成本的尝试，因为如果不好吃的话大不了去吃打工人套餐或者外卖，如果好吃那就赚大了，又学到一个成功的经验，攒到了一门拿手菜的技巧。相比于结识一个新朋友，追求爱慕已久的女神，机会成本还是低很多的。</p>
<p>我喜欢画画是因为需要一种途径去表达和记录。就像写文一样，无非就是记录和表达。奈何自己文字表达能力有限，写文实在有点爱不起来。有时候热爱某个东西时不需要任何理由的，仅仅是觉得哇塞那样好酷呀，我好喜欢。我对画画的喜欢也是如此。画画也能让我保持专注，有时候画一个简单的东西需要花好几个小时，为了一个线条反复修改…专注的过程是很享受的，那种快感不像是你打赢了一把游戏来的快去的也快，而是之后的很长一段时间那种愉悦都会围绕着你，回味无穷。<br><img src="https://upload-images.jianshu.io/upload_images/3117395-a29c2745207a1bf7.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="第一次画 入门"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3117395-3d7411f9c3fbd373.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp" alt="后来画的"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3117395-cd4cb499277fa8d8.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp" alt="临摹 gal shir的作品"></p>
<p>我的期望是有一天能做到通过画画真正的记录和表达，虽然现在仅仅只会简单的模仿。</p>
<p>除此之外，对于宅男程序员而言，当然少不了游戏。很久以来我只会玩LOL，这个游戏陪伴着差不多有快10个年头了。很长时间以来我很沉迷其中胜利的快感。但后来发现这种快感之后带来的是焦虑和不安，让人觉得很空虚无聊。如此一来就似乎对LOL没太多兴趣了。我对手游也提不起兴趣，我觉得要素过多，不晓得是人玩游戏还是游戏玩人。但自从遇见了林克，其他的游戏都不配称作游戏了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3117395-6e5098818e48a701.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="林克在新手村海拉鲁平原"></p>
<p>双11拔草了NS，顺便入手了心心念的塞尔达传说和健身环大冒险。很早前就听到网上很多人吹爆塞尔达，我抱着试试看心态买了个卡带想瞧瞧到底有多了不起，结果入坑之后发现根本停不下来。第一次发现原来游戏可以这么设计，可以这么随心所欲。我记得印象最深刻的一次是周六下午，吃完饭一点开始玩，中途没喝水没去厕所玩到了5点，丝毫没觉得很困或者无聊，全程保持着专注。我已经很久没体验到这么长时间的专注了，塞尔达做到了。</p>
<p>塞尔达是一个公主的名字，游戏的主线剧情很俗套，公主被大魔王抓走了，主人公林克需要打败大魔王救公主。虽然主线剧情很简单，但是游戏中没有那种十分强制的要求，比如在特定的时间点必须要完成什么任务之类的，当然也包括救公主这件事情。我在新手村里到处闲逛，走过新手村的每个角落。在神庙屋顶上看夕阳，白天在精灵森林抓野猪，晚上捉萤火虫，采蘑菇，抓青蛙，在河里抓鲈鱼，驯服马当自己坐骑…第一次遇到大一点的boss也会惊慌失措，遇到激光机器人还不会用盾反…这些游戏体验会让我忘记了我的使命，还救什么公主，多累呀，到处逛逛也挺舒服的。总之整个游戏里有很多值得探索的东西，许多未知。游戏的乐趣不是单纯的为了通关，而是去体验未知。体验未知，不就是我们这一生要做的事情吗？即使什么都不做，也可以坐在悬崖边上看着太阳下山，在夜里看看萤火虫，在河里抓鱼…这个游戏只卖300块，我觉得可以玩一年，卖300太亏了。</p>
<p>游戏玩久了对身体不好，就像上班一样，坐一天到晚腰酸背疼的，严重影响了身体健康。作为社畜人要珍爱自己的命，不然就没机会看到社会主义实现的那一天了。最近喜欢上了跑步，也感受到了跑步带来的变化。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3117395-5e4b12b101d77c71.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/750/format/webp" alt="今年第一次户外跑"></p>
<p>疫情以来，就再也没去公园跑步了。上次跑完1.5km发现并没有想象中那么辛苦。长期以来我觉得自己心肺不咋地，动不动就气喘吁吁。现在在户外一口气3km基本没问题，室内跑步机5km也很轻松。与之带来的变化是走路更轻松了，似乎像带风一样，这种正向反馈给人带来的愉悦是很开心的。即使体重也没有多少变化，但看到身体素质在变强，想着能活地更久一点，嘴角不禁就上扬了。</p>
<p>我曾痴迷于代码背后优雅亦或复杂的设计思想，也享受编码之外各种未知体验带来的快乐。一生很长，要滚烫地活着呀！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在思考一个问题，步入码农行业这么久了，除了编码带来的乐趣，到底还有没有别的乐趣。因为我本身专业就是计算机，从小对计算器有着很大的兴趣，即使存在着傻逼业务傻逼产品经理会提出奇葩的要求，也不会觉得编码很枯燥。纯粹的编码不会枯燥，纯粹的技术也不会枯燥。我觉得学习新技术就像
    
    </summary>
    
      <category term="BEYOND CODING" scheme="http://www.wei-dong.top/categories/BEYOND-CODING/"/>
    
    
      <category term="编码之外" scheme="http://www.wei-dong.top/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96/"/>
    
  </entry>
  
  <entry>
    <title>OpenTracing初探</title>
    <link href="http://www.wei-dong.top/2020/09/08/opentracing%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.wei-dong.top/2020/09/08/opentracing初探/</id>
    <published>2020-09-08T09:37:23.000Z</published>
    <updated>2020-09-08T09:48:29.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>OpenTracing分布式链路追踪的一种标准。根据google的论文Dapper，很多厂商根据这篇论文做出了自己的实现，然而每个厂商的实现都不同，因此如果你的分布式应用需要接入某个实现，那必须使用这个厂商提供的API，若哪一天不想用这个厂商的实现了咋办？得去改代码。因此出现了opentracing标准。这好比JSR规范，只提出API定义，至于厂商怎么去实现我不管，大家想用的话只需要使用这个标准API就行。</p>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>opentracing提供多语言的支持，如Java/Python/Ruby等。这里使用Java语言演示一下如何使用。<br>首先需要引入依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;io.opentracing&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;opentracing-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.33.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;!--这里使用的是jaeger的实现--&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;io.jaegertracing&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;jaeger-client&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;$&#123;jaeger.version&#125;&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Tracer tracer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">(Tracer tracer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.tracer = tracer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String hello)</span></span>&#123;</div><div class="line">        Span span = tracer.buildSpan(<span class="string">"say-hello"</span>).start();</div><div class="line">        System.out.println(hello);</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String hello = <span class="string">"hello world"</span>;</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Hello(initTracer(<span class="string">"hello-world"</span>)).sayHello(hello);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JaegerTracer <span class="title">initTracer</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        Configuration.SamplerConfiguration samplecfg = Configuration.SamplerConfiguration.fromEnv().withType(<span class="string">"const"</span>).withParam(<span class="number">1</span>);</div><div class="line"></div><div class="line">        Configuration.ReporterConfiguration reporterConfiguration = Configuration.ReporterConfiguration.fromEnv().withLogSpans(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        Configuration configuration = <span class="keyword">new</span> Configuration(name).withSampler(samplecfg).withReporter(reporterConfiguration);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> configuration.getTracer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有个核心的API <code>Tracer</code>,这个类用于创建Span。<br>什么是Span呢？简而言之可以理解为一个调用，这里描述可能太过于抽象。可以具体为一次http请求，一次rpc调用。一个Span里可能会出现多个Span，比如你的一次http请求中会调用多个rpc服务，而rpc服务又会去调用别的rpc服务…这样这些Span就形成了类似父子关系的结构，用术语来描述就是DAG（Direct Acyclic Graph）。当然这里描述的仅仅是最常见的一种情况，也就是父子关系的情况。<br><img src="https://pic2.zhimg.com/v2-05e888f1a7ea2e975673db6135b72a75_r.jpg" alt><br>参考这张图可以很轻松的理解Span。<br>代码中的方法<code>sayHello()</code>通过Tracer创建了一个名为<code>say-hello</code>的Span，方法结束后通过调用finish完成Span的终止。一个Span就这样简单的完成了，看上去是不是非常直观呢！</p>
<p>当然这仅仅是在代码层面的，有小伙伴可能会产生疑问，我写这些代码有啥用？之前说到，Tracer仅仅是一个标准，实现的厂家有很多，因此这里选择一个实现这个标准的厂家即可。<code>initTracer</code>方法初始化一个名叫<code>hello-world</code>的服务，其实现为Jaeger，这样我们的一些trace和span信息就能在Jaeger提供的控制面板中看到了。当然你也可以不选择Jaeger的实现，使用Zipkin也是一样的。<br>如果选择Jaeger实现，那需要启动一个Jaeger的服务，这里直接省事使用Docker跑一个Jaeger容器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker run \</div><div class="line">  --rm \</div><div class="line">  -p 6831:6831/udp \</div><div class="line">  -p 6832:6832/udp \</div><div class="line">  -p 16686:16686 \</div><div class="line">  jaegertracing/all-in-one:1.7 \</div><div class="line">  --log-level=debug</div></pre></td></tr></table></figure></p>
<p>这里的端口配置和<code>initTracer</code>方法中config中配置的默认端口应该是一样的，也就是这些config用于和Jaeger服务进行通信。将这个程序跑起来，就会在Jaeger的UI界面上看到<code>sayHello()</code>方法相关的调用信息了。<br><img src="https://upload-images.jianshu.io/upload_images/3117395-c9fa431385fcd506.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="opentracing"></p>
<p>说了这么多，貌似和想象中的有点差距。不着急，这仅仅才开始。</p>
<p>之前说到，一个Span里会有多个子Span，具体体现在代码中是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String helloTo)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"say-hello"</span>).start();</div><div class="line">    span.setTag(<span class="string">"hello-to"</span>, helloTo);</div><div class="line"></div><div class="line">    String helloStr = formatString(span, helloTo);</div><div class="line">    printHello(span, helloStr);</div><div class="line"></div><div class="line">    span.finish();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span>  String <span class="title">formatString</span><span class="params">(Span rootSpan, String helloTo)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"formatString"</span>).asChildOf(rootSpan).start();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        String helloStr = String.format(<span class="string">"Hello, %s!"</span>, helloTo);</div><div class="line">        span.log(ImmutableMap.of(<span class="string">"event"</span>, <span class="string">"string-format"</span>, <span class="string">"value"</span>, helloStr));</div><div class="line">        <span class="keyword">return</span> helloStr;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">(Span rootSpan, String helloStr)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"printHello"</span>).asChildOf(rootSpan).start();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(helloStr);</div><div class="line">        span.log(ImmutableMap.of(<span class="string">"event"</span>, <span class="string">"println"</span>));</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先使用<code>formatString</code>来格式化，接着使用<code>printHello</code>来打印到控制台。这里就很能体现出父子Span到层级关系了。通过<code>asChildOf</code>方法来表示这个层级关系，即：<code>formatString</code>和<code>printHello</code>的调用Span是<code>sayHello</code>方法的子Span。运行一下程序，在后台UI中看到的就是这样的层级关系了：<br><img src="https://upload-images.jianshu.io/upload_images/3117395-dd53ae32bdf1415c.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="span 层级"></p>
<p>当然这里还有同感span打印日志操作，语义十分清晰，这里不做过多解释了。<br>看到这里，似乎觉得这代码写起来是不是有点冗余了？没错，在方法之间非得把rootSpan拿来传递下去，显得格外麻烦。因此opentracing提供一种好用的方式，简化了方法之间传递rootSpan的复杂性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String helloTo)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"say-hello"</span>).start();</div><div class="line">    <span class="keyword">try</span> (Scope scope = tracer.scopeManager().activate(span)) &#123;</div><div class="line">        span.setTag(<span class="string">"hello-to"</span>, helloTo);</div><div class="line"></div><div class="line">        String helloStr = formatString(helloTo);</div><div class="line">        printHello(helloStr);</div><div class="line">    &#125; <span class="keyword">finally</span>&#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span>  String <span class="title">formatString</span><span class="params">(String helloTo)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"formatString"</span>).start();</div><div class="line">    <span class="keyword">try</span> (Scope scope = tracer.scopeManager().activate(span)) &#123;</div><div class="line">        String helloStr = String.format(<span class="string">"Hello, %s!"</span>, helloTo);</div><div class="line">        span.log(ImmutableMap.of(<span class="string">"event"</span>, <span class="string">"string-format"</span>, <span class="string">"value"</span>, helloStr));</div><div class="line">        <span class="keyword">return</span> helloStr;</div><div class="line">    &#125; <span class="keyword">finally</span>&#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">(String helloStr)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"printHello"</span>).start();</div><div class="line">    <span class="keyword">try</span> (Scope scope = tracer.scopeManager().activate(span)) &#123;</div><div class="line">        System.out.println(helloStr);</div><div class="line">        span.log(ImmutableMap.of(<span class="string">"event"</span>, <span class="string">"println"</span>));</div><div class="line">    &#125; <span class="keyword">finally</span>&#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>activate</code>方法来简化rootSpan在方法之间的传递。同时使用try with resource语法巧妙的对资源进行控制。其实现原理是线程上下文。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScopeManager</span> <span class="keyword">implements</span> <span class="title">ScopeManager</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalScope&gt; tlsScope = <span class="keyword">new</span> ThreadLocal&lt;ThreadLocalScope&gt;();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Scope <span class="title">activate</span><span class="params">(Span span)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalScope(<span class="keyword">this</span>, span);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Span <span class="title">activeSpan</span><span class="params">()</span> </span>&#123;</div><div class="line">        ThreadLocalScope scope = tlsScope.get();</div><div class="line">        <span class="keyword">return</span> scope == <span class="keyword">null</span> ? <span class="keyword">null</span> : scope.span();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalScope</span> <span class="keyword">implements</span> <span class="title">Scope</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocalScopeManager scopeManager;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Span wrapped;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocalScope toRestore;</div><div class="line"></div><div class="line">    <span class="comment">// 创建的时候，先拿到之前保存的存到变量中，再将自己放进线程上下文</span></div><div class="line">    ThreadLocalScope(ThreadLocalScopeManager scopeManager, Span wrapped) &#123;</div><div class="line">        <span class="keyword">this</span>.scopeManager = scopeManager;</div><div class="line">        <span class="keyword">this</span>.wrapped = wrapped;</div><div class="line">        <span class="keyword">this</span>.toRestore = scopeManager.tlsScope.get();</div><div class="line">        scopeManager.tlsScope.set(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 关闭的时候，将上次的信息恢复</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (scopeManager.tlsScope.get() != <span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">// This shouldn't happen if users call methods in the expected order. Bail out.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        scopeManager.tlsScope.set(toRestore);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Span <span class="title">span</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> wrapped;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为try语句在方法中是嵌套的，因此采用这样的方式最终的效果是都能找到上次的span。理解起来可能有点费力，<code>tlsScope</code>实例一直被传递，因为仅此一个实例（并没有显式去new，而是通过this去传递的），而<code>ThreadLocalScope</code>类却会每次创建出来，与此同时每次的span也会不一样。通过<code>toRestore</code>变量来不断地倒转，每次activate调用，创建新的Scope，放进上下文，try执行完，再将上次的Scope放进上下文。一来一回形成闭环有头有尾，类似括号匹配。<br>这种方式和之前采用方法中传递rootSpan变量是一样的效果。</p>
<p>看到这里，似乎也没觉得有太大的用处，因为这仅仅是在进程内进行trace，进程之间的trace如何实现呢？先看看这个demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String helloTo)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"say-hello"</span>).start();</div><div class="line">    <span class="keyword">try</span> (Scope scope = tracer.scopeManager().activate(span)) &#123;</div><div class="line">        span.setTag(<span class="string">"hello-to"</span>, helloTo);</div><div class="line"></div><div class="line">        String helloStr = formatString(helloTo);</div><div class="line">        printHello(helloStr);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">formatString</span><span class="params">(String helloTo)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"formatString"</span>).start();</div><div class="line">    <span class="keyword">try</span> (Scope scope = tracer.scopeManager().activate(span)) &#123;</div><div class="line">        String helloStr = getHttp(<span class="number">8081</span>, <span class="string">"format"</span>, <span class="string">"helloTo"</span>, helloTo);</div><div class="line">        span.log(ImmutableMap.of(<span class="string">"event"</span>, <span class="string">"string-format"</span>, <span class="string">"value"</span>, helloStr));</div><div class="line">        <span class="keyword">return</span> helloStr;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">(String helloStr)</span> </span>&#123;</div><div class="line">    Span span = tracer.buildSpan(<span class="string">"printHello"</span>).start();</div><div class="line">    <span class="keyword">try</span> (Scope scope = tracer.scopeManager().activate(span)) &#123;</div><div class="line">        getHttp(<span class="number">8082</span>, <span class="string">"publish"</span>, <span class="string">"helloStr"</span>, helloStr);</div><div class="line">        span.log(ImmutableMap.of(<span class="string">"event"</span>, <span class="string">"println"</span>));</div><div class="line">    &#125; <span class="keyword">finally</span>&#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getHttp</span><span class="params">(<span class="keyword">int</span> port, String path, String param, String value)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        HttpUrl url = <span class="keyword">new</span> HttpUrl.Builder().scheme(<span class="string">"http"</span>).host(<span class="string">"localhost"</span>).port(port).addPathSegment(path)</div><div class="line">                .addQueryParameter(param, value).build();</div><div class="line">        Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(url);</div><div class="line">        Request request = requestBuilder.build();</div><div class="line">        Response response = client.newCall(request).execute();</div><div class="line"></div><div class="line">        Tags.HTTP_STATUS.set(tracer.activeSpan(), response.code());</div><div class="line">        <span class="keyword">if</span> (response.code() != <span class="number">200</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad HTTP result: "</span> + response);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> response.body().string();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与之前不同的是，这里的格式化字符串和输出方法都不是在同一个进程执行的，而是跨进程了。这两个操作通过http进行远程方法调用。跑一下在UI界面中依然能看到与之前相同的结果；<br><img src="https://upload-images.jianshu.io/upload_images/3117395-a577c0874994f090.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="跨进程"><br>是不是发现了有什么不对？没错，按道理说跨进程调用，被调用的那一方也应该被trace到，而这里却只有发起方的trace记录，和之前在同一个进程内调用的根本没什么区别。因此这里需要对服务的提供方进行trace一下。</p>
<p>最通俗的解释就是怎么把我的rootSpan传递给别的进程。opentracing api提供了两种方式：</p>
<ul>
<li>inject(spanContext, format, carrier) </li>
<li>extract(format, carrier)<br>顾名思义，一个是注入，另一个是抽取。其中的format参数也提供了如下可选：</li>
<li>TEXT_MAP where span context is encoded as a collection of string key-value pairs,</li>
<li>BINARY where span context is encoded as an opaque byte array,</li>
<li>HTTP_HEADERS, which is similar to TEXT_MAP except that the keys must be safe to be used as HTTP headers.<br>第一个最简单，键值对，可以理解为一个map；第二个是二进制格式；第三个是基于http的头，其实也是键值对格式。而carrier则是根据format来确定的，如果format=TEXT_MAP，那么carrier就提供一个针对键值对的写入入口类似put(key,value).<br>接下来对上述代码进行改造。<br>首先是注入，简单理解为在发起调用的那一头把自己的rootSpan写到被调用方中去。因此这里使用inject方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getHttp</span><span class="params">(<span class="keyword">int</span> port, String path, String param, String value)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        HttpUrl url = <span class="keyword">new</span> HttpUrl.Builder().scheme(<span class="string">"http"</span>).host(<span class="string">"localhost"</span>).port(port).addPathSegment(path)</div><div class="line">                .addQueryParameter(param, value).build();</div><div class="line">        Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(url);</div><div class="line">        </div><div class="line">        Span activeSpan = tracer.activeSpan();</div><div class="line">        Tags.SPAN_KIND.set(activeSpan, Tags.SPAN_KIND_CLIENT);</div><div class="line">        Tags.HTTP_METHOD.set(activeSpan, <span class="string">"GET"</span>);</div><div class="line">        Tags.HTTP_URL.set(activeSpan, url.toString());</div><div class="line">        tracer.inject(activeSpan.context(), Format.Builtin.HTTP_HEADERS, <span class="keyword">new</span> RequestBuilderCarrier(requestBuilder));</div><div class="line"></div><div class="line">        Request request = requestBuilder.build();</div><div class="line">        Response response = client.newCall(request).execute();</div><div class="line"></div><div class="line">        Tags.HTTP_STATUS.set(activeSpan, response.code());</div><div class="line">        <span class="keyword">if</span> (response.code() != <span class="number">200</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad HTTP result: "</span> + response);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> response.body().string();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        Tags.ERROR.set(tracer.activeSpan(), <span class="keyword">true</span>);</div><div class="line">        tracer.activeSpan().log(ImmutableMap.of(Fields.EVENT, <span class="string">"error"</span>, Fields.ERROR_OBJECT, e));</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBuilderCarrier</span> <span class="keyword">implements</span> <span class="title">io</span>.<span class="title">opentracing</span>.<span class="title">propagation</span>.<span class="title">TextMap</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request.Builder builder;</div><div class="line"></div><div class="line">    RequestBuilderCarrier(Request.Builder builder) &#123;</div><div class="line">        <span class="keyword">this</span>.builder = builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator() &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"carrier is write-only"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</div><div class="line">        builder.addHeader(key, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果不去深入源码实现，这里也能够猜到inject的操作是将span上下文信息通过键值对的形式写到了http header中了，包含url，method等信息。这样，客户端的trace就完成了，接下来再看看服务端的trace怎么处理。</p>
<p>前面提到inject对应的方法是extract，看看没改动之前的样子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Path</span>(<span class="string">"/format"</span>)</div><div class="line"><span class="meta">@Produces</span>(MediaType.TEXT_PLAIN)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatterResource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GET</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(@QueryParam(<span class="string">"helloTo"</span>)</span> String helloTo) </span>&#123;</div><div class="line">        String helloStr = String.format(<span class="string">"Hello, %s!"</span>, helloTo);</div><div class="line">        <span class="keyword">return</span> helloStr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看看改动之后的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(@QueryParam(<span class="string">"helloTo"</span>)</span> String helloTo, @Context HttpHeaders httpHeaders) </span>&#123;</div><div class="line">    Span span =  Tracing.startServerSpan(tracer, httpHeaders, <span class="string">"format"</span>);</div><div class="line">    <span class="keyword">try</span> (Scope scope = tracer.scopeManager().activate(span)) &#123;</div><div class="line">        String helloStr = String.format(<span class="string">"Hello, %s!"</span>, helloTo);</div><div class="line">        span.log(ImmutableMap.of(<span class="string">"event"</span>, <span class="string">"string-format"</span>, <span class="string">"value"</span>, helloStr));</div><div class="line">        <span class="keyword">return</span> helloStr;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        span.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Span <span class="title">startServerSpan</span><span class="params">(Tracer tracer, javax.ws.rs.core.HttpHeaders httpHeaders, String operationName)</span> </span>&#123;</div><div class="line">    <span class="comment">// format the headers for extraction</span></div><div class="line">    MultivaluedMap&lt;String, String&gt; rawHeaders = httpHeaders.getRequestHeaders();</div><div class="line">    <span class="keyword">final</span> HashMap&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">    <span class="keyword">for</span> (String key : rawHeaders.keySet()) &#123;</div><div class="line">        headers.put(key, rawHeaders.get(key).get(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Tracer.SpanBuilder spanBuilder;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        SpanContext parentSpanCtx = tracer.extract(Format.Builtin.HTTP_HEADERS, <span class="keyword">new</span> TextMapAdapter(headers));</div><div class="line">        <span class="keyword">if</span> (parentSpanCtx == <span class="keyword">null</span>) &#123;</div><div class="line">            spanBuilder = tracer.buildSpan(operationName);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            spanBuilder = tracer.buildSpan(operationName).asChildOf(parentSpanCtx);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">        spanBuilder = tracer.buildSpan(operationName);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// TODO could add more tags like http.url</span></div><div class="line">    <span class="keyword">return</span> spanBuilder.withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与之前不同的是增加了一个参数<code>HttpHeaders</code>，然后获取header中的键值对，通过extract方法将span上下文还原，作为当前span的父亲，最后打上tag信息。同理对于print方法也是如此，最终在Jeager UI中看到的会是这样：<br><img src="https://upload-images.jianshu.io/upload_images/3117395-dc4b6b9e45172ba7.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="RPC CALL"><br>这里多了几个span，因为将服务端的span也trace到了。</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>本文介绍了opentracing 的一些基础使用和主要概念，理解起来相对比较简单。上述的代码在使用上稍微不是很方便，因为需要开发者手工去针对trace做一下适配。然而opentracing生态提供了相关的库，如上述代码中针对okhttp的定制就可以使用现成的<a href="https://github.com/opentracing-contrib/java-okhttp" target="_blank" rel="external">okhttp</a>.<br>除了使用之外，你肯定对这些span信息如何上报到服务端很感兴趣，等有时间再回头看看书如何实现的。</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><a href="https://www.jianshu.com/p/82cd923191fb" target="_blank" rel="external">分布式全链路监控 – opentracing小试</a><br><a href="https://github.com/yurishkuro/opentracing-tutorial" target="_blank" rel="external">opentracing-tutorial</a><br><a href="https://zhuanlan.zhihu.com/p/83654617" target="_blank" rel="external">分布式追踪系统 – Opentracing</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;what&quot;&gt;&lt;a href=&quot;#what&quot; class=&quot;headerlink&quot; title=&quot;what&quot;&gt;&lt;/a&gt;what&lt;/h3&gt;&lt;p&gt;OpenTracing分布式链路追踪的一种标准。根据google的论文Dapper，很多厂商根据这篇论文做出了自己的实现，然
    
    </summary>
    
      <category term="笔记" scheme="http://www.wei-dong.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="入门，opentracing" scheme="http://www.wei-dong.top/tags/%E5%85%A5%E9%97%A8%EF%BC%8Copentracing/"/>
    
  </entry>
  
  <entry>
    <title>面试二三事之我想杯喝水</title>
    <link href="http://www.wei-dong.top/2020/08/26/%E9%9D%A2%E8%AF%95%E4%BA%8C%E4%B8%89%E4%BA%8B%E4%B9%8B%E6%88%91%E6%83%B3%E5%96%9D%E6%9D%AF%E6%B0%B4/"/>
    <id>http://www.wei-dong.top/2020/08/26/面试二三事之我想喝杯水/</id>
    <published>2020-08-26T13:37:23.000Z</published>
    <updated>2020-08-26T15:22:57.165Z</updated>
    
    <content type="html"><![CDATA[<p>深圳这时候的天气，出趟门衣服就得汗湿透。然而这周已经出去面试了四个公司了。<br>我想记录的是在这几次面试过程中我的一些感受和经历。有吐槽也有欣喜。</p>
<p>周一上午去中通快递，离我住的地儿18公里左右。随着公交车窗外的风景变得越来越萧条，我后悔的心情也随之加重。在我的印象中中通也是一个大厂了，到了办公楼之后我否定了我的印象。面试通知上写的是在3A层，我心想应该是三楼，然后在整个三楼没找到A的房间。后来才知道四楼不能叫做四楼，有忌讳，所以叫3A。我好像发现什么秘密似的跑到了四楼，终于找到他们的办公室。昏暗的灯光，低矮的楼层，有点让我喘不上气来。格子间内安安静静，似乎每个人都在忙自己的东西。人事带我进一个狭小的会议室，桌子旁边还放着一个机房服务器，嗡嗡的风扇声让会议室的温度上升了很多，我局促不安地站在那里，想着人事会不会给我倒杯水，毕竟外面天气还是挺热的。然后一个穿着拖鞋的看似沉默寡言的技术大佬进来，一通常规不常规的技术问题输出，全程盯着简历上百十来个字，没有任何眼神交流。最后问我要多少钱，我说出了我的期望他有所变化，然后象征性地问我还有什么问题，在我正准备提问的时候他马上说既然没什么问题今天就先到这里，要不你先回去吧，然后一个人默默地离开了会议室，顺便还把会议室的灯关了。我坐在椅子上突然觉得这里的空调好像不怎么制冷，昏暗的房间里我感受到孤独在慢慢袭来，然后我缓缓起身，环顾四周，默默走出大门，回头看了他们一眼，他们好像确实是那么忙，没人说话，昏暗的灯光，逼仄的格子间以及低矮的楼层…走出办公楼，11点的太阳晒地我脑门出汗，我赶紧加快了脚步。还得去吃午饭呢。</p>
<p>随之而来的是下午的小公司。地址离我住的地儿很近，10分钟的车程。科兴科学园是深圳加班最晚的地方，令所有程序员闻风丧胆。我抱着忐忑的情绪进去了。同一楼层其他公司都有前台有门脸儿，这个小公司没得。办公室在一个犄角旮旯处，我像在迷宫里寻找出路一样找到的。按了门铃一个面无表情的小菇凉给我打开了门，然后领我去一个小会议室，让我在这里先等着。会议室桌子上摆了盆绿植，不知道为什么我喜欢坐在绿植旁边。可能是我看到绿植盆里有水吧。会议室外面有工人在装修，有几个工人举着水杯一饮而尽，看到这里我不禁抿了抿嘴角。要是这时候有瓶快乐水该有多好呀。实在不行一杯冰水也行呀。接着一个很壮的大哥进来了，一看就是广东人。他没有准备我的简历，问我带了没，我回答没有，然后他似乎想去找行政打印，我说我带了个pad你用我pad看，凑合一下吧。接着就随便聊了技术问题，有些我是真没答上，不过我也觉得他问的方式不是很合理。但是我觉得挑战还是很大，也能遇见会很难受。不知会不会给机会。出了写字楼，下午4点的太阳是真毒，我的眼睛都不太敢睁开了。今天流了几斤汗，很渴了，得赶紧回去喝杯冰可乐。</p>
<p>第二天的面试不算太远，车程大概半小时。这个写字楼很高端，第一次见到电梯选楼层是在电梯外面的。办公室在19楼，我开始以为是9楼，然后上去发现没找到。最后核实后继续按19楼，死活显示楼层错误。随后我灵机一动，要不我一层一层的试吧，这样最多需要再按10下就一定能到19楼了。事实上最多能输入11，因为我到了11楼后再输入上面的楼层都提示错误。那时候我就瞬间明白了，我真是个天才。到了19楼前台让我填个表格，各种信息都让你写完。坐在休闲区里望着窗外，我陷入了沉思。当时外面的风景是这样的.<br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/building.jpg?raw=true" alt="钢铁森林"></p>
<p>不知道什么时候起，我开始厌倦这样的写字楼。或者是说我厌倦的仅仅是这里的写字楼而已。外面一片荒凉，除了门前的八车道以及来来往往的大货车之外，似乎也见不到什么活物在活动。身处在这样的钢铁森林里我顿时感到喘不过气来。虽然这里的装修很互联网，但我却没有任何向往，我觉得很压抑，甚至后悔过来。不知道过去了多久，前台问我写完了没有，接着就领着我去一个小会议室，他们给会议室取名都是用深圳的地名如小梅沙，华侨城之类的。我记得云集是用的星座比如白羊座，水瓶座。那个小会议室的灯光我觉得让人觉得很不舒服，给人一种特别暧昧的感觉。椅子上红色的。墙壁在灯光的映射下是粉色的。如果这时候能给我倒杯水，我心里可能会好受很多，但是并没有。我在那样的房间里等了差不多五分钟，来了个看似很厉害的面试官，照着我简历圈圈点点，但是并没有问到一些技术上的东西。随着就让我等一下，几分钟后前台打开会议室门告诉我我让我先回去。那时候我内心似乎有好几匹草泥马在散步。这样的场景下，我可能会觉得在筛选简历的时候他们都没做到认真筛选，把我这样的根本不符合招聘要求的都约进来了。出了写字楼大门，我回头看了一眼，哇这楼是真高，阳光也特别刺眼，我也是真的有点渴了。去公交站台的时候还遇到个大妈问路，我给她用手机导航指了指，她高兴地对我说谢谢了靓仔。那时候我心里特别高兴，之前压抑的情绪一下子就消失了。原来帮助别人是多么快乐的事情呀。</p>
<p>今天下午去顺丰，有俩面试官，其中有个女技术。看上去做技术很多年了，从谈吐上都能体现出技术水准和涵养都很高，另外一个是小伙，在沟通的过程中他会和你有眼神交流。这让我感受到了尊重，最主要的是这小伙一开始给我倒了杯水，他说看你出了这么多汗给你倒杯水吧，我高兴地连胜答谢。就这样愉快的聊了一个多小时，我喝了好几杯水。至于聊什么都不重要了，毕竟我终于喝到了水。</p>
<p>这天气出去面试也很辛苦，最后总结是出门面试可能有不给你倒水喝风险，请随身携带饮用水。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深圳这时候的天气，出趟门衣服就得汗湿透。然而这周已经出去面试了四个公司了。&lt;br&gt;我想记录的是在这几次面试过程中我的一些感受和经历。有吐槽也有欣喜。&lt;/p&gt;
&lt;p&gt;周一上午去中通快递，离我住的地儿18公里左右。随着公交车窗外的风景变得越来越萧条，我后悔的心情也随之加重。在我
    
    </summary>
    
      <category term="BEYOND CODING" scheme="http://www.wei-dong.top/categories/BEYOND-CODING/"/>
    
    
      <category term="编码之外，碎碎念" scheme="http://www.wei-dong.top/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96%EF%BC%8C%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Java中的“锁”事之ReentrantLock</title>
    <link href="http://www.wei-dong.top/2020/07/12/Java%E4%B8%AD%E7%9A%84%E2%80%9C%E9%94%81%E2%80%9D%E4%BA%8B%E4%B9%8BReentrantLock/"/>
    <id>http://www.wei-dong.top/2020/07/12/Java中的“锁”事之ReentrantLock/</id>
    <published>2020-07-12T04:37:23.000Z</published>
    <updated>2020-07-12T04:31:56.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈“锁”"><a href="#谈谈“锁”" class="headerlink" title="谈谈“锁”"></a>谈谈“锁”</h2><p>说起Java的锁，脑袋里第一反应就是关键字<code>synchronized</code>.这是Java提供的基于语言级别的锁，底层是通过cup指令来实现的。对于使用者来说非常简单，容易上手。然而也有一些小缺陷。在早期的jvm中<code>synchronized</code>性能不是太好，而且加锁和释放锁不是很灵活，比如只能在程序正常执行完成和抛出异常时释放锁，对锁的持有很“执着”，获取锁的时候没法设置超时时间等。</p>
<p>除了jvm层面实现的锁之外，JDK中也提供了另外的锁实现。下面从一个例子说起。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">boolean</span> b = lock.hasQueuedThreads();</div><div class="line">            System.out.println(<span class="string">"t1"</span>+ b);</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"t1 start working..."</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    System.out.println(<span class="string">"t1 do working..."</span>);</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">boolean</span> b = lock.hasQueuedThreads();</div><div class="line">            System.out.println(<span class="string">"t2"</span>+ b);</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"t2 start working..."</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                    System.out.println(<span class="string">"t2 do working... "</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line"></div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">boolean</span> b = lock.hasQueuedThreads();</div><div class="line">            System.out.println(<span class="string">"t3"</span>+ b);</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"t3 start working..."</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">                    System.out.println(<span class="string">"t3 do working... "</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        t1.join();</div><div class="line">        t2.join();</div><div class="line">        t3.join();</div><div class="line">        System.out.println(<span class="string">"++++finished++++"</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>很容易看出，demo中使用了<code>ReentrantLock</code>来作为锁来对三个线程进行协调，确保三个线程顺序执行。使用方式也很简单：在需要保护的代码前后使用<code>lock</code>和<code>unlock</code>即可。</p>
<p>既然<code>ReentrantLock</code>能提供和<code>synchronized</code>一样的锁机制，那必须得看看到底这个“锁”有什么黑魔法。</p>
<h2 id="ReentrantLock和AbstractQueuedSynchronizer之加锁"><a href="#ReentrantLock和AbstractQueuedSynchronizer之加锁" class="headerlink" title="ReentrantLock和AbstractQueuedSynchronizer之加锁"></a>ReentrantLock和AbstractQueuedSynchronizer之加锁</h2><p>加锁其实是一个很容易理解的过程，其中我认为有点绕的是node结点之间链的摘除和建立，毕竟数据结构的基础还是比较弱，稍微多绕几圈就被整蒙圈了。<br>在研究AQS锁实现之前得聊一下什么是“公平”和“非公平”锁。所谓公平锁遵循先来的先获得锁，翻译成白话就是大家都是在排队的；而非公平锁则反之，只要有获取锁的机会，那就不顾一切去抢，不排队。</p>
<p><code>ReentrantLock</code>默认的实现为非公平锁。理论上来说非公平锁比公平锁效率更高。当然也可以通过指定参数来区分是否使用公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div><div class="line"><span class="comment">// ReentrantLock中的lock方法其实</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">            setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">        <span class="keyword">else</span></div><div class="line">            acquire(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>NonfairSync</code>作为内部类继承自<code>Sync</code>,而<code>Sync</code>继承自<code>AbstractQueuedSynchronizer</code>。<br>说白了其实就是个模版方法，AQS提供基础实现，子类根据自己需要去自定义不同的逻辑。</p>
<p>接下来根据demo中的几个关于锁的基本操作（lock）来看看其实现细节。</p>
<p>首先lock方法中的<code>compareAndSetState(0, 1)</code>语义是如果当前的值为0，那就更新为1.这是一个基于cpu指令的原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * The synchronization state.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * The current owner of exclusive mode synchronization.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</div><div class="line">    exclusiveOwnerThread = thread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果更新成功，那就返回true。而这个原子更新的字段为AQS的<code>state</code>。这个字段简单理解为获取锁的标志，整个锁的核心都是围绕着这个字段来完成的。<br>如果更新成功，那么将当前线程置为<code>exclusiveOwnerThread</code>。这个变量表示当前持有锁的线程。<br>完整的语义即：当某个线程中的逻辑调用lock方法后，lock对象中的state字段由0更新为1，当前线程持有锁。<br>那这个线程没执行完操作，还没释放掉锁，后续的线程怎么办？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div><div class="line"><span class="comment">// AQS中的实现 必须得由子类重写</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div><div class="line"><span class="comment">// NonfairSync中的重写</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Performs non-fair tryLock.  tryAcquire is implemented in</div><div class="line"> * subclasses, but both need nonfair try for trylock method.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在某个线程获取到了锁之后还没释放，其他线程也执行到lock方法，这时候由于lock对象中state为1，因此没办法更新，所以执行<code>acquire</code>逻辑。而<code>acquire</code>调用<code>nonfairTryAcquire</code>方法。<br>首先获取state的值，在我们的demo中由于之前的线程没有释放掉锁，这里的c的值为1，而当前线程和lock对象中持有的线程不一样（getExclusiveOwnerThread返回之前持有锁的线程对象）因此这里直接返回false。<br>当线程中执行的任务很短的时候，短到几纳秒，获取到锁的线程马上释放掉了。这个state值从1变成了0，这里其他线程就有机会再次去“争夺”一次锁，同样使用cas操作将state值从0到1，同时将当前线程置为lock对象的<code>exclusiveOwnerThread</code>字段。最后返回true，表示获取到了锁。<br>还有一种情形，一个线程多次去lock，这里lock对象中持有的线程锁同一个线程，因此进入到<code>current==getExclusiveOwnerThread()</code>逻辑。做法也很简单，将state再加1即可,这个线程依旧能获取到锁。这就是所谓的可重入（Reentrant），即可以多次获取一个锁。</p>
<p>当<code>tryAcquire</code>方法返回为真时，表示当前线程成功获取到了锁，整个lock逻辑已经完成，后面的<code>acquireQueued</code>方法就直接忽略掉。<br>这里小结一下：</p>
<ul>
<li>AQS使用state变量来标记锁是否被线程获取，使用变量<code>exclusiveOwnerThread</code>标记获取锁的线程；</li>
<li>锁可以被多次获取，这样的锁叫做可重入锁（Reentrant），通过state标记获取锁的次数，同理锁被获取多少次就得释放多少次，不然锁不会被释放；</li>
</ul>
<p>接下来看看<code>acquireQueued</code>方法的实现。上面说道，当尝试获取锁成功的时候，lock方法就结束了，如果尝试获取锁失败呢？如果失败就进入到<code>acquireQueued</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这里是两个方法<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，先调用<code>addWaiter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里，出现了新的数据结构<code>Node</code>，为了更加方便理解，现在不得不对这个数据结构进行说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * waitStatus value to indicate the next acquireShared should</div><div class="line">         * unconditionally propagate</div><div class="line">         */</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div><div class="line"></div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line">        </div><div class="line">        <span class="keyword">volatile</span> Node prev;</div><div class="line"></div><div class="line">        <span class="keyword">volatile</span> Node next;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The thread that enqueued this node.  Initialized on</div><div class="line">         * construction and nulled out after use.</div><div class="line">         */</div><div class="line">        <span class="keyword">volatile</span> Thread thread;</div><div class="line"></div><div class="line">        Node nextWaiter;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Returns true if node is waiting in shared mode.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</div><div class="line">            Node p = prev;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></div><div class="line">            <span class="keyword">this</span>.nextWaiter = mode;</div><div class="line">            <span class="keyword">this</span>.thread = thread;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></div><div class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</div><div class="line">            <span class="keyword">this</span>.thread = thread;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先是俩静态变量，这个变量仅仅是一个标记，并没有实际用途：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line"><span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<p>因为AQS有两种模式：独占和共享。独占模式例如demo中的<code>ReentrantLock</code>，而共享模式如并发工具包中的<code>CountDownLatch</code>。接着就是<code>waitStatus</code>变量，同时指定了几个枚举。然后就是<code>thread</code>当前线程，以及前驱后继结点。不难看出这是一个双端链表结构。<code>nextWaiter</code>字段暂时按下不表。</p>
<p>继续看<code>addWaiter</code>方法，由于传入的mode为<code>Node.EXCLUSIVE</code>，因此这里创建的node的<code>nextWaiter</code>字段的值为<code>null</code>，将当前要获取锁的线程也放进node里，然后尝试去“操作”这个node。实际上就是看这个AQS中node队列除了当前创建的还有没有别的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Head of the wait queue, lazily initialized.  Except for</div><div class="line"> * initialization, it is modified only via method setHead.  Note:</div><div class="line"> * If head exists, its waitStatus is guaranteed not to be</div><div class="line"> * CANCELLED.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Tail of the wait queue, lazily initialized.  Modified only via</div><div class="line"> * method enq to add new wait node.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</div><div class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></div><div class="line">    Node pred = tail;</div><div class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</div><div class="line">            pred.next = node;</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    enq(node);</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的<code>tail</code>和<code>head</code>都是AQS中的变量，用于操控node链表。他们的更新都是使用cas实现的，保证原子性。如果AQS中没有node链表（没有形成），head和tail都是null，直接走<code>enq</code>逻辑，然后将新创建的这个node返回，如果AQS中有结点存在呢，那就直接将创建的node变成tail。<code>compareAndSetTail(pred, node)</code>的语义为，如果当前tail的值为pred，那么将其更新为node。然后修改后继指针，返回node结点。</p>
<p>再看看AQS中的结点为空的时候：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑很清晰，这里进一步判断了一下tail是否为空，如果是真为空，那就新建一个node结点作为头结点，同时将tail指向头结点。这时候头结点就是尾结点，且结点内没有数据，只是作为一个标志而已。然而并没有返回，因为是个死循环，头尾结点初始化成功之后，继续走else逻辑，同理将新创建的结点的前驱指向刚才新建的空结点，然后把tail指向自己（<code>Node node = new Node(Thread.currentThread(), mode);</code>）的结点。最后修改后继指针并返回。这个逻辑看起来比较绕，尤其是指针的操作让人眼花缭乱，通过画图会更容易理解。总结一句话就是：创建node链表，初始化tail和head指针，且head指针指向的是一个空node（仅仅有意义的事waitStatus=0，因为没给值，默认就是0）。而返回的新创建的node作为<code>acquireQueued</code>参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心逻辑又是一个死循环，首先获取刚才创建的node结点的前驱结点，如果前驱结点为head结点（空的结点），可以再给这个线程一次机会，尝试获取锁。<code>tryAcquire</code>之前说过，这里不赘述。如果运气好，获取到了（state从0到1）返回true，将当前结点设置为head，同时摘除链表关系，也就是那个空结点被释放了，这个时候head结点可不是空结点了，而是<code>Node node = new Node(Thread.currentThread(), mode);</code>创建出来的。最后返回false，获取锁成功。为什么要来这一出呢？因为如果之前获取锁的线程执行任务的时候，其他线程在尝试着排队的时候还是有机会去抢一下的，说不定哪一瞬间任务结束释放了锁其他线程刚好抢到了呢？当然这也是有前提的，当线程决定去排队，且是排第一个的时候才能有多一次机会去抢锁。这里有疑问了，这个不是非公平的么？为啥还得排第一个才能抢？其实并不矛盾，因为每个线程都至少有一次机会去抢锁，通过<code>tryAcquire</code>。只有没抢到的，打算排队的，排到第一个的线程有第二次机会。当然，就算某个线程排第一，多一次抢锁机会，也不一定必然抢到呀，因为别的线程依旧和这个线程一样，同样是通过<code>tryAcquire</code>来抢的，因此是公平的，严格来说不公平，因为排第一的线程多了一次机会。</p>
<p>如果这个排第一的倒霉鬼还是没获取到锁，那就很难受了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们先考虑前驱结点为空结点的情况，之前提到，空结点的<code>waitStatus</code>没有赋值，默认为0，因此这里直接走<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</code>逻辑，将其置为-1；最后返回false，然而for死循环的逻辑还没结束，还会继续尝试获取一下锁，如果还是没获取到，那就再次进入到<code>shouldParkAfterFailedAcquire</code>中，因为第一次循环中将其<code>waitStatus</code>从0设置为了-1，因此这里直接返回true，所以，当在ASQ内部中“排队”的线程数第一个，是有两次次额外的获取锁的机会的。<br>接着就是<code>parkAndCheckInterrupt</code>逻辑了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>park为停车的意思，这里理解为挂起也没太大毛病。说白了就等着呗，等到什么时候为止呢？那就得从unlock说起了。</p>
<h2 id="ReentrantLock和AbstractQueuedSynchronizer之释放锁"><a href="#ReentrantLock和AbstractQueuedSynchronizer之释放锁" class="headerlink" title="ReentrantLock和AbstractQueuedSynchronizer之释放锁"></a>ReentrantLock和AbstractQueuedSynchronizer之释放锁</h2><p>demo中的解锁方法<code>unlock</code>对应的实现逻辑为<code>release</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Releases in exclusive mode.  Implemented by unblocking one or</div><div class="line"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</div><div class="line"> * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</div><div class="line"> *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</div><div class="line"> *        can represent anything you like.</div><div class="line"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类似地，先尝试去释放一下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先把state值减回去，判断一下当前的线程是不是AQS中锁持有的线程，如果不是那就说明有问题。如果当state还原为0了说明锁被释放掉了，同时将当前AQS持有的线程置为空。最后将当前state值更新（更新为减1后的，这里并不一定是0）。正如上文提到过，如果加多次锁，那么也得释放多次。如果没获释放掉，那就说明当前锁依旧被持有。</p>
<p>如果更新state成功，那么还需要做的一件事就是处理node结点。如果AQS中的头结点不为空，且状态不是默认的初始化的0，那么就去唤醒后继结点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Wakes up node's successor, if one exists.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> node the node</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里逻辑也十分清晰，先更新结点的waitStatus，将其置为0.然后找到后面的结点，如果不是空，那就将其唤醒，和之前是park一一对应。这里还多了一段判断锁被取消的情况，注释中也写得很清晰，意思就是从node链表的尾部开始找，一直找到符合要求的结点将其唤醒。</p>
<p>唤醒了还没完，因为等待锁的线程被park了后还得继续执行后续的逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 锁释放之后 这里会继续执行</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>parkAndCheckInterrupt</code>返回的值为当前线程的中断状态，如果当前（获取锁的）线程被设置了中断标记，那么这个方法就直接返回true。即<code>interrupted=true</code>。<br>由于是死循环，同样的当前线程（被唤醒的）获取一下锁，因为AQS中的state已经还原了，所以这里能拿到，将当前结点设置为头结点，获取锁完成。由于可能存在当前获取锁的线程由于某种情况被设置了中断标记，那么就将其中断（也只是设置中断标记）。</p>
<p>相比获取锁的操作，释放锁容易很多。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文基于<code>ReentrantLock</code>锁的基础实现，对AQS的大致原理进行了比较粗略的分析。如AQS的底层结构，核心的API等。通过锁的基础操作，如加锁和释放锁背后的逻辑进行了详细解读。当然还有很多没有涉及到的地方，如条件队列，共享模式的实现，公平和非公平的体现等。当知道了AQS的原理之后，去理解这些主题也是非常轻松的。总的来说，AQS的代码量不算太多，读起来不是很吃力。</p>
<p>PS:在云笔记中发现18年的时候也写过一篇AQS的文章，现在居然一点印象都没有了，时间啊，是真残酷。<a href="http://note.youdao.com/s/dlp3lGS4" target="_blank" rel="external">2年前的笔记</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1yJ411v7er?p=11" target="_blank" rel="external">Java并发锁框架AQS(AbstractQueuedSynchronizer)原理从理论到源码透彻解析</a></p>
<p><a href="https://www.zhihu.com/question/41048032" target="_blank" rel="external">Java里一个线程调用了Thread.interrupt()到底意味着什么？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;谈谈“锁”&quot;&gt;&lt;a href=&quot;#谈谈“锁”&quot; class=&quot;headerlink&quot; title=&quot;谈谈“锁”&quot;&gt;&lt;/a&gt;谈谈“锁”&lt;/h2&gt;&lt;p&gt;说起Java的锁，脑袋里第一反应就是关键字&lt;code&gt;synchronized&lt;/code&gt;.这是Java提供的基于
    
    </summary>
    
      <category term="AQS 笔记" scheme="http://www.wei-dong.top/categories/AQS-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="源码" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="JDK" scheme="http://www.wei-dong.top/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>池技术实现-commons-pool2</title>
    <link href="http://www.wei-dong.top/2020/07/06/%E6%B1%A0%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0-commons-pool2/"/>
    <id>http://www.wei-dong.top/2020/07/06/池技术实现-commons-pool2/</id>
    <published>2020-07-06T08:37:23.000Z</published>
    <updated>2020-07-12T04:31:18.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><h3 id="PooledObjectFactory"><a href="#PooledObjectFactory" class="headerlink" title="PooledObjectFactory"></a>PooledObjectFactory</h3><p>顾名思义，这个接口是一个工厂，用于创建要池化的对象。在使用的时候一般都不直接实现，而是去继承它默认抽象实现类<code>BasePooledObjectFactory</code>。</p>
<p>只需要实现这个抽象类中的两个抽象方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> PooledObject&lt;T&gt; <span class="title">wrap</span><span class="params">(T obj)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="ObjectPool"><a href="#ObjectPool" class="headerlink" title="ObjectPool"></a>ObjectPool</h3><p>这个接口为对象池的抽象定义，定义了很多对池的操作方法。如<code>addObject</code>等。可以简单理解为一个装对象的容器像list之类的数据结构。默认的抽象实现为<code>BaseGenericObjectPool</code>具体实现有好几个，最常见的为<code>GenericObjectPool</code>.</p>
<h3 id="GenericObjectPoolConfig"><a href="#GenericObjectPoolConfig" class="headerlink" title="GenericObjectPoolConfig"></a>GenericObjectPoolConfig</h3><p>配置类对象，就是一个简单的实体，封装很多配置参数而已。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>先针对最基本的借出对象的操作实现</p>
<h3 id="“借对象”"><a href="#“借对象”" class="headerlink" title="“借对象”"></a>“借对象”</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">borrowObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">return</span> borrowObject(getMaxWaitMillis());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">borrowObject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> borrowMaxWaitMillis)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        assertOpen();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> AbandonedConfig ac = <span class="keyword">this</span>.abandonedConfig;</div><div class="line">        <span class="keyword">if</span> (ac != <span class="keyword">null</span> &amp;&amp; ac.getRemoveAbandonedOnBorrow() &amp;&amp;</div><div class="line">                (getNumIdle() &lt; <span class="number">2</span>) &amp;&amp;</div><div class="line">                (getNumActive() &gt; getMaxTotal() - <span class="number">3</span>) ) &#123;</div><div class="line">            removeAbandoned(ac);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        PooledObject&lt;T&gt; p = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Get local copy of current config so it is consistent for entire</span></div><div class="line">        <span class="comment">// method execution</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> blockWhenExhausted = getBlockWhenExhausted();</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> create;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> waitTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">            create = <span class="keyword">false</span>;</div><div class="line">            p = idleObjects.pollFirst();</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                p = create();</div><div class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                    create = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (blockWhenExhausted) &#123;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (borrowMaxWaitMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">                        p = idleObjects.takeFirst();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        p = idleObjects.pollFirst(borrowMaxWaitMillis,</div><div class="line">                                TimeUnit.MILLISECONDS);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(</div><div class="line">                            <span class="string">"Timeout waiting for idle object"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Pool exhausted"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!p.allocate()) &#123;</div><div class="line">                p = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    factory.activateObject(p);</div><div class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        destroy(p);</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e1) &#123;</div><div class="line">                        <span class="comment">// Ignore - activation failure is more important</span></div><div class="line">                    &#125;</div><div class="line">                    p = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">if</span> (create) &#123;</div><div class="line">                        <span class="keyword">final</span> NoSuchElementException nsee = <span class="keyword">new</span> NoSuchElementException(</div><div class="line">                                <span class="string">"Unable to activate object"</span>);</div><div class="line">                        nsee.initCause(e);</div><div class="line">                        <span class="keyword">throw</span> nsee;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; getTestOnBorrow()) &#123;</div><div class="line">                    <span class="keyword">boolean</span> validate = <span class="keyword">false</span>;</div><div class="line">                    Throwable validationThrowable = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        validate = factory.validateObject(p);</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</div><div class="line">                        PoolUtils.checkRethrow(t);</div><div class="line">                        validationThrowable = t;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!validate) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            destroy(p);</div><div class="line">                            destroyedByBorrowValidationCount.incrementAndGet();</div><div class="line">                        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                            <span class="comment">// Ignore - validation failure is more important</span></div><div class="line">                        &#125;</div><div class="line">                        p = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (create) &#123;</div><div class="line">                            <span class="keyword">final</span> NoSuchElementException nsee = <span class="keyword">new</span> NoSuchElementException(</div><div class="line">                                    <span class="string">"Unable to validate object"</span>);</div><div class="line">                            nsee.initCause(validationThrowable);</div><div class="line">                            <span class="keyword">throw</span> nsee;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> p.getObject();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果没有给定<code>borrowMaxWaitMillis</code>参数，那就使用默认的最大等待时间（仅仅当<code>getBlockWhenExhausted</code>为true的时候），超出这个时间就直接抛异常。</p>
<p>首先需要根据配置参数中的<code>getRemoveAbandonedOnBorrow</code>来决定是不是在每次“借”的时候抛弃掉那些快“过气”的对象。当然还是得有条件的：闲置的对象数量小于2，且当前活跃的对象数量比最大数量的差值小于3，翻译成人话就是池子快装满了呗。</p>
<h4 id="“借对象”之前的判断"><a href="#“借对象”之前的判断" class="headerlink" title="“借对象”之前的判断"></a>“借对象”之前的判断</h4><p>看看移除掉“过气”对象的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAbandoned</span><span class="params">(<span class="keyword">final</span> AbandonedConfig ac)</span> </span>&#123;</div><div class="line">        <span class="comment">// Generate a list of abandoned objects to remove</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeout =</div><div class="line">                now - (ac.getRemoveAbandonedTimeout() * <span class="number">1000L</span>);</div><div class="line">        <span class="keyword">final</span> ArrayList&lt;PooledObject&lt;T&gt;&gt; remove = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">final</span> Iterator&lt;PooledObject&lt;T&gt;&gt; it = allObjects.values().iterator();</div><div class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">            <span class="keyword">final</span> PooledObject&lt;T&gt; pooledObject = it.next();</div><div class="line">            <span class="keyword">synchronized</span> (pooledObject) &#123;</div><div class="line">                <span class="comment">// 上次使用的时间在五分钟之前 说明需要抛弃</span></div><div class="line">                <span class="keyword">if</span> (pooledObject.getState() == PooledObjectState.ALLOCATED &amp;&amp;</div><div class="line">                        pooledObject.getLastUsedTime() &lt;= timeout) &#123;</div><div class="line">                    pooledObject.markAbandoned();</div><div class="line">                    remove.add(pooledObject);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Now remove the abandoned objects</span></div><div class="line">        <span class="keyword">final</span> Iterator&lt;PooledObject&lt;T&gt;&gt; itr = remove.iterator();</div><div class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</div><div class="line">            <span class="keyword">final</span> PooledObject&lt;T&gt; pooledObject = itr.next();</div><div class="line">            <span class="keyword">if</span> (ac.getLogAbandoned()) &#123;</div><div class="line">                pooledObject.printStackTrace(ac.getLogWriter());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                invalidateObject(pooledObject.getObject());</div><div class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中有个配置参数<code>getRemoveAbandonedTimeout</code>用于判断对象是否“过气”，这个值默认是30分钟。在对象池中使用<code>allObjects</code>变量来保存所有的被“池化”的对象，这是个map类型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * All of the objects currently associated with this pool in any state. It</div><div class="line"> * excludes objects that have been destroyed. The size of</div><div class="line"> * &#123;@link #allObjects&#125; will always be less than or equal to &#123;@link</div><div class="line"> * #_maxActive&#125;. Map keys are pooled objects, values are the PooledObject</div><div class="line"> * wrappers used internally by the pool.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;IdentityWrapper&lt;T&gt;, PooledObject&lt;T&gt;&gt; allObjects =</div><div class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p>然而，并不是将我们要创建的对象直接保存到这个map中，而是将对象包装成<code>PooledObject</code>放进去的，key为对象的hash值。这个对象用于池子的内部处理，比如加几个属性什么的。这种设计在很多库或者框架中很常见。为了将复杂性不直接暴露给用户，因此重新包装了一下。</p>
<p>这里的逻辑是将所有被“池化”的对象遍历出来，判断如果使用时间超过给定的时间，那就说明这个对象“过气”了，得移除掉。使用<code>invalidateObject</code>方法来销毁这个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateObject</span><span class="params">(<span class="keyword">final</span> T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">final</span> PooledObject&lt;T&gt; p = allObjects.get(<span class="keyword">new</span> IdentityWrapper&lt;&gt;(obj));</div><div class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (isAbandonedConfig()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                <span class="string">"Invalidated object not currently part of this pool"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (p) &#123;</div><div class="line">        <span class="keyword">if</span> (p.getState() != PooledObjectState.INVALID) &#123;</div><div class="line">            destroy(p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ensureIdle(<span class="number">1</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">final</span> PooledObject&lt;T&gt; toDestroy)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        toDestroy.invalidate();</div><div class="line">        idleObjects.remove(toDestroy);</div><div class="line">        allObjects.remove(<span class="keyword">new</span> IdentityWrapper&lt;&gt;(toDestroy.getObject()));</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            factory.destroyObject(toDestroy);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            destroyedCount.incrementAndGet();</div><div class="line">            createCount.decrementAndGet();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>销毁逻辑很简单，从空闲对象列表中移除，在<code>allObjects</code>中移除，然后再更新次数，这些数据仅仅是用于对象池数据统计。</p>
<p>最核心的方法还是<code>ensureIdle</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureIdle</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> idleCount, <span class="keyword">final</span> <span class="keyword">boolean</span> always)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (idleCount &lt; <span class="number">1</span> || isClosed() || (!always &amp;&amp; !idleObjects.hasTakeWaiters())) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (idleObjects.size() &lt; idleCount) &#123;</div><div class="line">            <span class="keyword">final</span> PooledObject&lt;T&gt; p = create();</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Can't create objects, no reason to think another call to</span></div><div class="line">                <span class="comment">// create will work. Give up.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (getLifo()) &#123;</div><div class="line">                idleObjects.addFirst(p);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                idleObjects.addLast(p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (isClosed()) &#123;</div><div class="line">            <span class="comment">// Pool closed while object was being added to idle objects.</span></div><div class="line">            <span class="comment">// Make sure the returned object is destroyed rather than left</span></div><div class="line">            <span class="comment">// in the idle object pool (which would effectively be a leak)</span></div><div class="line">            clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>顾名思义，这个方法保证对象池中有指定的空闲对象能用。不然你来借的时候对象池都空了，那多尴尬。</p>
<p>如果当前池中的空闲对象小于指定的值，那么就得去创建对象了，这里使用的<code>create()</code>方法就是在前文中说到的对象工厂抽象实现类中的<code>create()</code>做一样的事情，只不过这个方法创建的是一个<code>PooledObject</code>包装类型，以及一些其他的属性。然后将这个新创建的对象装到<code>idleObjects</code>容器中，这个容器类型为<code>LinkedBlockingDeque&lt;PooledObject&lt;T&gt;&gt;</code>链表结构，是这个库自己实现的。</p>
<h4 id="“借对象”的细节"><a href="#“借对象”的细节" class="headerlink" title="“借对象”的细节"></a>“借对象”的细节</h4><p>之前说到<code>getBlockWhenExhausted</code>属性用于判断当“借”的时候没有是否需要等待。如果给定超时时间那就按照超时时间去等，没等到那就返回空对象，如果没给超时时间，那就死等。</p>
<p>这个属性最终决定如果池子里没对象最终抛出的异常，如果这个属性为false，那就直接抛<code>Pool exhausted</code>异常，如果为true那就抛出<code>&quot;Timeout waiting for idle object&quot;</code>异常（给了超时时间）。</p>
<p>首先得从空闲的容器中取“空闲对象”，接着判断是否是有效的。然后使用之前提到的工厂方法“激活”这个对象，默认实现中是空实现，在使用过程中可以去重写这个方法实现自定义的需求。<br><code>updateStatsBorrow</code>方法用来更新对象池的统计数据信息，不需要太关注。最后就直接返回我们需要的对象。</p>
<p>如果空闲的容器中没得可用的对象咋办？那只能去create一个了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> PooledObject&lt;T&gt; <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> localMaxTotal = getMaxTotal();</div><div class="line">        <span class="comment">// This simplifies the code later in this method</span></div><div class="line">        <span class="keyword">if</span> (localMaxTotal &lt; <span class="number">0</span>) &#123;</div><div class="line">            localMaxTotal = Integer.MAX_VALUE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localStartTimeMillis = System.currentTimeMillis();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localMaxWaitTimeMillis = Math.max(getMaxWaitMillis(), <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Flag that indicates if create should:</span></div><div class="line">        <span class="comment">// - TRUE:  call the factory to create an object</span></div><div class="line">        <span class="comment">// - FALSE: return null</span></div><div class="line">        <span class="comment">// - null:  loop and re-test the condition that determines whether to</span></div><div class="line">        <span class="comment">//          call the factory</span></div><div class="line">        Boolean create = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (create == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (makeObjectCountLock) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> newCreateCount = createCount.incrementAndGet();</div><div class="line">                <span class="keyword">if</span> (newCreateCount &gt; localMaxTotal) &#123;</div><div class="line">                    <span class="comment">// The pool is currently at capacity or in the process of</span></div><div class="line">                    <span class="comment">// making enough new objects to take it to capacity.</span></div><div class="line">                    createCount.decrementAndGet();</div><div class="line">                    <span class="keyword">if</span> (makeObjectCount == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">// There are no makeObject() calls in progress so the</span></div><div class="line">                        <span class="comment">// pool is at capacity. Do not attempt to create a new</span></div><div class="line">                        <span class="comment">// object. Return and wait for an object to be returned</span></div><div class="line">                        create = Boolean.FALSE;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// There are makeObject() calls in progress that might</span></div><div class="line">                        <span class="comment">// bring the pool to capacity. Those calls might also</span></div><div class="line">                        <span class="comment">// fail so wait until they complete and then re-test if</span></div><div class="line">                        <span class="comment">// the pool is at capacity or not.</span></div><div class="line">                        makeObjectCountLock.wait(localMaxWaitTimeMillis);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// The pool is not at capacity. Create a new object.</span></div><div class="line">                    makeObjectCount++;</div><div class="line">                    create = Boolean.TRUE;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Do not block more if maxWaitTimeMillis is set.</span></div><div class="line">            <span class="keyword">if</span> (create == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                (localMaxWaitTimeMillis &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">                 System.currentTimeMillis() - localStartTimeMillis &gt;= localMaxWaitTimeMillis)) &#123;</div><div class="line">                create = Boolean.FALSE;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!create.booleanValue()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> PooledObject&lt;T&gt; p;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            p = factory.makeObject();</div><div class="line">            <span class="keyword">if</span> (getTestOnCreate() &amp;&amp; !factory.validateObject(p)) &#123;</div><div class="line">                createCount.decrementAndGet();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable e) &#123;</div><div class="line">            createCount.decrementAndGet();</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">synchronized</span> (makeObjectCountLock) &#123;</div><div class="line">                makeObjectCount--;</div><div class="line">                makeObjectCountLock.notifyAll();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> AbandonedConfig ac = <span class="keyword">this</span>.abandonedConfig;</div><div class="line">        <span class="keyword">if</span> (ac != <span class="keyword">null</span> &amp;&amp; ac.getLogAbandoned()) &#123;</div><div class="line">            p.setLogAbandoned(<span class="keyword">true</span>);</div><div class="line">            p.setRequireFullStackTrace(ac.getRequireFullStackTrace());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        createdCount.incrementAndGet();</div><div class="line">        allObjects.put(<span class="keyword">new</span> IdentityWrapper&lt;&gt;(p.getObject()), p);</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个逻辑很简单，需要注意的是其中的while循环，如果池中正在创建的对象超过了最大数量，那就直接返回空。</p>
<p>至此，“借”对象的整个过程就结束了。</p>
<h3 id="驱逐逻辑"><a href="#驱逐逻辑" class="headerlink" title="驱逐逻辑"></a>驱逐逻辑</h3><p>在配置参数中有个属性<code>timeBetweenEvictionRunsMillis</code>，如果这个值为负数，就不会去运行驱逐线程，否则以配置的值作为时间间隔去扫描池中的对象，驱逐出“过气”对象。<br>具体的驱逐逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        assertOpen();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (idleObjects.size() &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            PooledObject&lt;T&gt; underTest = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">final</span> EvictionPolicy&lt;T&gt; evictionPolicy = getEvictionPolicy();</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (evictionLock) &#123;</div><div class="line">                <span class="keyword">final</span> EvictionConfig evictionConfig = <span class="keyword">new</span> EvictionConfig(</div><div class="line">                        getMinEvictableIdleTimeMillis(),</div><div class="line">                        getSoftMinEvictableIdleTimeMillis(),</div><div class="line">                        getMinIdle());</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> testWhileIdle = getTestWhileIdle();</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, m = getNumTests(); i &lt; m; i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (evictionIterator == <span class="keyword">null</span> || !evictionIterator.hasNext()) &#123;</div><div class="line">                        evictionIterator = <span class="keyword">new</span> EvictionIterator(idleObjects);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!evictionIterator.hasNext()) &#123;</div><div class="line">                        <span class="comment">// Pool exhausted, nothing to do here</span></div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        underTest = evictionIterator.next();</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchElementException nsee) &#123;</div><div class="line">                        <span class="comment">// Object was borrowed in another thread</span></div><div class="line">                        <span class="comment">// Don't count this as an eviction test so reduce i;</span></div><div class="line">                        i--;</div><div class="line">                        evictionIterator = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!underTest.startEvictionTest()) &#123;</div><div class="line">                        <span class="comment">// Object was borrowed in another thread</span></div><div class="line">                        <span class="comment">// Don't count this as an eviction test so reduce i;</span></div><div class="line">                        i--;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="comment">// User provided eviction policy could throw all sorts of</span></div><div class="line">                    <span class="comment">// crazy exceptions. Protect against such an exception</span></div><div class="line">                    <span class="comment">// killing the eviction thread.</span></div><div class="line">                    <span class="keyword">boolean</span> evict;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        evict = evictionPolicy.evict(evictionConfig, underTest,</div><div class="line">                                idleObjects.size());</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</div><div class="line">                        <span class="comment">// Slightly convoluted as SwallowedExceptionListener</span></div><div class="line">                        <span class="comment">// uses Exception rather than Throwable</span></div><div class="line">                        PoolUtils.checkRethrow(t);</div><div class="line">                        swallowException(<span class="keyword">new</span> Exception(t));</div><div class="line">                        <span class="comment">// Don't evict on error conditions</span></div><div class="line">                        evict = <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (evict) &#123;</div><div class="line">                        destroy(underTest);</div><div class="line">                        destroyedByEvictorCount.incrementAndGet();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (testWhileIdle) &#123;</div><div class="line">                            <span class="keyword">boolean</span> active = <span class="keyword">false</span>;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                factory.activateObject(underTest);</div><div class="line">                                active = <span class="keyword">true</span>;</div><div class="line">                            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                                destroy(underTest);</div><div class="line">                                destroyedByEvictorCount.incrementAndGet();</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (active) &#123;</div><div class="line">                                <span class="keyword">if</span> (!factory.validateObject(underTest)) &#123;</div><div class="line">                                    destroy(underTest);</div><div class="line">                                    destroyedByEvictorCount.incrementAndGet();</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    <span class="keyword">try</span> &#123;</div><div class="line">                                        factory.passivateObject(underTest);</div><div class="line">                                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">                                        destroy(underTest);</div><div class="line">                                        destroyedByEvictorCount.incrementAndGet();</div><div class="line">                                    &#125;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (!underTest.endEvictionTest(idleObjects)) &#123;</div><div class="line">                            <span class="comment">// TODO - May need to add code here once additional</span></div><div class="line">                            <span class="comment">// states are used</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> AbandonedConfig ac = <span class="keyword">this</span>.abandonedConfig;</div><div class="line">        <span class="keyword">if</span> (ac != <span class="keyword">null</span> &amp;&amp; ac.getRemoveAbandonedOnMaintenance()) &#123;</div><div class="line">            removeAbandoned(ac);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>EvictionPolicy</code>为驱逐策略接口，用于指定使用哪种策略把过气对象清理出对象池。默认实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEvictionPolicy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EvictionPolicy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evict</span><span class="params">(<span class="keyword">final</span> EvictionConfig config, <span class="keyword">final</span> PooledObject&lt;T&gt; underTest,</span></span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idleCount) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((config.getIdleSoftEvictTime() &lt; underTest.getIdleTimeMillis() &amp;&amp;</div><div class="line">                config.getMinIdle() &lt; idleCount) ||</div><div class="line">                config.getIdleEvictTime() &lt; underTest.getIdleTimeMillis()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其策略为</p>
<ul>
<li>对象池中某个对象的空闲的时间长于<code>getMinEvictableIdleTimeMillis</code></li>
<li>在对象池中的空闲对象有超过<code>getMinIdle</code>且某个对象的空闲时间长于<code>getSoftMinEvictableIdleTimeMillis</code></li>
</ul>
<p>满足其中之一即返回真，执行驱逐操作。</p>
<p>而这个线程每次只会扫描<code>getNumTests</code>数量的对象。使用<code>EvictionIterator</code>将池中所有空闲对象包装起来，其实这里使用的是迭代器模式（处处都体现设计模式呀）。如果没取到，那就将这个空对象跳过去，反正必须得取<code>getNumTests</code>这么多个，空的不算数。最后就是使用<code>destroy</code>方法将其销毁掉了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了<code>commons-pool</code>几个核心接口以及相关配置参数和代表的含义，针对核心API的实现做了源码解读。总的来说这个工具的实现其实很简单，源码读起来没有太大难度。当然除了文中提到的默认对象池实现之外，<code>commons-pool</code>还提供基于key的对象池<code>KeyedObjectPool</code>以及基于代理的对象池<code>ProxiedObjectPool</code>的实现。由于暂时没找到使用的场景，就没有继续深入解读。</p>
<p>看了对象池的实现后，觉得这些看似“高大上”的东西也不过如此。接着尝试去了解一下更加专业的“池”–连接池。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;核心接口&quot;&gt;&lt;a href=&quot;#核心接口&quot; class=&quot;headerlink&quot; title=&quot;核心接口&quot;&gt;&lt;/a&gt;核心接口&lt;/h2&gt;&lt;h3 id=&quot;PooledObjectFactory&quot;&gt;&lt;a href=&quot;#PooledObjectFactory&quot; class
    
    </summary>
    
      <category term="pool 笔记" scheme="http://www.wei-dong.top/categories/pool-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="源码" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="apache" scheme="http://www.wei-dong.top/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>池技术使用-commons-pool2</title>
    <link href="http://www.wei-dong.top/2020/07/03/%E6%B1%A0%E6%8A%80%E6%9C%AF%E4%BD%BF%E7%94%A8-commons-pool2/"/>
    <id>http://www.wei-dong.top/2020/07/03/池技术使用-commons-pool2/</id>
    <published>2020-07-03T04:37:23.000Z</published>
    <updated>2020-07-03T09:29:43.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="池技术"><a href="#池技术" class="headerlink" title="池技术"></a>池技术</h2><p>日常搬砖过程中对池技术的接触很多，最具代表的是连接池。<br>连接池也是一种池技术，本质上都是对象池。commons-pool是apacha基金会开源的一款常见的对象池工具库。</p>
<p>使用池化主要是为了节省对象创建的开销。比如日常开发息息相关的数据源连接池，就是为了减少连接创建的时间而生的。可以简单评估一下一个连接的创建经历哪些操作：对象创建，tcp连接等。tcp连接又得经历三次握手，如果是tls/ssl还得做证书签名验证，想想都麻烦。所以使用连接池可以减少这些消耗性能的操作，把机器更多的性能留给业务。</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>这里直接搬运官网的demo。</p>
<p>下面是一个从流中读取字符串的工具类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.Reader; </div><div class="line"><span class="keyword">import</span> java.io.IOException; </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderUtil</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderUtil</span><span class="params">()</span> </span>&#123; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Dumps the contents of the &#123;<span class="doctag">@link</span> Reader&#125; to a </div><div class="line">     * String, closing the &#123;<span class="doctag">@link</span> Reader&#125; when done. </div><div class="line">     */ </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readToString</span><span class="params">(Reader in)</span> <span class="keyword">throws</span> IOException </span>&#123; </div><div class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer(); </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = in.read(); c != -<span class="number">1</span>; c = in.read()) &#123; </div><div class="line">                buf.append((<span class="keyword">char</span>)c); </div><div class="line">            &#125; </div><div class="line">            <span class="keyword">return</span> buf.toString(); </div><div class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123; </div><div class="line">            <span class="keyword">throw</span> e; </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            <span class="keyword">try</span> &#123; </div><div class="line">                in.close(); </div><div class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123; </div><div class="line">                <span class="comment">// ignored </span></div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>咋看上去没什么毛病，我们在日常搬砖中也会写出这样的工具类，也可以很好的工作。为了突出说明池化技术的优点，这个工具类还能继续优化，虽然优化空间不是很大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.Reader;</div><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.ObjectPool;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderUtil</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ObjectPool&lt;StringBuffer&gt; pool;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderUtil</span><span class="params">(ObjectPool&lt;StringBuffer&gt; pool)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.pool = pool;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Dumps the contents of the &#123;<span class="doctag">@link</span> Reader&#125; to a String, closing the &#123;<span class="doctag">@link</span> Reader&#125; when done.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readToString</span><span class="params">(Reader in)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException &#123;</div><div class="line">        StringBuffer buf = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            buf = pool.borrowObject();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = in.read(); c != -<span class="number">1</span>; c = in.read()) &#123;</div><div class="line">                buf.append((<span class="keyword">char</span>) c);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> buf.toString();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to borrow buffer from pool"</span> + e.toString());</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                in.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ignored</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != buf) &#123;</div><div class="line">                    pool.returnObject(buf);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="comment">// ignored</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>明眼人很快就能看出区别，无非就是将StringBuffer的创建方式做了变化，以前是直接new，每次调用都得new一下，现在是通过向pool借。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.BasePooledObjectFactory;</div><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.PooledObject;</div><div class="line"><span class="keyword">import</span> org.apache.commons.pool2.impl.DefaultPooledObject;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferFactory</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">BasePooledObjectFactory</span>&lt;<span class="title">StringBuffer</span>&gt; &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StringBuffer <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Use the default PooledObject implementation.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PooledObject&lt;StringBuffer&gt; <span class="title">wrap</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultPooledObject&lt;StringBuffer&gt;(buffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * When an object is returned to the pool, clear the buffer.</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">passivateObject</span><span class="params">(PooledObject&lt;StringBuffer&gt; pooledObject)</span> </span>&#123;</div><div class="line">        pooledObject.getObject().setLength(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// for all other methods, the no-op implementation</span></div><div class="line">    <span class="comment">// in BasePooledObjectFactory will suffice</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终只需要将pool传给这个util：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReaderUtil readerUtil = <span class="keyword">new</span> ReaderUtil(<span class="keyword">new</span> GenericObjectPool&lt;StringBuffer&gt;(<span class="keyword">new</span> StringBufferFactory()));</div></pre></td></tr></table></figure>
<p>需要开发关注的仅仅是对象工厂StringBufferFactory的实现，在这个工厂中，主要任务是创建对象，也就是最开始的new对象。把对象的创建工作转移到了工厂里，而不是硬生生的new出来，这也是设计模式的一种体现。</p>
<p>官网给的这个例子非常简洁易懂，很容易快速上手。然而其中还有很多配置参数，能让对象池功能更加丰富。</p>
<h2 id="带配置参数的入门"><a href="#带配置参数的入门" class="headerlink" title="带配置参数的入门"></a>带配置参数的入门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 创建池对象工厂</span></div><div class="line">        PooledObjectFactory&lt;StringBuilder&gt; factory = <span class="keyword">new</span> MyPoolableObjectFactory();</div><div class="line"></div><div class="line">        GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</div><div class="line">        <span class="comment">// 最大空闲数</span></div><div class="line">        poolConfig.setMaxIdle(<span class="number">5</span>);</div><div class="line">        <span class="comment">// 最小空闲数, 池中只有一个空闲对象的时候，池会在创建一个对象，并借出一个对象，从而保证池中最小空闲数为1</span></div><div class="line">        poolConfig.setMinIdle(<span class="number">1</span>);</div><div class="line">        <span class="comment">// 最大池对象总数</span></div><div class="line">        poolConfig.setMaxTotal(<span class="number">20</span>);</div><div class="line">        <span class="comment">// 逐出连接的最小空闲时间 默认1800000毫秒(30分钟)</span></div><div class="line">        poolConfig.setMinEvictableIdleTimeMillis(<span class="number">1800000</span>);</div><div class="line">        <span class="comment">// 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1</span></div><div class="line">        poolConfig.setTimeBetweenEvictionRunsMillis(<span class="number">1800000</span> * <span class="number">2L</span>);</div><div class="line">        <span class="comment">// 在获取对象的时候检查有效性, 默认false</span></div><div class="line">        poolConfig.setTestOnBorrow(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 在归还对象的时候检查有效性, 默认false</span></div><div class="line">        poolConfig.setTestOnReturn(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 在空闲时检查有效性, 默认false</span></div><div class="line">        poolConfig.setTestWhileIdle(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 最大等待时间， 默认的值为-1，表示无限等待。</span></div><div class="line">        poolConfig.setMaxWaitMillis(<span class="number">6000</span>);</div><div class="line">        <span class="comment">// 是否启用后进先出, 默认true</span></div><div class="line">        poolConfig.setLifo(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 连接耗尽时是否阻塞, false报异常,true阻塞直到超时, 默认true</span></div><div class="line">        poolConfig.setBlockWhenExhausted(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">// 每次逐出检查时 逐出的最大数目 默认3</span></div><div class="line">        poolConfig.setNumTestsPerEvictionRun(<span class="number">3</span>);</div><div class="line"></div><div class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">40</span>);</div><div class="line">        <span class="comment">// 创建对象池</span></div><div class="line">        <span class="keyword">final</span> GenericObjectPool&lt;StringBuilder&gt; pool = <span class="keyword">new</span> GenericObjectPool&lt;StringBuilder&gt;(factory, poolConfig);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</div><div class="line">            <span class="keyword">int</span> finalI = i;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    StringBuilder resource = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">// 注意，如果对象池没有空余的对象，那么这里会block，可以设置block的超时时间</span></div><div class="line">                        resource = pool.borrowObject();</div><div class="line">                        resource.append(<span class="string">"+"</span>).append(finalI);</div><div class="line">                        System.out.println(resource);</div><div class="line">                        Thread.sleep(<span class="number">2000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="comment">// 申请的资源用完了记得归还，不然其他人要申请时可能就没有资源用了</span></div><div class="line">                        pool.returnObject(resource);</div><div class="line">                        latch.countDown();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        latch.await();</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"=====finish===="</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPoolableObjectFactory</span> <span class="keyword">extends</span> <span class="title">BasePooledObjectFactory</span>&lt;<span class="title">StringBuilder</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> PooledObject&lt;StringBuilder&gt; <span class="title">wrap</span><span class="params">(StringBuilder obj)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultPooledObject&lt;&gt;(obj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个demo中给了很多配置参数，注释中写的都很明白。值得注意的是这个demo中输出的结果可能不一致。因为多线程的缘故。</p>
<p>下面是其中的一种输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">+5</div><div class="line">+9</div><div class="line">+8</div><div class="line">+11</div><div class="line">+12</div><div class="line">+10</div><div class="line">+4</div><div class="line">+1</div><div class="line">+3</div><div class="line">+2</div><div class="line">+7</div><div class="line">+13</div><div class="line">+15</div><div class="line">+16</div><div class="line">+6</div><div class="line">+17</div><div class="line">+18</div><div class="line">+19</div><div class="line">+0</div><div class="line">+14</div><div class="line">+3+20</div><div class="line">+9+21</div><div class="line">+11+22</div><div class="line">+4+25</div><div class="line">+2+23</div><div class="line">+5+24</div><div class="line">+1+26</div><div class="line">+0+27</div><div class="line">+14+28</div><div class="line">+9+21+29</div><div class="line">+3+20+30</div><div class="line">+4+25+31</div><div class="line">+1+26+32</div><div class="line">+2+23+33</div><div class="line">+11+22+35</div><div class="line">+5+24+34</div><div class="line">+0+27+36</div><div class="line">+14+28+37</div><div class="line">+3+20+30+38</div><div class="line">+9+21+29+39</div><div class="line">=====finish====</div></pre></td></tr></table></figure>
<p>这里开了40个线程去获取对象，通过使用latch使得所有线程都结束后再结束主线程。<br>这个latch得控制为40，因为每个线程跑完都得减一，直到为0后表示所有线程都结束。这里都latch只是用于控制先后顺序，也就是即使主线程结束了，子线程也能继续执行下去，除非子线程都是守护线程。</p>
<p>由于设置都最大数量为20，因此会有20个线程先获取到stringbuffer对象，然后这里睡眠了2秒钟，模拟一下对这个对象的使用，剩下的20个线程会尝试去“借”对象，但是之前的20个线程还没用完，因此不会马上获取到，这里设置了一个超时时间6s，也就是最多等6s，如果6s后还是没能等到，那就直接抛异常了。因为模拟只使用2s，到期了就直接“还”回去了，因此这里的输出会将之前的也打印出来，虽然归还了，但是却没清理掉它的内容。</p>
<p>仔细来看，带参数的也就不过如此，对于开发者而言也没有什么太复杂的地方，十分容易上手。接下来就拨开云雾，仔细瞧瞧池技术是如何实现的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;池技术&quot;&gt;&lt;a href=&quot;#池技术&quot; class=&quot;headerlink&quot; title=&quot;池技术&quot;&gt;&lt;/a&gt;池技术&lt;/h2&gt;&lt;p&gt;日常搬砖过程中对池技术的接触很多，最具代表的是连接池。&lt;br&gt;连接池也是一种池技术，本质上都是对象池。commons-pool是ap
    
    </summary>
    
      <category term="pool 笔记" scheme="http://www.wei-dong.top/categories/pool-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="源码" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="apache" scheme="http://www.wei-dong.top/tags/apache/"/>
    
  </entry>
  
  <entry>
    <title>写在2020</title>
    <link href="http://www.wei-dong.top/2020/01/01/%E5%86%99%E5%9C%A82020/"/>
    <id>http://www.wei-dong.top/2020/01/01/写在2020/</id>
    <published>2020-01-01T03:33:18.000Z</published>
    <updated>2020-01-01T06:24:24.835Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2020第一天。</p>
<h2 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h2><p>此时的我坐在电脑前对着屏幕发呆，仔细回忆着发生在2019值得纪念的事情。最值得被纪念的还得是我这一年的成长吧。</p>
<p>当然这个成长只能算是工作上的。自从2018年来到YJ后，回想起之前的工作经历可以说是浪费时间。刚来那时候面对新环境我真的是一个dd，d中d。对于工作中的基本操作都显得十分笨拙，那时候我还是有两年的工作经验呢。在试用期的几个月内，我真的十分崩溃。在完成第一个需求的时候痛苦不堪。有个坑b的产品，加上对接的东西又很多，老代码写得和狗屎一样，这些对我来说无疑是困难。毕竟之前从未在这么大规模的研发团队中工作过，团队的协作与沟通俨然成为一道阻碍我前行的屏障。说实话代码的难度倒是没难倒我，只是对于那么大的团队协作的工作方式觉得很困惑。曾经一度想直接和经理说干不下去了太难受了我不搞了，但最后还是坚持下来了，终于熬过试用期了。还记得那时候压力太大和父亲通话，他劝我说搞不了就别搞了，机会多的是干嘛和自己过不去呢。那时候我反驳了他没听他的，我就是想证明一下自己到底能不能扛得住这些压力。因为我之前之前的日子里过得实在是太安逸了，没有任何压力，每天都不知道自己做了些什么，甚至还有点自闭。度过那段难受的时光之后我逐渐轻车熟路，慢慢知道了一些常见的套路。这得感谢我的直接领导文颗，他是一个很出色的95后，情商很高，处理人际关系很有一套。有时候看他做事方式并不像一个95的年轻人，成熟的不像95后。后来慢慢负责了一块单独的业务，那时候我才正真体会到了价值和责任，也慢慢学会了沟通的技巧，但还是不知道怎么怼人。相比之前，2019在YJ的这段时间确实让我经历了许多，至少能抗住压力了。</p>
<p>再值得纪念的是和天一兄弟的‘云创业’。那时候他提出做自媒体的想法，然后招集几个小伙伴一起出谋划策实施落地方案。我记得当时两周一次会议，每次会议一个小时，轮岗主持人制。刚开始积极性还是很高的，后来就没有了太多热情，最后坚持了一两个月就宣布失败了。不过还是学到很多实用的东西，比如会议的控场，主题的把控等很多小技巧。不得不说创业其实还是很困难的。目前天一兄弟的博客也不更新了，可能是时间都用来陪伴女朋友了吧。</p>
<p>记得五一的时候回家过一躺，一个老朋友结婚去参加了婚礼，也是我人生中第一次参加别人的婚礼。男孩女孩都是老同学了，他们经历太多最后还是走到一起。在婚礼中有那么一瞬间真的很感动，甚至想哭。因为婚礼的缘故也遇到了很多老同学老朋友，神奇的是那么多年没见再次相遇居然还没有任何生疏的感觉，一切好像昨天才见面一样熟悉。曾经以为有些人一辈子都不会再见面了，现在却真实的站在我面前。</p>
<p>再谈谈2019哪些做了哪些没做吧。这一年读几本书，正真感兴趣的不是太多。</p>
<ul>
<li>《激荡三十年（上）》</li>
<li>《激荡十年 水大鱼大》</li>
<li>《浪潮之巅》</li>
<li>《未来简史》</li>
<li>《褚时健传》</li>
<li>《淘宝技术这十年》</li>
<li>《我们仨》 </li>
<li>《读懂财经新闻的第一本书》</li>
</ul>
<p>总的来说对那些带有历史变革背景的作品比较感兴趣。对非技术类的文学作品还是缺少耐心。技术类的书籍看得多，但大多都没看完在那里吃灰，比如《CSAPP》、《TCP/IP详解》等。</p>
<p>这一年专业技术水平没有太多的提升，最多的尝试是读源码，但是正真收获的却没有太多。有个阿里P7大佬写了个开源的RPC框架我是真的一点不漏的看完了，反反复复地看，还写出了几篇解读文章。值得高兴的是被他收录到他github上去了。那时候真的有一种付出就有回报的感觉，很自豪。为什么读不下去源码，因为做这种事情时间周期久而且得到的反馈太慢了，现在都讲究短平快，及时满足感，像这种起码得花好几天才能有回报的事情做起来太吃力了。还有一个根本原因：你不够热爱！突然想起最近和一个B站插画up主聊天，他说有时候下班还会去画画，因为喜欢。我反思了一下，我下班后还会打开电脑写代码么？</p>
<p>最近值得纪念的事情就是公司裁员，这让原本和谐融洽的气氛变得十分紧张。毕竟走了近一半的同学，还是挺难过的。</p>
<p>这一年的兴趣爱好似乎依旧没有培养起来，用四个字总结就是有心无力。总是期待着成为XXX样的人，一直在内心幻想着，却没有正真去付出时间和精力。还是源自内心的恐惧，害怕失败，害怕没有结果，害怕中途放弃…</p>
<p>这一年我没有成为有趣的人，没认识新的朋友，没去过有趣的地方。</p>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>对于2020我不想立太多flag。我希望找到自己的热爱，付出和实践；直面恐惧，发现生活的乐趣，做个内心世界丰富且强大的人。</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>2019已经过去了，我还是很怀念它！<br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/jim-carry.jpg?raw=true" alt="2020"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2020第一天。&lt;/p&gt;
&lt;h2 id=&quot;回首&quot;&gt;&lt;a href=&quot;#回首&quot; class=&quot;headerlink&quot; title=&quot;回首&quot;&gt;&lt;/a&gt;回首&lt;/h2&gt;&lt;p&gt;此时的我坐在电脑前对着屏幕发呆，仔细回忆着发生在2019值得纪念的事情。最值得被纪念的还得是我这一年的
    
    </summary>
    
      <category term="beyond coding" scheme="http://www.wei-dong.top/categories/beyond-coding/"/>
    
    
      <category term="生活" scheme="http://www.wei-dong.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>浮生一记</title>
    <link href="http://www.wei-dong.top/2019/11/14/%E6%B5%AE%E7%94%9F%E4%B8%80%E8%AE%B0/"/>
    <id>http://www.wei-dong.top/2019/11/14/浮生一记/</id>
    <published>2019-11-14T08:33:18.000Z</published>
    <updated>2019-11-24T10:08:27.722Z</updated>
    
    <content type="html"><![CDATA[<p>有些日子没有更新了。最近这段日子也不算太忙，因为双11的连续上班两周，总是觉得似乎没有休息好。</p>
<p>虽说不忙，但是也有不开心的事情。整个行业的不景气，许多公司在优化，我们公司也不例外。前段时间领导突然请吃饭，我就知道事情没那么简单。果不其然在饭桌上公布优化人员的消息，气氛变得凝重起来。但是早说要比晚说要好，毕竟留下了更多的心理缓冲时间。饭桌上比我几岁的领导没控制住情绪，失声哭了起来。换为思考一下，也能理解他这种情绪。当时团队从4-5个人扩大到11个人，这一路走来还是不容易的，现在上层说优化就优化，作为领导却没办法争取点什么。对我而言也是有点难过的，因为我的那个小team也是很不错的，要走一半也是很不舍得的。</p>
<p>在此之前我们的团建经费都下发到两个小team。我所在的小team没有好的想法，就直接交给表哥他们那边了。他们决定一起去自驾游。随着双11连续的两周上班结束，我们如期进行了我们的小trip。</p>
<p>这次的目的地是大鹏，离市区差不多近100公里。一位同事自己有车，此外我们还租了一辆车。在一个阳光明媚的早晨我们出发了。<br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0389.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0362.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0404.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0410.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0376.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0411.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0377.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0363.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0405.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0388.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0375.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0407.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0361.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0406.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0360.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0374.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0412.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0358.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0370.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0364.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0402.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0365.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0403.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0417.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0371.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0359.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0398.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0401.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0367.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0373.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0372.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0414.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0366.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0399.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0380.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0394.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0425.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0357.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0419.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0418.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0356.jpg?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0424.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0395.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0381.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0397.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0383.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0368.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0369.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0382.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0396.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0392.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0379.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0422.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0378.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0393.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0385.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0391.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0408.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0409.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0390.JPG?raw=true" alt="image"><br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/go-around/IMG_0384.JPG?raw=true" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些日子没有更新了。最近这段日子也不算太忙，因为双11的连续上班两周，总是觉得似乎没有休息好。&lt;/p&gt;
&lt;p&gt;虽说不忙，但是也有不开心的事情。整个行业的不景气，许多公司在优化，我们公司也不例外。前段时间领导突然请吃饭，我就知道事情没那么简单。果不其然在饭桌上公布优化人员的消
    
    </summary>
    
      <category term="玩" scheme="http://www.wei-dong.top/categories/%E7%8E%A9/"/>
    
    
      <category term="生活" scheme="http://www.wei-dong.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写作</title>
    <link href="http://www.wei-dong.top/2019/04/20/why_writting/"/>
    <id>http://www.wei-dong.top/2019/04/20/why_writting/</id>
    <published>2019-04-20T08:14:23.000Z</published>
    <updated>2019-04-20T08:47:04.358Z</updated>
    
    <content type="html"><![CDATA[<p>有一天，天一同学突然问我一个问题：你的博客是不打算更新了么？一时间我不知道怎么回答，因为我也不确定回答是或者否。</p>
<p>然后接下来好几天都在想这个问题。即使天一同学不提到，我也意识到很久没有更新文章了。然后回想一下，自从换了工作到云集工作后就再也没有更新博客了。就连github也没怎么更新过。原先买的3年期的域名，本打算在这段时间给自己留下点什么，仔细翻了翻以往写的东西，可能真的要半途而废了。</p>
<p>拿半途而废来形容是不准确的，毕竟这个域名还没到期，仅仅废了一半。那就好好分析一下为什么没想到去写文章了，总结一个字–懒！现在工作还是有压力的，业余时间都放松玩去了，压根没想到要写点什么记录一下。其次就是对技术的热爱没有那么强烈了。以前看到一些比较厉害的源码总是有那么一点小激动和兴奋，总想着去学习一下记录这个过程。而现在这种想法不是那么强烈，想着到时候需要的时候再来研究。那就不得不说，现在对什么兴趣比较强烈。现在对绘画、书法之类的比较感兴趣。空闲时间都会去b站看看，总想着有一天我也会这些东西，而不仅仅只会写代码。我想这种想法不仅仅我一个人有过，很多人都想过。同时也会关注一下那些技术博主的关于编码之外的文章，比方说生活琐事之类的。大概是因为自己从事这个行业时间久了，内心世界十分贫瘠，总是一些枯燥的代码。长久以来，我觉得技术之中也存在着某种艺术以及设计哲学，因此更加想去找到这两者之间的联系。</p>
<p>除了懒，还有一个比较重要的原因。觉得自己的语言组织能力不足，不足以将一件事情表达清楚，或者文笔不够好，担心写出来的东西太low，入不了眼。因此就更不愿意写，如此往复恶性循环。但是这个理由是站不住脚的。自己写的文章仅仅是用来取悦自己而不是取悦他人，干嘛有这么多心理负担，又不是上学那会让写个作文还得打分。因此还是一个字懒导致的。</p>
<p>还发现一个现象，随着年龄的增加，越来越多的人都不愿意在社交网络上表达自己了。我曾记得以前总是在微博盆友圈上发表一些想法感受，而现在却很少了。说不清为什么，大致觉得生活无非就是这样，稀疏平常的事情也没必要去抱怨或者去“晒”吧。或者是说成年人的世界比较复杂？</p>
<p>通篇下来，都是在讲我为什么没继续写作了，但丝毫没说为什么要写作。</p>
<p>为了留下点什么，为了不被忘记！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一天，天一同学突然问我一个问题：你的博客是不打算更新了么？一时间我不知道怎么回答，因为我也不确定回答是或者否。&lt;/p&gt;
&lt;p&gt;然后接下来好几天都在想这个问题。即使天一同学不提到，我也意识到很久没有更新文章了。然后回想一下，自从换了工作到云集工作后就再也没有更新博客了。就连
    
    </summary>
    
      <category term="写作" scheme="http://www.wei-dong.top/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="编码之外" scheme="http://www.wei-dong.top/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96/"/>
    
  </entry>
  
  <entry>
    <title>Netty中的线程模型之OIO</title>
    <link href="http://www.wei-dong.top/2018/09/12/Netty%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B9%8BOIO/"/>
    <id>http://www.wei-dong.top/2018/09/12/Netty中的线程模型之OIO/</id>
    <published>2018-09-12T09:17:23.000Z</published>
    <updated>2018-09-12T09:07:20.764Z</updated>
    
    <content type="html"><![CDATA[<p>和高性能NIO相比，个人认为OIO的实现相对要简单一点，选择这个难度稍微低一点的实现来肯对目前的菜鸡我而言更现实。</p>
<p>本质上而言，eventloopgroup就是线程池。</p>
<p><img src="http://7xsfwn.com1.z0.glb.clouddn.com/OioEventLoopGroup.png" alt="image"></p>
<p>Netty针对JDK的实现做了进一步的加强。</p>
<p>对于OIO的第一反应是「阻塞」，「性能差」，「耗资源」。事实上确实如此，但为什么还要写一篇文章（笔记）来对它进行描述呢？在之前，我以为Netty并没有提供OIO的实现，天真的认为Netty仅仅是对NIO进行了封装。直到某一天使用到了OIO，想将OIO的线程模型和Netty中的实现类似：一个线程负责连接，别的线程负责IO。想了许久没有下文，机缘巧合看到了Netty的文档，其中有对OIO的封装，恰好和我心中想的一模一样，而且对外提供的API不变。这种抽象设计让我想深入其中，看看到底是如何做到的。我想借鉴其中的设计来实现一个比较简单对OIO的封装。</p>
<blockquote>
<p>EventLoopGroup which is used to handle OIO Channel’s. Each Channel will be handled by its own EventLoop to not block others.</p>
</blockquote>
<p>文档中的解释很简单，EventLoopGroup用来处理连接，每个连接由它自己的EventLoop处理。</p>
<p>这段解释不禁联想到了针对OIO的编程：每个连接由新开的线程处理，有多少个连接就有多少个线程。这里的Channel就是连接的抽象，EventLoop可以理解为线程。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">OioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(maxChannels, threadFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ThreadPerChannelEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(maxChannels, <span class="keyword">new</span> ThreadPerTaskExecutor(threadFactory), args);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">        threadFactory.newThread(command).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器中两个参数，maxChannels为最大连接数。注意，这个是比较讲究的，在Netty线程模型中有boss和worker线程之分。如果只指定一个，也就是boss就是worker那么这个值如果为1那么任何客户端无法连进来，如果为2则只允许1个客户端连进来，依次类推。默认为0，表示允许无限多客户端接入（理论上）。当有worker的时候，boss的maxChannels指定多少无所谓，worker中的maxChannels值为多少就意味着允许多少客户端接入，同理0代表无限多。第二个参数为线程工厂，默认使用的是JDK的默认实现：Executors.defaultThreadFactory()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ThreadPerChannelEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, Executor executor, Object... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxChannels &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</div><div class="line">                <span class="string">"maxChannels: %d (expected: &gt;= 0)"</span>, maxChannels));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"executor"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</div><div class="line">        childArgs = EmptyArrays.EMPTY_OBJECTS;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        childArgs = args.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.maxChannels = maxChannels;</div><div class="line">    <span class="keyword">this</span>.executor = executor;</div><div class="line"></div><div class="line">    tooManyChannels = ThrowableUtil.unknownStackTrace(</div><div class="line">            <span class="keyword">new</span> ChannelException(<span class="string">"too many channels (max: "</span> + maxChannels + <span class="string">')'</span>),</div><div class="line">            ThreadPerChannelEventLoopGroup.class, <span class="string">"nextChild()"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的一些成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerChannelEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">AbstractEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] childArgs;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxChannels;</div><div class="line">    <span class="comment">// 任务执行器</span></div><div class="line">    <span class="keyword">final</span> Executor executor;</div><div class="line">    <span class="comment">// 活跃的线程集合</span></div><div class="line">    <span class="keyword">final</span> Set&lt;EventLoop&gt; activeChildren =</div><div class="line">            Collections.newSetFromMap(PlatformDependent.&lt;EventLoop, Boolean&gt;newConcurrentHashMap());</div><div class="line">    <span class="comment">// 空闲的线程集合</span></div><div class="line">    <span class="keyword">final</span> Queue&lt;EventLoop&gt; idleChildren = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;EventLoop&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelException tooManyChannels;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shuttingDown;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Promise&lt;?&gt; terminationFuture = <span class="keyword">new</span> DefaultPromise&lt;Void&gt;(GlobalEventExecutor.INSTANCE);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureListener&lt;Object&gt; childTerminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="comment">// Inefficient, but works.</span></div><div class="line">            <span class="keyword">if</span> (isTerminated()) &#123;</div><div class="line">                terminationFuture.trySuccess(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>EventLoopGroup的初始化就这样结束了。但是要探索其中的工作机制还得从一个Server 的启动开始。</p>
<h3 id="ServerBootstrap的启动"><a href="#ServerBootstrap的启动" class="headerlink" title="ServerBootstrap的启动"></a>ServerBootstrap的启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></div><div class="line">        b.group(bossGroup, workerGroup)</div><div class="line">         .channel(OioServerSocketChannel.class) <span class="comment">// (3)</span></div><div class="line">         .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></div><div class="line">             <span class="meta">@Override</span></div><div class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                 ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</div><div class="line">             &#125;</div><div class="line">         &#125;)</div><div class="line">         .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></div><div class="line">         .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></div><div class="line">    </div><div class="line">        <span class="comment">// Bind and start to accept incoming connections.</span></div><div class="line">        ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></div><div class="line">    </div><div class="line">        <span class="comment">// Wait until the server socket is closed.</span></div><div class="line">        <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></div><div class="line">        <span class="comment">// shut down your server.</span></div><div class="line">        f.channel().closeFuture().sync();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        workerGroup.shutdownGracefully();</div><div class="line">        bossGroup.shutdownGracefully();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最核心的是bind方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    validate();</div><div class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> doBind(localAddress);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">	 <span class="comment">// 核心是regFuture的获取，有了这个后面一切都好说</span></div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> regFuture;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</div><div class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></div><div class="line">        ChannelPromise promise = channel.newPromise();</div><div class="line">        doBind0(regFuture, channel, localAddress, promise);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></div><div class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</div><div class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Throwable cause = future.cause();</div><div class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></div><div class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></div><div class="line">                    promise.setFailure(cause);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></div><div class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></div><div class="line">                    promise.registered();</div><div class="line"></div><div class="line">                    doBind0(regFuture, channel, localAddress, promise);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</div><div class="line">    Channel channel = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    	 <span class="comment">// 实例化OioServerSocketChannel</span></div><div class="line">        channel = channelFactory.newChannel();</div><div class="line">        init(channel);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 核心是这段逻辑config().group()返回的就是我们设置的boss：OioEventLoopGroup</span></div><div class="line">    ChannelFuture regFuture = config().group().register(channel);</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</div><div class="line">            channel.close();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> regFuture;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>忽略掉无关的逻辑（实在是很复杂），关键点到了这个OioEventLoopGroup的register方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channel"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        EventLoop l = nextChild();</div><div class="line">        <span class="comment">// 将channel包装了一下--&gt; DefaultChannelPromise</span></div><div class="line">        <span class="keyword">return</span> l.register(<span class="keyword">new</span> DefaultChannelPromise(channel, l));</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailedChannelFuture(channel, GlobalEventExecutor.INSTANCE, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个Channel就是OioServerSocketChannel，对应在OIO原生API中就是ServerSocket。根据代码的字面意可以这样解释：将OioServerSocketChannel注册到EventLoopGroup。</p>
<p>最终是通过EventLoop去注册的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> EventLoop <span class="title">nextChild</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shuttingDown) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"shutting down"</span>);</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 从空闲队列中取EventLoop</span></div><div class="line">    EventLoop loop = idleChildren.poll();</div><div class="line">    <span class="keyword">if</span> (loop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (maxChannels &gt; <span class="number">0</span> &amp;&amp; activeChildren.size() &gt;= maxChannels) &#123;</div><div class="line">            <span class="keyword">throw</span> tooManyChannels;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有就新建一个 参数没用</span></div><div class="line">        loop = newChild(childArgs);</div><div class="line">        loop.terminationFuture().addListener(childTerminationListener);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 新建的放到活跃队列中</span></div><div class="line">    activeChildren.add(loop);</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 新建的一个EventLoop为ThreadPerChannelEventLoop实例，参数为EventLoopGroup 也就是说这个EventLoop说由哪个group产生的</span></div><div class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(@SuppressWarnings(<span class="string">"UnusedParameters"</span>)</span> Object... args) <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPerChannelEventLoop(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么一来，真正的注册逻辑就交给了ThreadPerChannelEventLoop去实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPerChannelEventLoop</span><span class="params">(ThreadPerChannelEventLoopGroup parent)</span> </span>&#123;</div><div class="line">	 <span class="comment">// 注意 这里的parent.executor为ThreadPerTaskExecutor实例</span></div><div class="line">    <span class="keyword">super</span>(parent, parent.executor, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.register(promise).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</div><div class="line">                ch = future.channel();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                deregister();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 父类的</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>终于要看到希望了，这一层一层的调用实在很繁琐，会把人看晕，建议多看几遍就不晕了😂。</p>
<p>promise.channel()返回的就是我们设置的OioServerSocketChannel。而unsafe方法则是继承自它的「太爷爷」。<br>其具体实现则是由它「爷爷」来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> AbstractUnsafe <span class="title">newUnsafe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultOioUnsafe();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这是它的一个内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultOioUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractUnsafe</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> SocketAddress remoteAddress,</div><div class="line">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">            doConnect(remoteAddress, localAddress);</div><div class="line"></div><div class="line">            <span class="comment">// Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel.</span></div><div class="line">            <span class="comment">// We still need to ensure we call fireChannelActive() in this case.</span></div><div class="line">            <span class="keyword">boolean</span> active = isActive();</div><div class="line"></div><div class="line">            safeSetSuccess(promise);</div><div class="line">            <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</div><div class="line">                pipeline().fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            safeSetFailure(promise, annotateConnectException(t, remoteAddress));</div><div class="line">            closeIfClosed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然快看到希望的曙光了，但是眼前却依旧是一片黑暗。😫！！！亲爱的register你到底在哪里？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractUnsafe 也是内部类 tmd netty真会折腾</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</div><div class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</div><div class="line">        promise.setFailure(</div><div class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</div><div class="line">	 <span class="comment">// 关键点 其他不管 这里一定是最后一步了</span></div><div class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</div><div class="line">        register0(promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        	  <span class="comment">// 这里大有玄机</span></div><div class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    register0(promise);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</div><div class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</div><div class="line">            closeForcibly();</div><div class="line">            closeFuture.setClosed();</div><div class="line">            safeSetFailure(promise, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这段代码看不懂 先放这个地方 看懂了再来解读</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></div><div class="line">        <span class="comment">// call was outside of the eventLoop</span></div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</div><div class="line">        <span class="comment">// OIO版本中什么都不做</span></div><div class="line">        doRegister();</div><div class="line">        neverRegistered = <span class="keyword">false</span>;</div><div class="line">        registered = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></div><div class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></div><div class="line">        pipeline.invokeHandlerAddedIfNeeded();</div><div class="line"></div><div class="line">        safeSetSuccess(promise);</div><div class="line">        pipeline.fireChannelRegistered();</div><div class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></div><div class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></div><div class="line">        <span class="keyword">if</span> (isActive()) &#123;</div><div class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</div><div class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></div><div class="line">                <span class="comment">// again so that we process inbound data.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></div><div class="line">                beginRead();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></div><div class="line">        closeForcibly();</div><div class="line">        closeFuture.setClosed();</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>eventLoop.execute方法中不仅仅只执行一个Runnable就完了，因为Netty这个狗逼没有使用默认实现 而是自己实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SingleThreadEventExecutor的实现</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</div><div class="line">    <span class="comment">// 这个task就是register0的具体逻辑 这个逻辑暂时不管（因为看不懂😂）</span></div><div class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</div><div class="line">    	  <span class="comment">// 放到队列中</span></div><div class="line">        addTask(task);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    	 <span class="comment">// 终于露出马脚了 开线程了吧</span></div><div class="line">        startThread();</div><div class="line">        addTask(task);</div><div class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class="line">            reject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class="line">        wakeup(inEventLoop);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 开个线程都玩这么花</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</div><div class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                doStartThread();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</div><div class="line">                STATE_UPDATER.set(<span class="keyword">this</span>, ST_NOT_STARTED);</div><div class="line">                PlatformDependent.throwException(cause);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 这个executor就是ThreadPerTaskExecutor </span></div><div class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            thread = Thread.currentThread();</div><div class="line">            <span class="keyword">if</span> (interrupted) &#123;</div><div class="line">                thread.interrupt();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">            updateLastExecutionTime();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            		<span class="comment">// 这个狗逼玩的是真花 还去调别人的run 实际上是ThreadPerChannelEventLoop的实现</span></div><div class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</div><div class="line">                success = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            	<span class="comment">// 太多 不看了          </span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ThreadPerChannelEventLoop</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	 <span class="comment">// 死循环</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">    	 <span class="comment">// 这里的task就是AbstractUnsafe#register0的逻辑 当然也有可能是其他的</span></div><div class="line">        Runnable task = takeTask();</div><div class="line">        <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</div><div class="line">            task.run();</div><div class="line">            updateLastExecutionTime();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Channel ch = <span class="keyword">this</span>.ch;</div><div class="line">        <span class="keyword">if</span> (isShuttingDown()) &#123;</div><div class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</div><div class="line">                ch.unsafe().close(ch.unsafe().voidPromise());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (confirmShutdown()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Handle deregistration</span></div><div class="line">                <span class="keyword">if</span> (!ch.isRegistered()) &#123;</div><div class="line">                    runAllTasks();</div><div class="line">                    deregister();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整了这么多，依旧没有搞明白这个register到底在做什么。但是明白了一件事：找到了启动入口。</p>
<h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><p>在原生OIO网络编程中，实现一个服务器需要做这几个步骤：</p>
<ul>
<li>创建ServerSocket对象绑定监听端口。</li>
<li>通过accept()方法监听客户端的请求。</li>
<li>建立连接后，通过输入输出流读取客户端发送的请求信息。</li>
<li>通过输出流向客户端发送请求信息。</li>
<li>关闭相关资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ServerSocket server=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        server=<span class="keyword">new</span> ServerSocket(<span class="number">5209</span>);</div><div class="line">        <span class="comment">//b)指定绑定的端口，并监听此端口。</span></div><div class="line">        System.out.println(<span class="string">"服务器启动成功"</span>);</div><div class="line">        <span class="comment">//创建一个ServerSocket在端口5209监听客户请求</span></div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"没有启动监听："</span>+e);</div><div class="line">            <span class="comment">//出错，打印出错信息</span></div><div class="line">    &#125;</div><div class="line">    Socket socket=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        socket=server.accept();</div><div class="line">        <span class="comment">//2、调用accept()方法开始监听，等待客户端的连接 </span></div><div class="line">        <span class="comment">//使用accept()阻塞等待客户请求，有客户</span></div><div class="line">        <span class="comment">//请求到来则产生一个Socket对象，并继续执行</span></div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">        System.out.println(<span class="string">"Error."</span>+e);</div><div class="line">        <span class="comment">//出错，打印出错信息</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在Netty中的实现基本如此，只不过代码结构比较复杂罢了。这段代码在Netty中的的实现在OioServerSocketChannel中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    socket.bind(localAddress, config.getBacklog());</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (socket.isClosed()) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Socket s = socket.accept();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            buf.add(<span class="keyword">new</span> OioSocketChannel(<span class="keyword">this</span>, s));</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                s.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</div><div class="line">                logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">        <span class="comment">// Expected</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先绑定端口，再接受连接。这个接受连接是伪非阻塞的。因为用于连接的线程只有一个，没有客户端连进来的时候不能将其阻塞调。客户端连进来了就将这个「连接」交给别的线程处理，每个连接对应一个线程。这样就做到了连接和io处理不冲突。</p>
<p>当然，最后的执行肯定是到这一步，但是具体的执行调用过程可称得上困难重重。仔细回头看这个register0的处理逻辑，发现好像仅仅启动了一个线程，用于不断从队列中取任务执行的死循环而已。似乎没有直接表现出像绑定端口，接受连接的迹象。不能慌，这个老b隐藏得很深。回到最开始的地方，这个仅仅是register，姑且就到这里，先继续往下看，看到底又有什么新发现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> regFuture;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</div><div class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></div><div class="line">        ChannelPromise promise = channel.newPromise();</div><div class="line">        doBind0(regFuture, channel, localAddress, promise);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// 省略。。。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>initAndRegister方法经历千山万水终于启动了一个线程，目的就是返回一个ChannelFuture，先不管这个ChannelFuture到底是什么鬼，先将其理解为JDK中的Future的增强实现。一旦这个Future完成了，调用doBind0:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</div><div class="line">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></div><div class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.</span></div><div class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</div><div class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                promise.setFailure(regFuture.cause());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吧，这个鬼又向队列中添加了一个任务。这个任务核心就是去绑定。想都不用想，这个绑定一定是AbstractChannel中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// pipeline的bind有是其默认实现类中的子类TailContext中的实现</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 省略。。。</span></div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeBind(localAddress, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeBind(localAddress, promise);</div><div class="line">            &#125;</div><div class="line">        &#125;, promise, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后的bind是最终的核心逻辑。先找OutboundContext：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        ctx = ctx.prev;</div><div class="line">    &#125; <span class="keyword">while</span> (!ctx.outbound);</div><div class="line">    <span class="keyword">return</span> ctx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，调用这个方法的是tail，关于pipeline的结构有必要了解一下。<img src="https://segmentfault.com/img/bVEPxn?w=2387&amp;h=584" alt="image"></p>
<p>我们在这个Server初始化的时候添加了handler，比如LoggingHandler等。这些handler都会被添加到tail和head之间。即使你不添加任何handler，netty也会把自己内部的handler添加进去。handler又分为in和out，分别代表入站和出站。这段代码就是找出站的(只有out的才有bind方法)，一直向head方向找（废话，自己都是tail了只能往前找，后面没有了）。找到一个就算数，直接返回这个context。接着就是调用invokeBind方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyOutboundHandlerException(t, promise);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bind(localAddress, promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终的bind方法在if分支中。具体的执行逻辑为实现了out的handler，例如LoggingHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isEnabled(internalLevel)) &#123;</div><div class="line">        logger.log(internalLevel, format(ctx, <span class="string">"BIND"</span>, localAddress));</div><div class="line">    &#125;</div><div class="line">    ctx.bind(localAddress, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然这个handler仅仅只是来打印log的，完事之后又交给父类去执行。而父类依然是那段。因为之前是找到第一个实现out的handler就算数，这里又回到了这个pipeline中，继续往前找，最终会找到head（head不仅是out而且还是in，就是这么屌）。最终调用的是headcontext中的bind，而它的bind却是使用的是unsafe的bind：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></div><div class="line">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</div><div class="line">        <span class="keyword">throws</span> Exception &#123;</div><div class="line">    unsafe.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/576</span></div><div class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</div><div class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</div><div class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</div><div class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</div><div class="line">        <span class="comment">// Warn a user about the fact that a non-root user can't receive a</span></div><div class="line">        <span class="comment">// broadcast packet on *nix if the socket is bound on non-wildcard address.</span></div><div class="line">        logger.warn(</div><div class="line">                <span class="string">"A non-root user can't receive a broadcast packet if the socket "</span> +</div><div class="line">                <span class="string">"is not bound to a wildcard address; binding to a non-wildcard "</span> +</div><div class="line">                <span class="string">"address ("</span> + localAddress + <span class="string">") anyway as requested."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这个逻辑是有意思的 返回值为 !socket.isClosed()&amp;&amp; socket.isBound()</span></div><div class="line">    <span class="comment">// 没关且绑定了才为true 这里一定为false 因为肯定没绑定</span></div><div class="line">    <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    	 <span class="comment">// 看到这行代码就够了 其他不管</span></div><div class="line">        doBind(localAddress);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">        closeIfClosed();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 绑定完了isActive()肯定为true</span></div><div class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</div><div class="line">        <span class="comment">// 这段代码也得看</span></div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    safeSetSuccess(promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到doBind就知道怎么回事了，这就是之前所说的OioServerSocketChannel的doBind。终于完成了第一步：绑定端口。<br>接下来就是监听客户端连接，在invokeLater中将其实现了，一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeLater</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        eventLoop().execute(task);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">        logger.warn(<span class="string">"Can't invoke task later as EventLoop rejected it"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，依旧把这个任务放到线程中去执行了。这个任务到底是什么，很重要。代码中只给了一段<code>pipeline.fireChannelActive()</code>.看看具体实现吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext.invokeChannelActive(head);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// context为head 又交给了EventExecutor去执行</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeChannelActive();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用的是head的实现</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelInboundHandler) handler()).channelActive(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyHandlerException(t);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fireChannelActive();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// head的channelActive 这里的套路和之前的一样，先调用父类的 继续找pipeline中的handler只不过方向相反（从head到tail） 依次类推 如果某个handler不去调用ctx了，那么事件就到此为止不会传递下去了</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ctx.fireChannelActive();</div><div class="line">	 <span class="comment">// 这段代码是重点</span></div><div class="line">    readIfIsAutoRead();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 父类的fireChannelActive</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    invokeChannelActive(findContextInbound());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，一定一定是要做我们在OIO原生编程中的第二步了：接受连接了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</div><div class="line">        channel.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// OioSocketChannel的read 实际上是父类的</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    pipeline.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用的是pipeline的read</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    tail.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// tail的read</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeRead();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Runnable task = next.invokeReadTask;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">            next.invokeReadTask = task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    next.invokeRead();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        executor.execute(task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里我又打脸了，还有这么多层的调用！但是不要慌，因为逻辑是类似的。都是在pipeline这条链上找handler来调用，爱调不调的思想。这里的顺序是从tail到head。如果这个链中有哪个不长眼的没有将事件传递下去，那么最终就到不了head。正常情况下是一定要到head的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    unsafe.beginRead();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 什么都得考unsafe</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line">    <span class="keyword">if</span> (!isActive()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doBeginRead();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireExceptionCaught(e);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        close(voidPromise());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 最终还是将其丢给了eventLoop去执行 readTask是核心</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (readPending) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    readPending = <span class="keyword">true</span>;</div><div class="line">    eventLoop().execute(readTask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个readTask先将其定义好了，没有直接使用匿名内部类。一股清流啊！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable readTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        doRead();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个doRead有2个实现AbstractOioByteChannel和AbstractOioMessageChannel看名字都能知道区别，一个是读字节一个是读对象。最大的区别是OioByteStreamChannel是OioSocketChannel的父类而AbstractOioMessageChannel是OioServerSocketChannel的父类。这里使用的实现不用说也知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 太多省略不看</span></div><div class="line">    <span class="keyword">final</span> ChannelConfig config = config();</div><div class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</div><div class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class="line">    allocHandle.reset(config);</div><div class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</div><div class="line">    Throwable exception = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// Perform a read. 关键点</span></div><div class="line">            <span class="keyword">int</span> localRead = doReadMessages(readBuf);</div><div class="line">            <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</div><div class="line">                closed = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            allocHandle.incMessagesRead(localRead);</div><div class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        exception = t;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不看</span></div><div class="line">    <span class="comment">// 这里还省略了一个关键代码 一直想不明白的一个问题是这段代码是怎么能够一只run下去的</span></div><div class="line">    <span class="comment">// 因为eventloop中有个死循环，取的是任务队列中的任务去执行的，取的方式是take，也就是取出来就移除掉</span></div><div class="line">    <span class="comment">// 而下面这段代码则是将其继续加到任务队列中，只要没读到数据就继续将这个task添加到任务队列 这样就能一直死循环下去</span></div><div class="line">    <span class="comment">// Reading 0 bytes could mean there is a SocketTimeout and no data was actually read, so we</span></div><div class="line">    <span class="comment">// should execute read() again because no data may have been read.</span></div><div class="line">    read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终这个doReadMessages就是OioServerSocketChannel的实现。将监听客户端连接也放到了任务队列中，让线程去轮询。至于怎么去把消息读出来以及这个过程是怎样的，这是以后的事情。因为这次基本上将整个netty的核心组件都接触到了。接下来的源码解读会稍微轻松点。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Netty真屌，不接受反驳😂！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和高性能NIO相比，个人认为OIO的实现相对要简单一点，选择这个难度稍微低一点的实现来肯对目前的菜鸡我而言更现实。&lt;/p&gt;
&lt;p&gt;本质上而言，eventloopgroup就是线程池。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsfwn.com1.z0.glb.cl
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Netty" scheme="http://www.wei-dong.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(四)</title>
    <link href="http://www.wei-dong.top/2018/08/31/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E5%9B%9B)/"/>
    <id>http://www.wei-dong.top/2018/08/31/一起学RPC(四)/</id>
    <published>2018-08-31T08:17:23.000Z</published>
    <updated>2018-08-31T08:26:41.343Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中讲到了provider中针对consumer的请求消息封装<code>MessageTask</code>的部分细节。留下了最核心的处理消息的细节<code>process</code>方法没有说。</p>
<p>在继续对所谓的核心逻辑梳理之前，先整体的捋一捋之前文章的行文思路。</p>
<p>consumer的client发送一个请求报文，这个报文包含header头以及请求体，通过provider的解码器将其进行解码，解码后的对象为<code>JRequestPayload</code>或者<code>JResponsePayload</code>。这些解码后的对象还不属于业务层的，仅仅只是对数据包进行了第一层的封装。解码完成后，经过第一层包装的消息进入具体处理消息的handler，而这个handler并不允许处理太多业务逻辑，因为这是IO线程，处理多了会累死，消耗性能，影响别的请求。handler将消息丢给了processor来处理。然而processor是一个任劳任怨的老大哥，他也很聪明，叫来了<code>CloseableExecutor</code>大佬，也就是<code>Executor</code>家族的一员来帮忙处理这些消息。但是这个大佬只能处理特定的消息，针对这些“不认识”的消息有点懵逼，于是将这些消息做了一些加工，转化成<code>MessageTask</code>，这样子大佬们就开心快乐的去干活了。然而实际上大佬不会亲自去干活，他只“安排”小弟去干，而具体做什么都在<code>MessageTask</code>里面装着，将要做的事情全部安排在<code>run</code>方法中。接下来就是对这些消息进行处理了。</p>
<p>这里要做最重要的一步就是将payload中的字节根据header中的序列化规则进行解码（反序列化），这也可以算是第二次封装了。为啥要在这里处理而不是在解码器处理，还是因为不能影响IO线程，那个家伙娇贵的很，累不得。经过反序列化后的对象叫做<code>MessageWrapper</code>.这个家伙很真实，因为完全是属于业务层的包。无非就是consumer的诉求罢了：我要调用哪个接口，参数是什么，得是什么版本的blabla一系列信息。这些信息全部都放在传输层的body里面，现在通过反序列化真真实实的站在大佬面前。那么如何来处理consumer发送过来的请求呢？前提是得知道consumer端到底要什么。之前说过，consumer将请求报文全部封装到<code>MessageWrapper</code>中，而其中有一个非常重要的信息：<code>ServiceMetadata</code>。这个对象是一个“地址”，通过这个玩意provider就能找到consumer需要的调用对象以及其他相关的信息。原理也很简单，在provider发布的时候将这个“地址”在本地做一份映射不就完了。同时将这个地址发送到注册中心去。这样consumer到注册中心拿到这个地址然后向provider发送请求的时候，provider也就能做出回应了–找到对应的“服务”（本质上就是一个bean），通过consumer的请求参数，invoke一下，爱返回结果就返回结果，没有返回的拉倒。当然有结果返回的情况又涉及一次网络请求了–provider向consumer发送响应数据。</p>
<p>如此，rpc的前半个过程就完成了，接下来就是最最最伤脑筋的部分–调用。也就是上文未具体说到的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ServiceWrapper service)</span> </span>&#123;</div><div class="line">        <span class="comment">// stack copy</span></div><div class="line">        <span class="keyword">final</span> JRequest _request = request;</div><div class="line"></div><div class="line">        Context invokeCtx = <span class="keyword">new</span> Context(service);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (TracingUtil.isTracingNeeded()) &#123;</div><div class="line">            setCurrentTraceId(_request.message().getTraceId());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Object invokeResult = Chains.invoke(_request, invokeCtx)</div><div class="line">                    .getResult();</div><div class="line"></div><div class="line">            ResultWrapper result = <span class="keyword">new</span> ResultWrapper();</div><div class="line">            result.setResult(invokeResult);</div><div class="line">            <span class="keyword">byte</span> s_code = _request.serializerCode();</div><div class="line">            Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">            JResponsePayload responsePayload = <span class="keyword">new</span> JResponsePayload(_request.invokeId());</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">                OutputBuf outputBuf =</div><div class="line">                        serializer.writeObject(channel.allocOutputBuf(), result);</div><div class="line">                responsePayload.outputBuf(s_code, outputBuf);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">byte</span>[] bytes = serializer.writeObject(result);</div><div class="line">                responsePayload.bytes(s_code, bytes);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responsePayload.status(Status.OK.value());</div><div class="line"></div><div class="line">            handleWriteResponse(responsePayload);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">if</span> (INVOKE_ERROR == t) &#123;</div><div class="line">                <span class="comment">// handle biz exception</span></div><div class="line">                handleException(invokeCtx.getExpectCauseTypes(), invokeCtx.getCause());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                processor.handleException(channel, _request, Status.SERVER_ERROR, t);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (TracingUtil.isTracingNeeded()) &#123;</div><div class="line">                TracingUtil.clearCurrent();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码中最重要的一行是获取调用结果<code>invokeResult</code>。这里使用<code>Context</code>将<code>ServiceWrapper</code>进行封装了一下，然后使用<code>Chains#invoke</code>进行调用。其中就涉及到了一种设计模式–责任链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Chains</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JFilterChain headChain;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            JFilterChain invokeChain = <span class="keyword">new</span> DefaultFilterChain(<span class="keyword">new</span> InvokeFilter(), <span class="keyword">null</span>);</div><div class="line">            JFilterChain interceptChain = <span class="keyword">new</span> DefaultFilterChain(<span class="keyword">new</span> InterceptorsFilter(), invokeChain);</div><div class="line">            headChain = JFilterLoader.loadExtFilters(interceptChain, JFilter.Type.PROVIDER);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &lt;T extends JFilterContext&gt; <span class="function">T <span class="title">invoke</span><span class="params">(JRequest request, T invokeCtx)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            headChain.doFilter(request, invokeCtx);</div><div class="line">            <span class="keyword">return</span> invokeCtx;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这点代码很简单，首先在static代码块中初始化了几个chain。<code>headChain</code>为第一个chain，通过spi机制去动态加载<code>META-INF/services/</code>目录下的配置文件来实例化<code>JFilterChain</code>.当然只会去找类型为provider的chain，同时将下一个chain放进去。而下一个chain叫做<code>interceptChain</code>，也是预先被初始化了，其中的filter的实现为<code>InterceptorsFilter</code>,最后一个filterChain为<code>invokeChain</code>，通过命名就知道这个chain是真正用来执行具体业务处理的。他没有下一个节点。</p>
<p>具体的调用顺序是headChain调用doFilter，内部其实是headChain持有的filter实例来调用doFilter,同时将headChain持有的实例nextChain作为参数传递进去。如果headChain的filter处理不了，就调用next的doFilter，而next也是同样的结构，也能做出同样的处理，这样一层一层的调用直到chain的尾巴，得到结果后再一层一层返回。</p>
<p>这种设计思想非常典型，很多框架中都有责任链模式的身影。而我们讨论的核心在invokeChain这一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeFilter</span> <span class="keyword">implements</span> <span class="title">JFilter</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Type.PROVIDER;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> &lt;T extends JFilterContext&gt; <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(JRequest request, T filterCtx, JFilterChain next)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            MessageWrapper msg = request.message();</div><div class="line">            Context invokeCtx = (Context) filterCtx;</div><div class="line"></div><div class="line">            Object invokeResult = MessageTask.invoke(msg, invokeCtx);</div><div class="line"></div><div class="line">            invokeCtx.setResult(invokeResult);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，doFilter方法中并没有调用next，也证实了一点：这是chain的尾巴了。必须处理，不处理就没人处理了。而这里具体处理逻辑却又回到了<code>MessageTask#invoke</code>,兜兜转转又是一圈。最终将返回的结果使用<code>Context#setResult</code>进行填充。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invoke</span><span class="params">(MessageWrapper msg, Context invokeCtx)</span> <span class="keyword">throws</span> Signal </span>&#123;</div><div class="line">        ServiceWrapper service = invokeCtx.getService();</div><div class="line">        <span class="comment">// 得到具体的实例</span></div><div class="line">        Object provider = service.getServiceProvider();</div><div class="line">        <span class="comment">// 方法名</span></div><div class="line">        String methodName = msg.getMethodName();</div><div class="line">        <span class="comment">// 方法参数</span></div><div class="line">        Object[] args = msg.getArgs();</div><div class="line"></div><div class="line">		 <span class="comment">// metrics api 用于统计数据</span></div><div class="line">        Timer.Context timerCtx = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (METRIC_NEEDED) &#123;</div><div class="line">            timerCtx = Metrics.timer(msg.getOperationName()).time();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Class&lt;?&gt;[] expectCauseTypes = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt;&gt; methodExtension = service.getMethodExtension(methodName);</div><div class="line">            <span class="keyword">if</span> (methodExtension == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(methodName);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 根据JLS方法调用的静态分派规则查找最匹配的方法parameterTypes</span></div><div class="line">            Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt; bestMatch = Reflects.findMatchingParameterTypesExt(methodExtension, args);</div><div class="line">            Class&lt;?&gt;[] parameterTypes = bestMatch.getFirst();</div><div class="line">            expectCauseTypes = bestMatch.getSecond();</div><div class="line"></div><div class="line">            <span class="keyword">return</span> Reflects.fastInvoke(provider, methodName, parameterTypes, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            invokeCtx.setCauseAndExpectTypes(t, expectCauseTypes);</div><div class="line">            <span class="keyword">throw</span> INVOKE_ERROR;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (METRIC_NEEDED) &#123;</div><div class="line">                timerCtx.stop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码有点晦涩难懂。尤其是使用静态分派这块逻辑非常模糊。去看一下反射调用的相关api就知道，使用反射用到的参数得有方法名，方法参数，参数类型以及调用方法的对象。在<code>ServiceWrapper</code>实例中已经有了方法名，参数，要调用的方法对象很显然就是他自己，就剩下一个参数类型不知道了。当然在rpc中请求端也没法吧参数类型给你传过来，这里需要自己去判断了。而<code>Reflects.findMatchingParameterTypesExt</code>就是根据参数来判断参数类型到底是什么。最终使用<code>Reflects.fastInvoke(provider, methodName, parameterTypes, args);</code>来完成调用。从这里看到参数确实是刚才提到的四个参数，缺一不可。然而这里并没有去使用反射调用的，而是使用字节码直接生成子类（但是反射的本质不就是生成子类吗？有点懵逼）。其实还是有一点区别的，在使用反射的时候，以jdk反射为例，每代理一个方法就会生成一个代理类，在需要很多代理方法需要被调用的时候就回生成很多个代理类，这样就很消耗性能。而这里使用的是通过字节码工具自己生成一个子类，并且缓存下来，这样节省很多性能。在benchmark中跑的结果确实比jdk反射性能要好很多。具体的代码实现就不去纠结了，反正也看不明白，这里就当作是反射调用就行了。关于Java语言的这种“动态”特性我不得不吐槽一下，虽说提供了一种基于运行时的修改程序的行为机制，但是真的是很麻烦，光看api都会把人给搞晕，非常不友好。而现在很多动态语言就很人性化，想改就改，非常轻松。其实我还是很喜欢Javascript的。</p>
<p>最终，整个调用的逻辑都完完全全走通了。当然，这只是基于正常的调用，也就是没有出现异常的情况。如果出现了异常情况改怎么处理呢？比如说空指针，除数为0等情况。在invoke的逻辑中，直接将<code>Throwable</code>捕获到，塞进<code>Context</code>中，最后抛出异常。在process逻辑也里会有捕获动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(Class&lt;?&gt;[] exceptionTypes, Throwable failCause)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (exceptionTypes != <span class="keyword">null</span> &amp;&amp; exceptionTypes.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            Class&lt;?&gt; failType = failCause.getClass();</div><div class="line">            <span class="keyword">for</span> (Class&lt;?&gt; eType : exceptionTypes) &#123;</div><div class="line">                <span class="comment">// 如果抛出声明异常的子类, 客户端可能会因为不存在子类类型而无法序列化, 会在客户端抛出无法反序列化异常</span></div><div class="line">                <span class="keyword">if</span> (eType.isAssignableFrom(failType)) &#123;</div><div class="line">                    <span class="comment">// 预期内的异常</span></div><div class="line">                    processor.handleException(channel, request, Status.SERVICE_EXPECTED_ERROR, failCause);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 预期外的异常</span></div><div class="line">        processor.handleException(channel, request, Status.SERVICE_UNEXPECTED_ERROR, failCause);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>虽然这段代码比较长，但是核心就只有一点，处理异常消息。而正真做这件事交给了processor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doHandleException</span><span class="params">(</span></span></div><div class="line">            JChannel channel, <span class="keyword">long</span> invokeId, <span class="keyword">byte</span> s_code, <span class="keyword">byte</span> status, Throwable cause, <span class="keyword">boolean</span> closeChannel) &#123;</div><div class="line"></div><div class="line">        ResultWrapper result = <span class="keyword">new</span> ResultWrapper();</div><div class="line">        <span class="comment">// 截断cause, 避免客户端无法找到cause类型而无法序列化</span></div><div class="line">        cause = ThrowUtil.cutCause(cause);</div><div class="line">        result.setError(cause);</div><div class="line"></div><div class="line">        Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">        JResponsePayload response = <span class="keyword">new</span> JResponsePayload(invokeId);</div><div class="line">        response.status(status);</div><div class="line">        <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">            OutputBuf outputBuf =</div><div class="line">                    serializer.writeObject(channel.allocOutputBuf(), result);</div><div class="line">            response.outputBuf(s_code, outputBuf);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = serializer.writeObject(result);</div><div class="line">            response.bytes(s_code, bytes);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (closeChannel) &#123;</div><div class="line">            channel.write(response, JChannel.CLOSE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.write(response, <span class="keyword">new</span> JFutureListener&lt;JChannel&gt;() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationSuccess</span><span class="params">(JChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    logger.debug(<span class="string">"Service error message sent out: &#123;&#125;."</span>, channel);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationFailure</span><span class="params">(JChannel channel, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">                        logger.warn(<span class="string">"Service error message sent failed: &#123;&#125;, &#123;&#125;."</span>, channel, stackTrace(cause));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>无非就是将异常对象写出去，当然也不一定是异常对象，也有可能是正常对象，管他呢，反正都是对象，客户端能够通过status自行去判断到底是什么类型。这样子，客户端调用一个rpc方法就像调用本地方法一样，也可以打印正常的异常栈信息，但是只能知道发生了什么异常，没办法去定位到哪一行有问题，这是很尴尬的。当然实际生成中这和你调用方关系不大，只需要遵循一个原则：谁写的bug谁去改。轻松甩锅。</p>
<p>终于，provider的核心基本上写完了，还有很多细节需要慢慢地理一遍，毕竟涉及到很多知识盲区，需要时间慢慢消化。写到这里我才发现还有一个比较关键的点没有涉及到，那就是服务的发布。接下来的一篇文章会简单概述provider是怎么“发布”出去的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中讲到了provider中针对consumer的请求消息封装&lt;code&gt;MessageTask&lt;/code&gt;的部分细节。留下了最核心的处理消息的细节&lt;code&gt;process&lt;/code&gt;方法没有说。&lt;/p&gt;
&lt;p&gt;在继续对所谓的核心逻辑梳理之前，先整体的捋一捋
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(三)</title>
    <link href="http://www.wei-dong.top/2018/08/21/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%B8%89)/"/>
    <id>http://www.wei-dong.top/2018/08/21/一起学RPC(三)/</id>
    <published>2018-08-21T08:17:23.000Z</published>
    <updated>2018-08-21T08:24:45.776Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中讲到jupiter的传输模块transport中的编解码器的实现。对server来言，编解码器扮演着一头一尾的门卫角色，保证进来的人是干净的，也得保证出去的人也是干净的。当然这么比喻很不恰当，但是也想不到别的比喻了。</p>
<p>编解码器固然重要，但是没有核心的业务处理器也没多大意义。本文的重点就是核心处理器：<code>AcceptorHandler</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ChannelHandler</span>.Sharable</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptorHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> ProviderProcessor processor;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="function"><span class="keyword">public</span> ProviderProcessor <span class="title">processor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> processor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processor</span><span class="params">(ProviderProcessor processor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.processor = processor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现一个handler很容易，直接继承<code>ChannelInboundHandlerAdapter</code>就行了。当然这是针对server来说的。根据类名来看，正常情况下首先会联想到肯定会有个与之对应的。针对server来说，要处理的就是入站数据，使用inbound就行了。如果有更加复杂的逻辑处理，可以去看看官方文档中其他的派生类。同时，这个实例也是能够被共享的，道理也很简单：没有状态。也许你会问：这里分明是有成员变量的呀。但是，这个成员变量是不会被改变的。如果发生了变化，这个程序设计上就有问题。理论上是绝对不允许改变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       Channel ch = ctx.channel();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JRequestPayload) &#123;</div><div class="line">           JChannel jChannel = NettyChannel.attachChannel(ch);</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               processor.handleRequest(jChannel, (JRequestPayload) msg);</div><div class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">               processor.handleException(jChannel, (JRequestPayload) msg, Status.SERVER_ERROR, t);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unexpected message type received: &#123;&#125;, channel: &#123;&#125;."</span>, msg.getClass(), ch);</div><div class="line"></div><div class="line">           ReferenceCountUtil.release(msg);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="keyword">int</span> count = channelCounter.incrementAndGet();</div><div class="line"></div><div class="line">       logger.info(<span class="string">"Connects with &#123;&#125; as the &#123;&#125;th channel."</span>, ctx.channel(), count);</div><div class="line"></div><div class="line">       <span class="keyword">super</span>.channelActive(ctx);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="keyword">int</span> count = channelCounter.getAndDecrement();</div><div class="line"></div><div class="line">       logger.warn(<span class="string">"Disconnects with &#123;&#125; as the &#123;&#125;th channel."</span>, ctx.channel(), count);</div><div class="line"></div><div class="line">       <span class="keyword">super</span>.channelInactive(ctx);</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       Channel ch = ctx.channel();</div><div class="line">       ChannelConfig config = ch.config();</div><div class="line"></div><div class="line">       <span class="comment">// 高水位线: ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK</span></div><div class="line">       <span class="comment">// 低水位线: ChannelOption.WRITE_BUFFER_LOW_WATER_MARK</span></div><div class="line">       <span class="keyword">if</span> (!ch.isWritable()) &#123;</div><div class="line">           <span class="comment">// 当前channel的缓冲区(OutboundBuffer)大小超过了WRITE_BUFFER_HIGH_WATER_MARK</span></div><div class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">               logger.warn(<span class="string">"&#123;&#125; is not writable, high water mask: &#123;&#125;, the number of flushed entries that are not written yet: &#123;&#125;."</span>,</div><div class="line">                       ch, config.getWriteBufferHighWaterMark(), ch.unsafe().outboundBuffer().size());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           config.setAutoRead(<span class="keyword">false</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// 曾经高于高水位线的OutboundBuffer现在已经低于WRITE_BUFFER_LOW_WATER_MARK了</span></div><div class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">               logger.warn(<span class="string">"&#123;&#125; is writable(rehabilitate), low water mask: &#123;&#125;, the number of flushed entries that are not written yet: &#123;&#125;."</span>,</div><div class="line">                       ch, config.getWriteBufferLowWaterMark(), ch.unsafe().outboundBuffer().size());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           config.setAutoRead(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>AcceptorHandler</code>重写了几个方法。注意，重写<code>channelRead()</code>方法的时候记得调用<code>ReferenceCountUtil.release(msg)</code>。</p>
<p>其中最核心的逻辑在<code>channelRead()</code>中处理。无非就是将解码器中反序列化后的对象进行处理罢了。当然这里接受的仅仅是<code>JRequestPayload</code>类型。然后将Netty的原生<code>Channel</code>转化为自定义的<code>JChannel</code>类型。这样做的目的是为了将api统一，方便接入其他网络库实现。也就说如果要换别的网络框架如mina，不需要去改动我业务的代码，只需针对别的网络库的api进行编码即可。然后使用<code>ProviderProcessor</code>来处理具体的业务逻辑。这个接口中提供了两个操作：<code>handleRequest</code>和 <code>handleException</code>.因此具体的业务逻辑处理全部都传递给<code>ProviderProcessor</code>实现了。</p>
<p>而<code>channelWritabilityChanged</code>方法在可写状态发生变化的时候会被调用。可以通过<code>Channel#isWritable()</code>方法来获取状态。而这里对其重写是为了判断OutboundBuffer的大小有没有超过高水位线，这里的水位线是在<code>ChannelConfig</code>中设置的，server初始化的时候。超过高水位线就不允许自动去读数据了。这里有一点疑惑，不清楚为什么需要调用<code>config.setAutoRead(false)</code>。一个比较模糊的概念是Netty的写动作并不是直接向socket中写，而是写到Netty中的缓冲区中，这个缓冲区叫做<code>ChannelOutboundBuffer</code>，而这个buffer的实现是使用的无界链表，如果对方的接受太慢，就会导致这个链表无限大，最坏情况会导致OOM。因此提供一种机制：设置水位线。如果超过水位线就让用户来自己决定怎么处理，具体做法就是调用<code>channelWritabilityChanged</code>方法。这里的这个方法将自动读关闭了，这里面大有玄机。其实是利用了TCP的滑动窗口来控制的。</p>
<blockquote>
<p>比如咱俩喝酒, 你喝完一杯我就立刻给你满上, 最终你喝不动了 ,<br>不再举起杯子…. 你的杯子一直是满的, 我也没法继续给你倒酒</p>
</blockquote>
<p>这个栗子很形象地解释了滑动窗口。结合这个<a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="external">动画</a>更直观。</p>
<p><a href="http://www.cnblogs.com/rainy-shurun/p/5213086.html" target="_blank" rel="external">这里</a>有一篇文章值得参考。</p>
<p><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/water-2018-08-06-10-52-13.jpg?raw=true" alt="image"></p>
<p>接下来要讨论的是这个<code>processor</code>到底是怎么处理消息的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(DefaultProviderProcessor.class);</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CloseableExecutor executor;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DefaultProviderProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>(ProviderExecutors.executor());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DefaultProviderProcessor</span><span class="params">(CloseableExecutor executor)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.executor = executor;</div><div class="line">   &#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(JChannel channel, JRequestPayload requestPayload)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       MessageTask task = <span class="keyword">new</span> MessageTask(<span class="keyword">this</span>, channel, <span class="keyword">new</span> JRequest(requestPayload));</div><div class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</div><div class="line">           task.run();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           executor.execute(task);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实不难想到，<code>handleRequest</code>方法中将接受到的数据做了一层封装，然后丢给线程池去处理。在Netty中，业务处理逻辑绝对不能放在IO线程中执行。IO线程只负责读取/发送数据，不能进行业务处理。这是因为如果业务逻辑中有耗时的操作就会将IO线程阻塞住，这样正常的请求也就被阻塞了，影响应用的性能。而这里的线程池也被自定义了。</p>
<p><code>CloseableExecutor</code>是一个接口类型，正真的实现类是通过SPI机制由工厂创建出来的。关于SPI机制这里不会展开，将单独去整理一篇文章来说明。这种机制在很多框架中都有体现。</p>
<p>而包装类<code>MessageTask</code>的实现就很关键了。既然这个对象能放到线程池中，那么一定是一个<code>Runnable</code>或者<code>Callable</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// stack copy</span></div><div class="line">       <span class="keyword">final</span> DefaultProviderProcessor _processor = processor;</div><div class="line">       <span class="keyword">final</span> JRequest _request = request;</div><div class="line"></div><div class="line">       <span class="comment">// 全局流量控制</span></div><div class="line">       ControlResult ctrl = _processor.flowControl(_request);</div><div class="line">       <span class="keyword">if</span> (!ctrl.isAllowed()) &#123;</div><div class="line">           rejected(Status.APP_FLOW_CONTROL, <span class="keyword">new</span> JupiterFlowControlException(String.valueOf(ctrl)));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       MessageWrapper msg;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           JRequestPayload _requestPayload = _request.payload();</div><div class="line"></div><div class="line">           <span class="keyword">byte</span> s_code = _requestPayload.serializerCode();</div><div class="line">           Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">           <span class="comment">// 在业务线程中反序列化, 减轻IO线程负担</span></div><div class="line">           <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">               InputBuf inputBuf = _requestPayload.inputBuf();</div><div class="line">               msg = serializer.readObject(inputBuf, MessageWrapper.class);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">byte</span>[] bytes = _requestPayload.bytes();</div><div class="line">               msg = serializer.readObject(bytes, MessageWrapper.class);</div><div class="line">           &#125;</div><div class="line">           _requestPayload.clear();</div><div class="line"></div><div class="line">           _request.message(msg);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">           rejected(Status.BAD_REQUEST, <span class="keyword">new</span> JupiterBadRequestException(<span class="string">"reading request failed"</span>, t));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 查找服务</span></div><div class="line">       <span class="keyword">final</span> ServiceWrapper service = _processor.lookupService(msg.getMetadata());</div><div class="line">       <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">           rejected(Status.SERVICE_NOT_FOUND, <span class="keyword">new</span> JupiterServiceNotFoundException(String.valueOf(msg)));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// provider私有流量控制</span></div><div class="line">       FlowController&lt;JRequest&gt; childController = service.getFlowController();</div><div class="line">       <span class="keyword">if</span> (childController != <span class="keyword">null</span>) &#123;</div><div class="line">           ctrl = childController.flowControl(_request);</div><div class="line">           <span class="keyword">if</span> (!ctrl.isAllowed()) &#123;</div><div class="line">               rejected(Status.PROVIDER_FLOW_CONTROL, <span class="keyword">new</span> JupiterFlowControlException(String.valueOf(ctrl)));</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// processing</span></div><div class="line">       Executor childExecutor = service.getExecutor();</div><div class="line">       <span class="keyword">if</span> (childExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">           process(service);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// provider私有线程池执行</span></div><div class="line">           childExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   process(service);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这段代码十分简洁。首先将全局变量赋值为局部变量，我依稀记得在一个老外的代码中看到过，目的大概是为了节省性能。接下来就是全局流量控制，所谓的流量控制简单理解为防止请求太猛导致服务垮掉。有全局的就一定有局部的。而局部的控制是针对rpc中对外暴露某个服务。其粒度更小一点。然后就是反序列化了，这个过程在编解码器中也能完成，但是作者并没有这么做。目的也很简单，毕竟序列化是比较耗性能的，再说了，编解码器实际上也是在IO线程中处理的。这么做也是为了减轻IO线程负担。紧接着就是将序列化后的对象中的<code>ServiceMetadata</code>取出来 ，通过这个对象去本地容器中找<code>ServiceWrapper</code>。本地容器就是rpc的provider在发布一个服务到注册中心的时候本地也保存一个这个服务的相关信息。所谓的服务简单理解为就是一个service bean。而这个容器简单理解为就是一个map映射，<code>ServiceMetadata</code>为key，<code>ServiceWrapper</code>为value。找到这个<code>ServiceWrapper</code>后就很好办了，接下来就是调用这个service了。但是这个<code>ServiceWrapper</code>不仅仅是一个service，里面有很多额外的功能，比方可以有一个私有的线程池。如果有，那么在具体调用这个service的时候会使用这个私有的线程池。这种场景我反正没见过，但不排除有这种情况。如果没有那就很简单了，直接处理。这个处理过程也很容易想到，无非就是将要调用的service执行一遍，将结果序列化，再写出去。然而里面的代码实现可没有那么简单。</p>
<p>具体的处理逻辑全部都在<code>process</code>方法中。当然，在看具体实现之前很有必要对其中几个核类如<code>ServiceWrapper</code>和<code>MessageWrapper</code>进行解读。</p>
<p><code>MessageWrapper</code>可以简单理解为调用者发送的数据。包含要调用的对象，对象的方法，方法的参数。当然实际上比这些内容要复杂很多，比如链路追踪id等。有个最重要的参数<code>ServiceMetadata</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMetadata</span> <span class="keyword">extends</span> <span class="title">Directory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8908295634641380163L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String group;               <span class="comment">// 服务组别</span></div><div class="line">    <span class="keyword">private</span> String serviceProviderName; <span class="comment">// 服务名称</span></div><div class="line">    <span class="keyword">private</span> String version;             <span class="comment">// 服务版本号</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Directory</code>是一个抽象类。这个命名也很容易理解，顾名思义Directory是目录的意思。对于某个服务来说，单纯的知道服务名就足矣完成调用。但是在复杂的场景下，有成百上千个服务，要做到准确调用就得对其进行分类了。而且有时候还有同一个服务版本也不一样的情形，因此版本号也得作为这个目录中的某个层级。为什么成为metadata呢？这个属性在<code>ServiceWrapper</code>对象中也有。可以猜到了，一定是一一对应起来的。通俗解释来说<code>ServiceWrapper</code>是属于服务端的。也就是说provider发布本地服务到注册中心的同时，仅仅是将元数据发出去了，注册中心有了还不能完事，自己本地得确实存在呀，不然consumer从注册中心中拿到服务元数据了去provider里找不到这个服务，这非得骂娘不可。而ServiceWrapper正是将需要暴露出去的服务在本地存起来。仅此而已。其中最重要的属性就是服务对象<code>serviceProvider</code>了，对于rpc来说，consumer知道的仅仅是接口，正真去干活的还是实现类。而其余的花里胡哨的东西还是有点用的，得分场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceWrapper</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6690575889849847348L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 服务元数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceMetadata metadata;</div><div class="line">    <span class="comment">// 服务对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object serviceProvider;</div><div class="line">    <span class="comment">// 服务拦截器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProviderInterceptor[] interceptors;</div><div class="line">    <span class="comment">// key:     method name</span></div><div class="line">    <span class="comment">// value:   pair.first:  方法参数类型(用于根据JLS规则实现方法调用的静态分派)</span></div><div class="line">    <span class="comment">//          pair.second: 方法显式声明抛出的异常类型</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt;&gt;&gt; extensions;</div><div class="line"></div><div class="line">    <span class="comment">// 权重 hashCode() 与 equals() 不把weight计算在内</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = JConstants.DEFAULT_WEIGHT;</div><div class="line">    <span class="comment">// provider私有线程池</span></div><div class="line">    <span class="keyword">private</span> Executor executor;</div><div class="line">    <span class="comment">// provider私有流量控制器</span></div><div class="line">    <span class="keyword">private</span> FlowController&lt;JRequest&gt; flowController;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>而具体的核心处理逻辑<code>process</code>以后再慢慢看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中讲到jupiter的传输模块transport中的编解码器的实现。对server来言，编解码器扮演着一头一尾的门卫角色，保证进来的人是干净的，也得保证出去的人也是干净的。当然这么比喻很不恰当，但是也想不到别的比喻了。&lt;/p&gt;
&lt;p&gt;编解码器固然重要，但是没有核
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>小白探索大前端--使用vue实现简单轮播图</title>
    <link href="http://www.wei-dong.top/2018/08/15/%E5%B0%8F%E7%99%BD%E6%8E%A2%E7%B4%A2%E5%A4%A7%E5%89%8D%E7%AB%AF--%E4%BD%BF%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <id>http://www.wei-dong.top/2018/08/15/小白探索大前端--使用vue实现简单轮播图/</id>
    <published>2018-08-15T09:17:23.000Z</published>
    <updated>2018-08-15T10:04:51.119Z</updated>
    
    <content type="html"><![CDATA[<p>最近看完了《Vue实战》这本书，这也是我第一次完整的看完的一本关于前端的书籍（现在还在看的是《CSS世界》，有点想放弃了）。照着书中的demo都写了一遍，虽然很多栗子非常简单，但是值得学习的地方还是挺多的。当然也不得不吐槽很多用法都有点过时，尤其是关于webpack的配置。不过现在的前端发展很快，各种工具版本不断更新，代码过时也是能够理解的。对于学习者来说当然得学习最新的东西。</p>
<p>这篇文章主要是用来记录在自己实现一个【知乎日报移动版】的过程中遇到的一个坑，说坑也算不上，只能叫做坎坷之路吧。因为书中给的实战demo是一个pc版的，自己跟着写了一遍，觉得没有什么难度。然后在github上找了一下，发现用知乎日报来练手的项目很多，原因也很简单–api是现成的。于是我也蠢蠢欲动，决定使用vue亲自撸一个【知乎daily】。</p>
<p>虽然gayhub很多现成的项目，但是我并不打算去抄一遍。我在手机上下载了一个知乎日报的APP，按照不同功能截屏来一一实现。没办法，这就是工(zhuang)匠(bi)情(xin)怀(tai).</p>
<p>开发过程中，整体的框架功能上基本没什么问题，该自己写组件就自己写，绝没有偷懒。也遇到很多问题，比如开发环境下的接口代理、知乎图片的同源策略等。这些问题肯定难不倒我，都不值一提。让我觉得难受的还是首页的轮播图实现。这个问题困扰了我2天（准确时间是一天半，还有半天在工作：逃）。</p>
<p>遇到这个功能的时候第一反应是使用一个开源库，分分钟就搞定了。但是经过10s的思想斗争，工匠情怀终于战胜了理智，下定决心打算自己手动实现。然而，带来的结果就是卡顿了半天，没任何进展。网上也有很多教程，也是很简单的，可以说是基础操作了。可惜我被一篇文章带偏了，走了一点弯路。</p>
<p>这篇文章的思路很常规，很有道理。首先将一个框框用来装你要显示的图片，仅仅只能显示这个框框，而图片呢就放后面排排坐，通过定时器去移动图片，就像一格格的胶卷一样，轮到谁谁就被看到了。</p>
<p>我一开始就是按照这种思路去整，结果怎么整都实现不了（在移动端）。在一筹莫展之际，发现了一个更加屌的思路。这个思路和之前的不一样，区别在于后面的图片不是排排坐好，而是叠加到一块去。下面通过代码去一探究竟。</p>
<p>首先得整一个窗口，简单来说就是用来显示一张图片的容器，它的宽度对移动端而言就是屏幕宽度。他得有一个非常重要的属性<code>overflow：hidden</code>，当子元素尺寸超过其父亲的大小多余内容就会被隐藏。这里用<code>ul</code>标签来装图片，其实使用<code>div</code>也是没问题的。元素<code>li</code>的<code>position</code>属性得设置为<code>absolute</code>.因为使用这个属性就能脱离文档流，也就不会“排排坐”了，而是叠加到一起了，当然，最后的肯定叠在最上面，前提是没有显示的设置<code>z-index</code>属性。还有很重要的一点，子元素定位设置为<code>absolute</code>父元素记得也设置一下定位属性，因为子元素的相对位置是按照第一个祖先元素不为<code>static</code>的元素来的，不然会粗大事。 html代码结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"window"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">ref</span>=<span class="string">"imagesWrapper"</span>&gt;</span></div><div class="line">       </div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(e,i) in imgs"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"e.image"</span> <span class="attr">:alt</span>=<span class="string">"e.title"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>&#123;&#123;e.title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">     <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"point-wrap"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">:class</span>=<span class="string">"&#123;active:i==currentIndex&#125;"</span> <span class="attr">v-for</span>=<span class="string">"(e,i) in imgs"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">list-style-type</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> <span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100%);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.window</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个小技巧，在静态样式中并没有将图片直接展示出来，而是将所有图片向右偏移一个窗口宽度。这是有玄机的。</p>
<p>说了这么多，还没谈到vue的部分。在<code>container</code>容器中有一个<code>ref</code>标签。这是在vue中用来获取dom元素的。也许在vue中操作dom是不被推荐的，但是对于这种动态生成的<code>li</code>元素我找不到怎么去动态绑定其样式。因此采用了这种比较low的办法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">init() &#123;</div><div class="line">     <span class="keyword">let</span> wrappers = <span class="keyword">this</span>.$refs.imagesWrapper;</div><div class="line">     <span class="keyword">let</span> children = wrappers.children;</div><div class="line">     <span class="keyword">let</span> total = <span class="keyword">this</span>.imgs.length;</div><div class="line">     <span class="comment">// 纯js操作 只需要先将三张图片位置确定好</span></div><div class="line">     <span class="comment">// 最左边按道理说是没有图片的 但是为了无限滚动效果 这里将其置为最后一张</span></div><div class="line">     <span class="keyword">let</span> left = total - <span class="number">1</span>;</div><div class="line">     <span class="keyword">let</span> center = <span class="number">0</span>;</div><div class="line">     <span class="keyword">let</span> right = <span class="number">1</span>;</div><div class="line"></div><div class="line">     <span class="comment">// 初始化的时候将li左移动了一个屏幕宽度，就是为了防止叠加的元素挡住要显示的图</span></div><div class="line">     <span class="comment">// 现在第一张显示的图片实际是最后一张 3张轮播起来就行了 没必要对每个图片进行位置计算</span></div><div class="line">     <span class="comment">// left处于最左边的位置 不显示</span></div><div class="line">     children[left].style.transform = <span class="string">"translateX("</span> + -<span class="keyword">this</span>.distance + <span class="string">"px)"</span>;</div><div class="line">     <span class="comment">// center处于中间位置 显示</span></div><div class="line">     children[center].style.transform = <span class="string">"translateX("</span> + <span class="number">0</span> + <span class="string">"px)"</span>;</div><div class="line">     <span class="comment">// right处于右边 不显示</span></div><div class="line">     children[right].style.transform = <span class="string">"translateX("</span> + <span class="keyword">this</span>.distance + <span class="string">"px)"</span>;</div><div class="line">     <span class="keyword">this</span>.sliderItem = children;</div><div class="line">     <span class="comment">// this.play();</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>首先就是初始化显示的内容，之前在静态css样式中将图片移动到右边看不到的地方去了，现在就得手动操作让其可见。刚开始我以为直接将这些图片全部“铺开”，然后滚动，后来发现这么做很笨。直接操作三张就行了！为了实现无限滚动的效果，第一张的逻辑上的前一张是最后一张，因此将第一张的“上一张”给放到屏幕左边，下一张放到屏幕右边，要显示的也就是第一张（下标为0）归位到窗口，这和之前设置的全局的样式<code>transform: translateX(100%)</code>对应起来了。</p>
<p>如此以来，初始化的三张图片就定位好了，逻辑上也是没什么问题的。其余的改不显示还是显示不了，也不会参与移动。下面看看怎么“滚”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">next() &#123;</div><div class="line">     this.currentIndex++;</div><div class="line">     // 边界判断</div><div class="line">     if (this.currentIndex &gt; this.imgs.length - 1) &#123;</div><div class="line">       this.currentIndex = 0;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     // center 为显示的图片</div><div class="line">     let center = this.currentIndex;</div><div class="line">     // 左边的 如果为负数 就取最后一张图片下标</div><div class="line">     let left = center - 1 &lt; 0 ? this.imgs.length - 1 : center - 1;</div><div class="line">     // 右边的 如果超过了最大图片数量 取第一张图片下标</div><div class="line">     let right = center + 1 == this.imgs.length ? 0 : center + 1;</div><div class="line"></div><div class="line">     let children = this.sliderItem;</div><div class="line">     // 给元素添加过渡</div><div class="line">     children[center].style.transition = "transform .5s";</div><div class="line">     children[left].style.transition = "transform .5s";</div><div class="line">     // 右边的图片是替补图片，不需要走过渡</div><div class="line">     children[right].style.transition = "none";</div><div class="line">     // 3张图片同时移动</div><div class="line">     children[left].style.transform = "translateX(" + -this.distance + "px)";</div><div class="line">     children[center].style.transform = "translateX(0px)";</div><div class="line">     children[right].style.transform = "translateX(" + this.distance + "px)";</div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p><code>currentIndex</code>为全局变量，指当前显示的图片下标，每次调用<code>next</code>会子增，到上限后会回归到0，这些都是很常规的操作。接下来就是计算上一张，下一张图片的下标，也是很容易理解，无非多了一点判断，在最后一张显示的时候下一张的下标得置为0，上一张也是同理，不然就回”空指针”了。接下来就是针对这三张图片改变样式，原则就是移动到哪个下标就显示哪个图片，上一张就移到左边，下一站移动到右边，顺便给加个动画效果。如此而已！</p>
<p>最后就是自动播放的逻辑，也是非常简单，一个定时器就搞定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">play() &#123;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.timer) &#123;</div><div class="line">       <span class="built_in">window</span>.clearInterval(<span class="keyword">this</span>.timer);</div><div class="line">       <span class="keyword">this</span>.timer = <span class="literal">null</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">this</span>.timer = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">       <span class="keyword">this</span>.next();</div><div class="line">     &#125;, <span class="keyword">this</span>.interval);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后在钩子函数中将这方法加上去就完事了。一个自制的轮播组件就写完了。简陋但是简单。这里有一个不太重要的细节，针对窗口变化的时候得动态改变偏移量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 窗口变化 重新初始化</span></div><div class="line">   windowChange() &#123;</div><div class="line">     <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line">     <span class="built_in">window</span>.onresize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">       <span class="keyword">return</span> <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</div><div class="line">         <span class="built_in">window</span>.screenWidth = <span class="built_in">document</span>.body.clientWidth;</div><div class="line">         that.distance = <span class="built_in">window</span>.screenWidth;</div><div class="line">         <span class="keyword">this</span>.init();</div><div class="line">       &#125;)();</div><div class="line">     &#125;;</div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p>这样在pc端下也能正常“滚”动了。</p>
<p>最后，做一下小小的总结。这个组件虽然简单，但是也花了一定时间，毕竟踩坑的路是不能跳过的。其中花了很多时间纠结布局和样式，很是难受，都怪我没有把《CSS世界》看完。虽然简单，但是功能也很局限，比如没有实现手动去滑动。APP上是有这个功能的，那是因为我还没学会怎么在vue下使用touch事件（实际上是懒）。比如没有代码优化等等，总不能要求一个新手来造一个完美的轮子吧（给自己一点上升的空间咯）。造轮子不是目的，理解其中的所以然才是目的，现成的库有很多，完成功能也很容易，但是不能仅仅满足于此，我觉得作为手艺人得有一种格(xi)物(huan)致(zhuang)知(B)的精神。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3117395-0a23d3aadd128f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/662" alt="image"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://web.jobbole.com/94701/" target="_blank" rel="external">CSS深入理解之relative定位</a></p>
<p><a href="https://segmentfault.com/a/1190000011013572#articleHeader2" target="_blank" rel="external">几种原生js轮播图</a></p>
<p><a href="https://github.com/Mr-Vincent/zhihu-daily-app" target="_blank" rel="external">源码地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看完了《Vue实战》这本书，这也是我第一次完整的看完的一本关于前端的书籍（现在还在看的是《CSS世界》，有点想放弃了）。照着书中的demo都写了一遍，虽然很多栗子非常简单，但是值得学习的地方还是挺多的。当然也不得不吐槽很多用法都有点过时，尤其是关于webpack的配置。
    
    </summary>
    
      <category term="前端" scheme="http://www.wei-dong.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="VUE" scheme="http://www.wei-dong.top/tags/VUE/"/>
    
      <category term="Javascript" scheme="http://www.wei-dong.top/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(二)</title>
    <link href="http://www.wei-dong.top/2018/08/09/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%BA%8C)/"/>
    <id>http://www.wei-dong.top/2018/08/09/一起学RPC(二)/</id>
    <published>2018-08-09T10:17:23.000Z</published>
    <updated>2018-08-09T10:02:11.780Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中介绍到关于jupiter的底层通信模块transport的部分实现。仅仅只是讨论了整个server的初始化以及启动流程。很多细枝末节其实还没有涉及到，例如tcp参数设置，超时机制，编解码器等等实现细节。这些东西将会逐步被消化分解。而本文的主题是jupiter的业务编解码器的实现。</p>
<p>在jupiter中有一张图，这张图清晰地描述了整个server的数据流向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">* *********************************************************************</div><div class="line"> *            I/O Request                       I/O Response</div><div class="line"> *                 │                                 △</div><div class="line"> *                                                   │</div><div class="line"> *                 │</div><div class="line"> * ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─ ─ ─</div><div class="line"> * │               │                                                  │</div><div class="line"> *                                                   │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐       ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐   │</div><div class="line"> *     IdleStateChecker#inBound          IdleStateChecker#outBound</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘       └ ─ ─ ─ ─ ─ ─△─ ─ ─ ─ ─ ─ ┘   │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐                                     │</div><div class="line"> *     AcceptorIdleStateTrigger                      │</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                                     │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐       ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐   │</div><div class="line"> *          ProtocolDecoder                   ProtocolEncoder</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘       └ ─ ─ ─ ─ ─ ─△─ ─ ─ ─ ─ ─ ┘   │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐                                     │</div><div class="line"> *          AcceptorHandler                          │</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                                     │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                    ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐                     │</div><div class="line"> *                 ▽                                 │</div><div class="line"> * │               ─ ─ ▷│       Processor       ├ ─ ─▷                │</div><div class="line"> *</div><div class="line"> * │                    └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                     │</div><div class="line"> * ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</div><div class="line"> *</div></pre></td></tr></table></figure>
<p>实际上这个图仅仅是针对Netty api的描述，和rpc没有太多直接的关系。如果换做别的通信框架这个图就没有什么意义了。鉴于Netty依旧是目前Java网络开发中最流行的框架，拿出来讨论也是很有意义的。</p>
<p>这个图中有几个核心的概念：decode、encode、IdleStateChecker和handler。在编写一个网络应用的时候首先必须定义的是通信协议。比如上传下载文件使用ftp，即时聊天使用xmpp，浏览网页使用http…当然自己写一个rpc框架也得定义自己的通信协议。为什么要定义协议这个问题对于开发的老手来说没有必要去解释，不过我还是得啰嗦一下。在网络应用程序中，所有的数据在网络上的传输都是二进制格式，也就是0101010这样的机器码。当然也有人会反驳：不是有基于字符的数据吗？我的理解是在宏观上来说确实存在，那是因为上层的协议已经将代表字符串的01010解码成了可读的字符串。但是在底层的传输，也就是在物理层比如网线、电磁波中的传输依旧还是0101。当然用0101来比喻也是不恰当，更准确的说法应该是电平信号。而协议的作用是将通信双方的内容进行规范。就像以前写书信的时候，开头得有称谓，然后写正文，最后是落款这样一种格式。别人收到后就知道，嗯，这是一封信而不是一篇散文或者自传。当然这个比喻不是很恰当，但是就这样吧，不想废话了。</p>
<p>既然定义了协议，那么就得去处理协议。Netty中提供了很多内置的协议解析的类。通常被称作编解码器。顾名思义也就是将二进制转化为我们想要的数据结构，这样方便统一处理。这张图中的具体体现就是先解码，然后再处理，最后将处理结果编码后发送出去。编解码器将是本文讨论的重点。然而还有别的几个组件如空闲链路检查<code>IdleStateChecker</code>和业务处理<code>AcceptorHandler</code>组件，这些放在后面讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">boot.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                ch.pipeline().addLast(</div><div class="line">                        <span class="keyword">new</span> IdleStateChecker(timer, JConstants.READER_IDLE_TIME_SECONDS, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                        idleStateTrigger,</div><div class="line">                        CodecConfig.isCodecLowCopy() ? <span class="keyword">new</span> LowCopyProtocolDecoder() : <span class="keyword">new</span> ProtocolDecoder(),</div><div class="line">                        encoder,</div><div class="line">                        handler);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这段代码就是初始化编解码器等组件。可以看到handler作为业务核心处理器放在了最后。这是Netty的机制所决定的。关于Netty的一些设计可以看看<a href="http://ifeve.com/netty-in-action-1/" target="_blank" rel="external">这本书</a>作为基础入门。</p>
<p>看到解码器和编码器还有点不一样。解码器是直接new的方式添加到pipeline中的，而编码器是new好了再添加到pipeline中。其实具体差别就在于解码器不能共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">ProtocolDecoder</span>.<span class="title">State</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@ChannelHandler</span>.Sharable</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">PayloadHolder</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所谓的能共享，就是意味着每次都能使用这个编码器而不需要每次用就得实例化出来。而解码器不能被共享也是有原因的。因为解码器解码的数据全部来自于网络请求，网络通常而言是不可靠的，不能保证每次都能发送完整的数据包也有可能需要的数据还没收到。那么如何保证接受到的数据是完整的呢？实际上是没法保证，只能够“假装”是完整的。所以decoder是继承自<code>ReplayingDecoder</code>。这个类的作用简单通俗来理解就是如果网络上的数据还没发完，我就继续接收，直到收完为止。具体的工作原理可以参考api文档或者源码，这里不再过多探讨。为什么继承这个类后就不能共享呢？这个类是个泛型，参数是一个state的字眼。看到这里大概可以联想到这个类肯定和状态有关系。这样就很容易理解了，有状态的对象通常不能被共享。想象一下，在多线程环境下，线程A将这个状态改为1线程B这时候拿到执行权又把这个状态改为2，然后线程A又要使用这个状态变量了，这时候就不是他刚开始改变的状态了。如此一来，全部乱套了。这些都是并发基础相关的内容，有兴趣可以去谷歌。这里不再过多描述。而encode则没有状态变量，需要编码的数据一定是确定的，不存在解码器中数据不完整的情况。因此使用共享实例没什么问题。具体可以看看其中的代码实现：<a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-transport/jupiter-transport-netty/src/main/java/org/jupiter/transport/netty/handler/ProtocolDecoder.java" target="_blank" rel="external">ProtocolDecoder</a>  <a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-transport/jupiter-transport-netty/src/main/java/org/jupiter/transport/netty/handler/ProtocolEncoder.java" target="_blank" rel="external">ProtocolEncoder</a></p>
<p>解释完这些鸡毛蒜皮的细节，接下来开始分析一下这个协议的定义以及解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">* **************************************************************************************************</div><div class="line">*                                          Protocol</div><div class="line">*  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</div><div class="line">*       2   │   1   │    1   │     8     │      4      │</div><div class="line">*  ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤</div><div class="line">*           │       │        │           │             │</div><div class="line">*  │  MAGIC   Sign    Status   Invoke Id    Body Size                    Body Content              │</div><div class="line">*           │       │        │           │             │</div><div class="line">*  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</div><div class="line">*</div><div class="line">* 消息头16个字节定长</div><div class="line">* = 2 // magic = (short) 0xbabe</div><div class="line">* + 1 // 消息标志位, 低地址4位用来表示消息类型request/response/heartbeat等, 高地址4位用来表示序列化类型</div><div class="line">* + 1 // 状态位, 设置请求响应状态</div><div class="line">* + 8 // 消息 id, long 类型, 未来jupiter可能将id限制在48位, 留出高地址的16位作为扩展字段</div><div class="line">* + 4 // 消息体 body 长度, int 类型</div><div class="line">*</div></pre></td></tr></table></figure>
<p>作者在代码中将协议格式完全标注出来了:16字节的消息头+消息体。消息头中的MAGIC字段仅仅是为了标识这个数据包是属于jupiter。就像java class文件以<code>0xCAFEBABE</code>开头一样。没有实际的意义，仅仅做个标识而已。其他的字段也就没什么可说的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_COMPOSITE_BUF = SystemPropertyUtil.getBoolean(<span class="string">"jupiter.io.decoder.composite.buf"</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProtocolDecoder</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(State.MAGIC);</div><div class="line">       <span class="keyword">if</span> (USE_COMPOSITE_BUF) &#123;</div><div class="line">           setCumulator(COMPOSITE_CUMULATOR);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">enum</span> State &#123;</div><div class="line">       MAGIC,</div><div class="line">       SIGN,</div><div class="line">       STATUS,</div><div class="line">       ID,</div><div class="line">       BODY_SIZE,</div><div class="line">       BODY</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>解码器的构造函数中直接调用了父类的构造函数，将枚举类型<code>State</code>传入。这个枚举类型所代表的就是要解析协议数据中的位置（下标）。因此构造器中传入的当然是协议的第一个字段，也就表示从第一个位置开始解析。然后有一个布尔标识，这个变量从系统变量中获取，用来决定是否使用<code>COMPOSITE_CUMULATOR</code>。默认的CUMULATOR是<code>MERGE_CUMULATOR</code>.区别可能在性能上有点差距吧。具体差异得去研究源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> JProtocolHeader header = <span class="keyword">new</span> JProtocolHeader();</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (state()) &#123;</div><div class="line">            <span class="keyword">case</span> MAGIC:</div><div class="line">                checkMagic(in.readShort());         <span class="comment">// MAGIC</span></div><div class="line">                checkpoint(State.SIGN);</div><div class="line">            <span class="keyword">case</span> SIGN:</div><div class="line">                header.sign(in.readByte());         <span class="comment">// 消息标志位</span></div><div class="line">                checkpoint(State.STATUS);</div><div class="line">            <span class="keyword">case</span> STATUS:</div><div class="line">                header.status(in.readByte());       <span class="comment">// 状态位</span></div><div class="line">                checkpoint(State.ID);</div><div class="line">            <span class="keyword">case</span> ID:</div><div class="line">                header.id(in.readLong());           <span class="comment">// 消息id</span></div><div class="line">                checkpoint(State.BODY_SIZE);</div><div class="line">            <span class="keyword">case</span> BODY_SIZE:</div><div class="line">                header.bodySize(in.readInt());      <span class="comment">// 消息体长度</span></div><div class="line">                checkpoint(State.BODY);</div><div class="line">            <span class="keyword">case</span> BODY:</div><div class="line">                <span class="keyword">switch</span> (header.messageCode()) &#123;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.HEARTBEAT:</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.REQUEST: &#123;</div><div class="line">                        <span class="keyword">int</span> length = checkBodySize(header.bodySize());</div><div class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">                        in.readBytes(bytes);</div><div class="line"></div><div class="line">                        JRequestPayload request = <span class="keyword">new</span> JRequestPayload(header.id());</div><div class="line">                        request.timestamp(SystemClock.millisClock().now());</div><div class="line">                        request.bytes(header.serializerCode(), bytes);</div><div class="line"></div><div class="line">                        out.add(request);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.RESPONSE: &#123;</div><div class="line">                        <span class="keyword">int</span> length = checkBodySize(header.bodySize());</div><div class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">                        in.readBytes(bytes);</div><div class="line"></div><div class="line">                        JResponsePayload response = <span class="keyword">new</span> JResponsePayload(header.id());</div><div class="line">                        response.status(header.status());</div><div class="line">                        response.bytes(header.serializerCode(), bytes);</div><div class="line"></div><div class="line">                        out.add(response);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        <span class="keyword">throw</span> IoSignals.ILLEGAL_SIGN;</div><div class="line">                &#125;</div><div class="line">                checkpoint(State.MAGIC);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>正真的解析逻辑全部在<code>decode</code>方法中。这里的每个case并没有break，道理很简单，每解析一段数据后得接着继续往下解析，如果break掉了后面的数据不全都放弃解析了吗？每当解析到一个位置，都将这个位置上读取的数据放到<code>header</code>变量中，同时将接下来需要解析的位置记录下来（通过<code>checkpoint(...)</code>方法）。之所以要记录下来，万一某个位置解析出错，下次就不用从头再来了，直接上次出错的位置接着来就行了，也是为了提高性能。然而解析到body部分的时候，header里面内容都已经全部填充好了。接下来就是根据消息类型来处理body里的内容。如果是心跳包，那么什么都不做直接返回，因为body里肯定是没有数据的。如果是请求包(<code>REQUEST</code>类型)，先从header里读取这个body到底有多长，然后再去读这么长的数据，最后通过<code>JRequestPayload</code>对象将这个body数据封装起来，同时将消息id和序列化类型code也封装进去了。响应包类型逻辑与之类似。整个解码器解析逻辑就完成了。</p>
<p>与之对应的就是编码器了，编码器逻辑更简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, PayloadHolder msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JRequestPayload) &#123;</div><div class="line">            doEncodeRequest((JRequestPayload) msg, out);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JResponsePayload) &#123;</div><div class="line">            doEncodeResponse((JResponsePayload) msg, out);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Reflects.simpleClassName(msg));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doEncodeRequest</span><span class="params">(JRequestPayload request, ByteBuf out)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> sign = JProtocolHeader.toSign(request.serializerCode(), JProtocolHeader.REQUEST);</div><div class="line">        <span class="keyword">long</span> invokeId = request.invokeId();</div><div class="line">        <span class="keyword">byte</span>[] bytes = request.bytes();</div><div class="line">        <span class="keyword">int</span> length = bytes.length;</div><div class="line"></div><div class="line">        out.writeShort(JProtocolHeader.MAGIC)</div><div class="line">                .writeByte(sign)</div><div class="line">                .writeByte(<span class="number">0x00</span>)</div><div class="line">                .writeLong(invokeId)</div><div class="line">                .writeInt(length)</div><div class="line">                .writeBytes(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doEncodeResponse</span><span class="params">(JResponsePayload response, ByteBuf out)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> sign = JProtocolHeader.toSign(response.serializerCode(), JProtocolHeader.RESPONSE);</div><div class="line">        <span class="keyword">byte</span> status = response.status();</div><div class="line">        <span class="keyword">long</span> invokeId = response.id();</div><div class="line">        <span class="keyword">byte</span>[] bytes = response.bytes();</div><div class="line">        <span class="keyword">int</span> length = bytes.length;</div><div class="line"></div><div class="line">        out.writeShort(JProtocolHeader.MAGIC)</div><div class="line">                .writeByte(sign)</div><div class="line">                .writeByte(status)</div><div class="line">                .writeLong(invokeId)</div><div class="line">                .writeInt(length)</div><div class="line">                .writeBytes(bytes);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>和解码器相反，编码器就是将对象中的数据按协议中的定义挨个写到buf中。</p>
<p>以上，jupiter中的消息编解码器的实现就全部整理完了。当然还有空闲链路检测部分，因此我决定暂时放弃这部分，太复杂了，等所有逻辑整理完毕后再接着填坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中介绍到关于jupiter的底层通信模块transport的部分实现。仅仅只是讨论了整个server的初始化以及启动流程。很多细枝末节其实还没有涉及到，例如tcp参数设置，超时机制，编解码器等等实现细节。这些东西将会逐步被消化分解。而本文的主题是jupiter的业务
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
</feed>
