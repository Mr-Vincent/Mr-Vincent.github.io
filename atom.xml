<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DongWei&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wei-dong.top/"/>
  <updated>2018-08-31T08:26:41.343Z</updated>
  <id>http://www.wei-dong.top/</id>
  
  <author>
    <name>Mr-Vincent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一起学RPC(四)</title>
    <link href="http://www.wei-dong.top/2018/08/31/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E5%9B%9B)/"/>
    <id>http://www.wei-dong.top/2018/08/31/一起学RPC(四)/</id>
    <published>2018-08-31T08:17:23.000Z</published>
    <updated>2018-08-31T08:26:41.343Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中讲到了provider中针对consumer的请求消息封装<code>MessageTask</code>的部分细节。留下了最核心的处理消息的细节<code>process</code>方法没有说。</p>
<p>在继续对所谓的核心逻辑梳理之前，先整体的捋一捋之前文章的行文思路。</p>
<p>consumer的client发送一个请求报文，这个报文包含header头以及请求体，通过provider的解码器将其进行解码，解码后的对象为<code>JRequestPayload</code>或者<code>JResponsePayload</code>。这些解码后的对象还不属于业务层的，仅仅只是对数据包进行了第一层的封装。解码完成后，经过第一层包装的消息进入具体处理消息的handler，而这个handler并不允许处理太多业务逻辑，因为这是IO线程，处理多了会累死，消耗性能，影响别的请求。handler将消息丢给了processor来处理。然而processor是一个任劳任怨的老大哥，他也很聪明，叫来了<code>CloseableExecutor</code>大佬，也就是<code>Executor</code>家族的一员来帮忙处理这些消息。但是这个大佬只能处理特定的消息，针对这些“不认识”的消息有点懵逼，于是将这些消息做了一些加工，转化成<code>MessageTask</code>，这样子大佬们就开心快乐的去干活了。然而实际上大佬不会亲自去干活，他只“安排”小弟去干，而具体做什么都在<code>MessageTask</code>里面装着，将要做的事情全部安排在<code>run</code>方法中。接下来就是对这些消息进行处理了。</p>
<p>这里要做最重要的一步就是将payload中的字节根据header中的序列化规则进行解码（反序列化），这也可以算是第二次封装了。为啥要在这里处理而不是在解码器处理，还是因为不能影响IO线程，那个家伙娇贵的很，累不得。经过反序列化后的对象叫做<code>MessageWrapper</code>.这个家伙很真实，因为完全是属于业务层的包。无非就是consumer的诉求罢了：我要调用哪个接口，参数是什么，得是什么版本的blabla一系列信息。这些信息全部都放在传输层的body里面，现在通过反序列化真真实实的站在大佬面前。那么如何来处理consumer发送过来的请求呢？前提是得知道consumer端到底要什么。之前说过，consumer将请求报文全部封装到<code>MessageWrapper</code>中，而其中有一个非常重要的信息：<code>ServiceMetadata</code>。这个对象是一个“地址”，通过这个玩意provider就能找到consumer需要的调用对象以及其他相关的信息。原理也很简单，在provider发布的时候将这个“地址”在本地做一份映射不就完了。同时将这个地址发送到注册中心去。这样consumer到注册中心拿到这个地址然后向provider发送请求的时候，provider也就能做出回应了–找到对应的“服务”（本质上就是一个bean），通过consumer的请求参数，invoke一下，爱返回结果就返回结果，没有返回的拉倒。当然有结果返回的情况又涉及一次网络请求了–provider向consumer发送响应数据。</p>
<p>如此，rpc的前半个过程就完成了，接下来就是最最最伤脑筋的部分–调用。也就是上文未具体说到的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ServiceWrapper service)</span> </span>&#123;</div><div class="line">        <span class="comment">// stack copy</span></div><div class="line">        <span class="keyword">final</span> JRequest _request = request;</div><div class="line"></div><div class="line">        Context invokeCtx = <span class="keyword">new</span> Context(service);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (TracingUtil.isTracingNeeded()) &#123;</div><div class="line">            setCurrentTraceId(_request.message().getTraceId());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Object invokeResult = Chains.invoke(_request, invokeCtx)</div><div class="line">                    .getResult();</div><div class="line"></div><div class="line">            ResultWrapper result = <span class="keyword">new</span> ResultWrapper();</div><div class="line">            result.setResult(invokeResult);</div><div class="line">            <span class="keyword">byte</span> s_code = _request.serializerCode();</div><div class="line">            Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">            JResponsePayload responsePayload = <span class="keyword">new</span> JResponsePayload(_request.invokeId());</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">                OutputBuf outputBuf =</div><div class="line">                        serializer.writeObject(channel.allocOutputBuf(), result);</div><div class="line">                responsePayload.outputBuf(s_code, outputBuf);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">byte</span>[] bytes = serializer.writeObject(result);</div><div class="line">                responsePayload.bytes(s_code, bytes);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responsePayload.status(Status.OK.value());</div><div class="line"></div><div class="line">            handleWriteResponse(responsePayload);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">if</span> (INVOKE_ERROR == t) &#123;</div><div class="line">                <span class="comment">// handle biz exception</span></div><div class="line">                handleException(invokeCtx.getExpectCauseTypes(), invokeCtx.getCause());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                processor.handleException(channel, _request, Status.SERVER_ERROR, t);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (TracingUtil.isTracingNeeded()) &#123;</div><div class="line">                TracingUtil.clearCurrent();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码中最重要的一行是获取调用结果<code>invokeResult</code>。这里使用<code>Context</code>将<code>ServiceWrapper</code>进行封装了一下，然后使用<code>Chains#invoke</code>进行调用。其中就涉及到了一种设计模式–责任链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Chains</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JFilterChain headChain;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            JFilterChain invokeChain = <span class="keyword">new</span> DefaultFilterChain(<span class="keyword">new</span> InvokeFilter(), <span class="keyword">null</span>);</div><div class="line">            JFilterChain interceptChain = <span class="keyword">new</span> DefaultFilterChain(<span class="keyword">new</span> InterceptorsFilter(), invokeChain);</div><div class="line">            headChain = JFilterLoader.loadExtFilters(interceptChain, JFilter.Type.PROVIDER);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &lt;T extends JFilterContext&gt; <span class="function">T <span class="title">invoke</span><span class="params">(JRequest request, T invokeCtx)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            headChain.doFilter(request, invokeCtx);</div><div class="line">            <span class="keyword">return</span> invokeCtx;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这点代码很简单，首先在static代码块中初始化了几个chain。<code>headChain</code>为第一个chain，通过spi机制去动态加载<code>META-INF/services/</code>目录下的配置文件来实例化<code>JFilterChain</code>.当然只会去找类型为provider的chain，同时将下一个chain放进去。而下一个chain叫做<code>interceptChain</code>，也是预先被初始化了，其中的filter的实现为<code>InterceptorsFilter</code>,最后一个filterChain为<code>invokeChain</code>，通过命名就知道这个chain是真正用来执行具体业务处理的。他没有下一个节点。</p>
<p>具体的调用顺序是headChain调用doFilter，内部其实是headChain持有的filter实例来调用doFilter,同时将headChain持有的实例nextChain作为参数传递进去。如果headChain的filter处理不了，就调用next的doFilter，而next也是同样的结构，也能做出同样的处理，这样一层一层的调用直到chain的尾巴，得到结果后再一层一层返回。</p>
<p>这种设计思想非常典型，很多框架中都有责任链模式的身影。而我们讨论的核心在invokeChain这一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeFilter</span> <span class="keyword">implements</span> <span class="title">JFilter</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Type.PROVIDER;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> &lt;T extends JFilterContext&gt; <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(JRequest request, T filterCtx, JFilterChain next)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            MessageWrapper msg = request.message();</div><div class="line">            Context invokeCtx = (Context) filterCtx;</div><div class="line"></div><div class="line">            Object invokeResult = MessageTask.invoke(msg, invokeCtx);</div><div class="line"></div><div class="line">            invokeCtx.setResult(invokeResult);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，doFilter方法中并没有调用next，也证实了一点：这是chain的尾巴了。必须处理，不处理就没人处理了。而这里具体处理逻辑却又回到了<code>MessageTask#invoke</code>,兜兜转转又是一圈。最终将返回的结果使用<code>Context#setResult</code>进行填充。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invoke</span><span class="params">(MessageWrapper msg, Context invokeCtx)</span> <span class="keyword">throws</span> Signal </span>&#123;</div><div class="line">        ServiceWrapper service = invokeCtx.getService();</div><div class="line">        <span class="comment">// 得到具体的实例</span></div><div class="line">        Object provider = service.getServiceProvider();</div><div class="line">        <span class="comment">// 方法名</span></div><div class="line">        String methodName = msg.getMethodName();</div><div class="line">        <span class="comment">// 方法参数</span></div><div class="line">        Object[] args = msg.getArgs();</div><div class="line"></div><div class="line">		 <span class="comment">// metrics api 用于统计数据</span></div><div class="line">        Timer.Context timerCtx = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (METRIC_NEEDED) &#123;</div><div class="line">            timerCtx = Metrics.timer(msg.getOperationName()).time();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Class&lt;?&gt;[] expectCauseTypes = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt;&gt; methodExtension = service.getMethodExtension(methodName);</div><div class="line">            <span class="keyword">if</span> (methodExtension == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(methodName);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 根据JLS方法调用的静态分派规则查找最匹配的方法parameterTypes</span></div><div class="line">            Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt; bestMatch = Reflects.findMatchingParameterTypesExt(methodExtension, args);</div><div class="line">            Class&lt;?&gt;[] parameterTypes = bestMatch.getFirst();</div><div class="line">            expectCauseTypes = bestMatch.getSecond();</div><div class="line"></div><div class="line">            <span class="keyword">return</span> Reflects.fastInvoke(provider, methodName, parameterTypes, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            invokeCtx.setCauseAndExpectTypes(t, expectCauseTypes);</div><div class="line">            <span class="keyword">throw</span> INVOKE_ERROR;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (METRIC_NEEDED) &#123;</div><div class="line">                timerCtx.stop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码有点晦涩难懂。尤其是使用静态分派这块逻辑非常模糊。去看一下反射调用的相关api就知道，使用反射用到的参数得有方法名，方法参数，参数类型以及调用方法的对象。在<code>ServiceWrapper</code>实例中已经有了方法名，参数，要调用的方法对象很显然就是他自己，就剩下一个参数类型不知道了。当然在rpc中请求端也没法吧参数类型给你传过来，这里需要自己去判断了。而<code>Reflects.findMatchingParameterTypesExt</code>就是根据参数来判断参数类型到底是什么。最终使用<code>Reflects.fastInvoke(provider, methodName, parameterTypes, args);</code>来完成调用。从这里看到参数确实是刚才提到的四个参数，缺一不可。然而这里并没有去使用反射调用的，而是使用字节码直接生成子类（但是反射的本质不就是生成子类吗？有点懵逼）。其实还是有一点区别的，在使用反射的时候，以jdk反射为例，每代理一个方法就会生成一个代理类，在需要很多代理方法需要被调用的时候就回生成很多个代理类，这样就很消耗性能。而这里使用的是通过字节码工具自己生成一个子类，并且缓存下来，这样节省很多性能。在benchmark中跑的结果确实比jdk反射性能要好很多。具体的代码实现就不去纠结了，反正也看不明白，这里就当作是反射调用就行了。关于Java语言的这种“动态”特性我不得不吐槽一下，虽说提供了一种基于运行时的修改程序的行为机制，但是真的是很麻烦，光看api都会把人给搞晕，非常不友好。而现在很多动态语言就很人性化，想改就改，非常轻松。其实我还是很喜欢Javascript的。</p>
<p>最终，整个调用的逻辑都完完全全走通了。当然，这只是基于正常的调用，也就是没有出现异常的情况。如果出现了异常情况改怎么处理呢？比如说空指针，除数为0等情况。在invoke的逻辑中，直接将<code>Throwable</code>捕获到，塞进<code>Context</code>中，最后抛出异常。在process逻辑也里会有捕获动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(Class&lt;?&gt;[] exceptionTypes, Throwable failCause)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (exceptionTypes != <span class="keyword">null</span> &amp;&amp; exceptionTypes.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            Class&lt;?&gt; failType = failCause.getClass();</div><div class="line">            <span class="keyword">for</span> (Class&lt;?&gt; eType : exceptionTypes) &#123;</div><div class="line">                <span class="comment">// 如果抛出声明异常的子类, 客户端可能会因为不存在子类类型而无法序列化, 会在客户端抛出无法反序列化异常</span></div><div class="line">                <span class="keyword">if</span> (eType.isAssignableFrom(failType)) &#123;</div><div class="line">                    <span class="comment">// 预期内的异常</span></div><div class="line">                    processor.handleException(channel, request, Status.SERVICE_EXPECTED_ERROR, failCause);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 预期外的异常</span></div><div class="line">        processor.handleException(channel, request, Status.SERVICE_UNEXPECTED_ERROR, failCause);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>虽然这段代码比较长，但是核心就只有一点，处理异常消息。而正真做这件事交给了processor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doHandleException</span><span class="params">(</span></span></div><div class="line">            JChannel channel, <span class="keyword">long</span> invokeId, <span class="keyword">byte</span> s_code, <span class="keyword">byte</span> status, Throwable cause, <span class="keyword">boolean</span> closeChannel) &#123;</div><div class="line"></div><div class="line">        ResultWrapper result = <span class="keyword">new</span> ResultWrapper();</div><div class="line">        <span class="comment">// 截断cause, 避免客户端无法找到cause类型而无法序列化</span></div><div class="line">        cause = ThrowUtil.cutCause(cause);</div><div class="line">        result.setError(cause);</div><div class="line"></div><div class="line">        Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">        JResponsePayload response = <span class="keyword">new</span> JResponsePayload(invokeId);</div><div class="line">        response.status(status);</div><div class="line">        <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">            OutputBuf outputBuf =</div><div class="line">                    serializer.writeObject(channel.allocOutputBuf(), result);</div><div class="line">            response.outputBuf(s_code, outputBuf);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = serializer.writeObject(result);</div><div class="line">            response.bytes(s_code, bytes);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (closeChannel) &#123;</div><div class="line">            channel.write(response, JChannel.CLOSE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.write(response, <span class="keyword">new</span> JFutureListener&lt;JChannel&gt;() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationSuccess</span><span class="params">(JChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    logger.debug(<span class="string">"Service error message sent out: &#123;&#125;."</span>, channel);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationFailure</span><span class="params">(JChannel channel, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">                        logger.warn(<span class="string">"Service error message sent failed: &#123;&#125;, &#123;&#125;."</span>, channel, stackTrace(cause));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>无非就是将异常对象写出去，当然也不一定是异常对象，也有可能是正常对象，管他呢，反正都是对象，客户端能够通过status自行去判断到底是什么类型。这样子，客户端调用一个rpc方法就像调用本地方法一样，也可以打印正常的异常栈信息，但是只能知道发生了什么异常，没办法去定位到哪一行有问题，这是很尴尬的。当然实际生成中这和你调用方关系不大，只需要遵循一个原则：谁写的bug谁去改。轻松甩锅。</p>
<p>终于，provider的核心基本上写完了，还有很多细节需要慢慢地理一遍，毕竟涉及到很多知识盲区，需要时间慢慢消化。写到这里我才发现还有一个比较关键的点没有涉及到，那就是服务的发布。接下来的一篇文章会简单概述provider是怎么“发布”出去的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中讲到了provider中针对consumer的请求消息封装&lt;code&gt;MessageTask&lt;/code&gt;的部分细节。留下了最核心的处理消息的细节&lt;code&gt;process&lt;/code&gt;方法没有说。&lt;/p&gt;
&lt;p&gt;在继续对所谓的核心逻辑梳理之前，先整体的捋一捋
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(三)</title>
    <link href="http://www.wei-dong.top/2018/08/21/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%B8%89)/"/>
    <id>http://www.wei-dong.top/2018/08/21/一起学RPC(三)/</id>
    <published>2018-08-21T08:17:23.000Z</published>
    <updated>2018-08-21T08:24:45.776Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中讲到jupiter的传输模块transport中的编解码器的实现。对server来言，编解码器扮演着一头一尾的门卫角色，保证进来的人是干净的，也得保证出去的人也是干净的。当然这么比喻很不恰当，但是也想不到别的比喻了。</p>
<p>编解码器固然重要，但是没有核心的业务处理器也没多大意义。本文的重点就是核心处理器：<code>AcceptorHandler</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ChannelHandler</span>.Sharable</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptorHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> ProviderProcessor processor;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="function"><span class="keyword">public</span> ProviderProcessor <span class="title">processor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> processor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processor</span><span class="params">(ProviderProcessor processor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.processor = processor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现一个handler很容易，直接继承<code>ChannelInboundHandlerAdapter</code>就行了。当然这是针对server来说的。根据类名来看，正常情况下首先会联想到肯定会有个与之对应的。针对server来说，要处理的就是入站数据，使用inbound就行了。如果有更加复杂的逻辑处理，可以去看看官方文档中其他的派生类。同时，这个实例也是能够被共享的，道理也很简单：没有状态。也许你会问：这里分明是有成员变量的呀。但是，这个成员变量是不会被改变的。如果发生了变化，这个程序设计上就有问题。理论上是绝对不允许改变的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       Channel ch = ctx.channel();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JRequestPayload) &#123;</div><div class="line">           JChannel jChannel = NettyChannel.attachChannel(ch);</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               processor.handleRequest(jChannel, (JRequestPayload) msg);</div><div class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">               processor.handleException(jChannel, (JRequestPayload) msg, Status.SERVER_ERROR, t);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unexpected message type received: &#123;&#125;, channel: &#123;&#125;."</span>, msg.getClass(), ch);</div><div class="line"></div><div class="line">           ReferenceCountUtil.release(msg);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="keyword">int</span> count = channelCounter.incrementAndGet();</div><div class="line"></div><div class="line">       logger.info(<span class="string">"Connects with &#123;&#125; as the &#123;&#125;th channel."</span>, ctx.channel(), count);</div><div class="line"></div><div class="line">       <span class="keyword">super</span>.channelActive(ctx);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="keyword">int</span> count = channelCounter.getAndDecrement();</div><div class="line"></div><div class="line">       logger.warn(<span class="string">"Disconnects with &#123;&#125; as the &#123;&#125;th channel."</span>, ctx.channel(), count);</div><div class="line"></div><div class="line">       <span class="keyword">super</span>.channelInactive(ctx);</div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       Channel ch = ctx.channel();</div><div class="line">       ChannelConfig config = ch.config();</div><div class="line"></div><div class="line">       <span class="comment">// 高水位线: ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK</span></div><div class="line">       <span class="comment">// 低水位线: ChannelOption.WRITE_BUFFER_LOW_WATER_MARK</span></div><div class="line">       <span class="keyword">if</span> (!ch.isWritable()) &#123;</div><div class="line">           <span class="comment">// 当前channel的缓冲区(OutboundBuffer)大小超过了WRITE_BUFFER_HIGH_WATER_MARK</span></div><div class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">               logger.warn(<span class="string">"&#123;&#125; is not writable, high water mask: &#123;&#125;, the number of flushed entries that are not written yet: &#123;&#125;."</span>,</div><div class="line">                       ch, config.getWriteBufferHighWaterMark(), ch.unsafe().outboundBuffer().size());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           config.setAutoRead(<span class="keyword">false</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// 曾经高于高水位线的OutboundBuffer现在已经低于WRITE_BUFFER_LOW_WATER_MARK了</span></div><div class="line">           <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">               logger.warn(<span class="string">"&#123;&#125; is writable(rehabilitate), low water mask: &#123;&#125;, the number of flushed entries that are not written yet: &#123;&#125;."</span>,</div><div class="line">                       ch, config.getWriteBufferLowWaterMark(), ch.unsafe().outboundBuffer().size());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           config.setAutoRead(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>AcceptorHandler</code>重写了几个方法。注意，重写<code>channelRead()</code>方法的时候记得调用<code>ReferenceCountUtil.release(msg)</code>。</p>
<p>其中最核心的逻辑在<code>channelRead()</code>中处理。无非就是将解码器中反序列化后的对象进行处理罢了。当然这里接受的仅仅是<code>JRequestPayload</code>类型。然后将Netty的原生<code>Channel</code>转化为自定义的<code>JChannel</code>类型。这样做的目的是为了将api统一，方便接入其他网络库实现。也就说如果要换别的网络框架如mina，不需要去改动我业务的代码，只需针对别的网络库的api进行编码即可。然后使用<code>ProviderProcessor</code>来处理具体的业务逻辑。这个接口中提供了两个操作：<code>handleRequest</code>和 <code>handleException</code>.因此具体的业务逻辑处理全部都传递给<code>ProviderProcessor</code>实现了。</p>
<p>而<code>channelWritabilityChanged</code>方法在可写状态发生变化的时候会被调用。可以通过<code>Channel#isWritable()</code>方法来获取状态。而这里对其重写是为了判断OutboundBuffer的大小有没有超过高水位线，这里的水位线是在<code>ChannelConfig</code>中设置的，server初始化的时候。超过高水位线就不允许自动去读数据了。这里有一点疑惑，不清楚为什么需要调用<code>config.setAutoRead(false)</code>。一个比较模糊的概念是Netty的写动作并不是直接向socket中写，而是写到Netty中的缓冲区中，这个缓冲区叫做<code>ChannelOutboundBuffer</code>，而这个buffer的实现是使用的无界链表，如果对方的接受太慢，就会导致这个链表无限大，最坏情况会导致OOM。因此提供一种机制：设置水位线。如果超过水位线就让用户来自己决定怎么处理，具体做法就是调用<code>channelWritabilityChanged</code>方法。这里的这个方法将自动读关闭了，这里面大有玄机。其实是利用了TCP的滑动窗口来控制的。</p>
<blockquote>
<p>比如咱俩喝酒, 你喝完一杯我就立刻给你满上, 最终你喝不动了 ,<br>不再举起杯子…. 你的杯子一直是满的, 我也没法继续给你倒酒</p>
</blockquote>
<p>这个栗子很形象地解释了滑动窗口。结合这个<a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html" target="_blank" rel="external">动画</a>更直观。</p>
<p><a href="http://www.cnblogs.com/rainy-shurun/p/5213086.html" target="_blank" rel="external">这里</a>有一篇文章值得参考。</p>
<p><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/water-2018-08-06-10-52-13.jpg?raw=true" alt="image"></p>
<p>接下来要讨论的是这个<code>processor</code>到底是怎么处理消息的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(DefaultProviderProcessor.class);</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CloseableExecutor executor;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DefaultProviderProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>(ProviderExecutors.executor());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DefaultProviderProcessor</span><span class="params">(CloseableExecutor executor)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.executor = executor;</div><div class="line">   &#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(JChannel channel, JRequestPayload requestPayload)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       MessageTask task = <span class="keyword">new</span> MessageTask(<span class="keyword">this</span>, channel, <span class="keyword">new</span> JRequest(requestPayload));</div><div class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</div><div class="line">           task.run();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           executor.execute(task);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实不难想到，<code>handleRequest</code>方法中将接受到的数据做了一层封装，然后丢给线程池去处理。在Netty中，业务处理逻辑绝对不能放在IO线程中执行。IO线程只负责读取/发送数据，不能进行业务处理。这是因为如果业务逻辑中有耗时的操作就会将IO线程阻塞住，这样正常的请求也就被阻塞了，影响应用的性能。而这里的线程池也被自定义了。</p>
<p><code>CloseableExecutor</code>是一个接口类型，正真的实现类是通过SPI机制由工厂创建出来的。关于SPI机制这里不会展开，将单独去整理一篇文章来说明。这种机制在很多框架中都有体现。</p>
<p>而包装类<code>MessageTask</code>的实现就很关键了。既然这个对象能放到线程池中，那么一定是一个<code>Runnable</code>或者<code>Callable</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// stack copy</span></div><div class="line">       <span class="keyword">final</span> DefaultProviderProcessor _processor = processor;</div><div class="line">       <span class="keyword">final</span> JRequest _request = request;</div><div class="line"></div><div class="line">       <span class="comment">// 全局流量控制</span></div><div class="line">       ControlResult ctrl = _processor.flowControl(_request);</div><div class="line">       <span class="keyword">if</span> (!ctrl.isAllowed()) &#123;</div><div class="line">           rejected(Status.APP_FLOW_CONTROL, <span class="keyword">new</span> JupiterFlowControlException(String.valueOf(ctrl)));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       MessageWrapper msg;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           JRequestPayload _requestPayload = _request.payload();</div><div class="line"></div><div class="line">           <span class="keyword">byte</span> s_code = _requestPayload.serializerCode();</div><div class="line">           Serializer serializer = SerializerFactory.getSerializer(s_code);</div><div class="line"></div><div class="line">           <span class="comment">// 在业务线程中反序列化, 减轻IO线程负担</span></div><div class="line">           <span class="keyword">if</span> (CodecConfig.isCodecLowCopy()) &#123;</div><div class="line">               InputBuf inputBuf = _requestPayload.inputBuf();</div><div class="line">               msg = serializer.readObject(inputBuf, MessageWrapper.class);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">byte</span>[] bytes = _requestPayload.bytes();</div><div class="line">               msg = serializer.readObject(bytes, MessageWrapper.class);</div><div class="line">           &#125;</div><div class="line">           _requestPayload.clear();</div><div class="line"></div><div class="line">           _request.message(msg);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">           rejected(Status.BAD_REQUEST, <span class="keyword">new</span> JupiterBadRequestException(<span class="string">"reading request failed"</span>, t));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 查找服务</span></div><div class="line">       <span class="keyword">final</span> ServiceWrapper service = _processor.lookupService(msg.getMetadata());</div><div class="line">       <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">           rejected(Status.SERVICE_NOT_FOUND, <span class="keyword">new</span> JupiterServiceNotFoundException(String.valueOf(msg)));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// provider私有流量控制</span></div><div class="line">       FlowController&lt;JRequest&gt; childController = service.getFlowController();</div><div class="line">       <span class="keyword">if</span> (childController != <span class="keyword">null</span>) &#123;</div><div class="line">           ctrl = childController.flowControl(_request);</div><div class="line">           <span class="keyword">if</span> (!ctrl.isAllowed()) &#123;</div><div class="line">               rejected(Status.PROVIDER_FLOW_CONTROL, <span class="keyword">new</span> JupiterFlowControlException(String.valueOf(ctrl)));</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// processing</span></div><div class="line">       Executor childExecutor = service.getExecutor();</div><div class="line">       <span class="keyword">if</span> (childExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">           process(service);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">// provider私有线程池执行</span></div><div class="line">           childExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   process(service);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这段代码十分简洁。首先将全局变量赋值为局部变量，我依稀记得在一个老外的代码中看到过，目的大概是为了节省性能。接下来就是全局流量控制，所谓的流量控制简单理解为防止请求太猛导致服务垮掉。有全局的就一定有局部的。而局部的控制是针对rpc中对外暴露某个服务。其粒度更小一点。然后就是反序列化了，这个过程在编解码器中也能完成，但是作者并没有这么做。目的也很简单，毕竟序列化是比较耗性能的，再说了，编解码器实际上也是在IO线程中处理的。这么做也是为了减轻IO线程负担。紧接着就是将序列化后的对象中的<code>ServiceMetadata</code>取出来 ，通过这个对象去本地容器中找<code>ServiceWrapper</code>。本地容器就是rpc的provider在发布一个服务到注册中心的时候本地也保存一个这个服务的相关信息。所谓的服务简单理解为就是一个service bean。而这个容器简单理解为就是一个map映射，<code>ServiceMetadata</code>为key，<code>ServiceWrapper</code>为value。找到这个<code>ServiceWrapper</code>后就很好办了，接下来就是调用这个service了。但是这个<code>ServiceWrapper</code>不仅仅是一个service，里面有很多额外的功能，比方可以有一个私有的线程池。如果有，那么在具体调用这个service的时候会使用这个私有的线程池。这种场景我反正没见过，但不排除有这种情况。如果没有那就很简单了，直接处理。这个处理过程也很容易想到，无非就是将要调用的service执行一遍，将结果序列化，再写出去。然而里面的代码实现可没有那么简单。</p>
<p>具体的处理逻辑全部都在<code>process</code>方法中。当然，在看具体实现之前很有必要对其中几个核类如<code>ServiceWrapper</code>和<code>MessageWrapper</code>进行解读。</p>
<p><code>MessageWrapper</code>可以简单理解为调用者发送的数据。包含要调用的对象，对象的方法，方法的参数。当然实际上比这些内容要复杂很多，比如链路追踪id等。有个最重要的参数<code>ServiceMetadata</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMetadata</span> <span class="keyword">extends</span> <span class="title">Directory</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8908295634641380163L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String group;               <span class="comment">// 服务组别</span></div><div class="line">    <span class="keyword">private</span> String serviceProviderName; <span class="comment">// 服务名称</span></div><div class="line">    <span class="keyword">private</span> String version;             <span class="comment">// 服务版本号</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Directory</code>是一个抽象类。这个命名也很容易理解，顾名思义Directory是目录的意思。对于某个服务来说，单纯的知道服务名就足矣完成调用。但是在复杂的场景下，有成百上千个服务，要做到准确调用就得对其进行分类了。而且有时候还有同一个服务版本也不一样的情形，因此版本号也得作为这个目录中的某个层级。为什么成为metadata呢？这个属性在<code>ServiceWrapper</code>对象中也有。可以猜到了，一定是一一对应起来的。通俗解释来说<code>ServiceWrapper</code>是属于服务端的。也就是说provider发布本地服务到注册中心的同时，仅仅是将元数据发出去了，注册中心有了还不能完事，自己本地得确实存在呀，不然consumer从注册中心中拿到服务元数据了去provider里找不到这个服务，这非得骂娘不可。而ServiceWrapper正是将需要暴露出去的服务在本地存起来。仅此而已。其中最重要的属性就是服务对象<code>serviceProvider</code>了，对于rpc来说，consumer知道的仅仅是接口，正真去干活的还是实现类。而其余的花里胡哨的东西还是有点用的，得分场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceWrapper</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6690575889849847348L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 服务元数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceMetadata metadata;</div><div class="line">    <span class="comment">// 服务对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object serviceProvider;</div><div class="line">    <span class="comment">// 服务拦截器</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProviderInterceptor[] interceptors;</div><div class="line">    <span class="comment">// key:     method name</span></div><div class="line">    <span class="comment">// value:   pair.first:  方法参数类型(用于根据JLS规则实现方法调用的静态分派)</span></div><div class="line">    <span class="comment">//          pair.second: 方法显式声明抛出的异常类型</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;Pair&lt;Class&lt;?&gt;[], Class&lt;?&gt;[]&gt;&gt;&gt; extensions;</div><div class="line"></div><div class="line">    <span class="comment">// 权重 hashCode() 与 equals() 不把weight计算在内</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = JConstants.DEFAULT_WEIGHT;</div><div class="line">    <span class="comment">// provider私有线程池</span></div><div class="line">    <span class="keyword">private</span> Executor executor;</div><div class="line">    <span class="comment">// provider私有流量控制器</span></div><div class="line">    <span class="keyword">private</span> FlowController&lt;JRequest&gt; flowController;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>而具体的核心处理逻辑<code>process</code>以后再慢慢看。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中讲到jupiter的传输模块transport中的编解码器的实现。对server来言，编解码器扮演着一头一尾的门卫角色，保证进来的人是干净的，也得保证出去的人也是干净的。当然这么比喻很不恰当，但是也想不到别的比喻了。&lt;/p&gt;
&lt;p&gt;编解码器固然重要，但是没有核
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>小白探索大前端--使用vue实现简单轮播图</title>
    <link href="http://www.wei-dong.top/2018/08/15/%E5%B0%8F%E7%99%BD%E6%8E%A2%E7%B4%A2%E5%A4%A7%E5%89%8D%E7%AB%AF--%E4%BD%BF%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <id>http://www.wei-dong.top/2018/08/15/小白探索大前端--使用vue实现简单轮播图/</id>
    <published>2018-08-15T09:17:23.000Z</published>
    <updated>2018-08-15T10:04:51.119Z</updated>
    
    <content type="html"><![CDATA[<p>最近看完了《Vue实战》这本书，这也是我第一次完整的看完的一本关于前端的书籍（现在还在看的是《CSS世界》，有点想放弃了）。照着书中的demo都写了一遍，虽然很多栗子非常简单，但是值得学习的地方还是挺多的。当然也不得不吐槽很多用法都有点过时，尤其是关于webpack的配置。不过现在的前端发展很快，各种工具版本不断更新，代码过时也是能够理解的。对于学习者来说当然得学习最新的东西。</p>
<p>这篇文章主要是用来记录在自己实现一个【知乎日报移动版】的过程中遇到的一个坑，说坑也算不上，只能叫做坎坷之路吧。因为书中给的实战demo是一个pc版的，自己跟着写了一遍，觉得没有什么难度。然后在github上找了一下，发现用知乎日报来练手的项目很多，原因也很简单–api是现成的。于是我也蠢蠢欲动，决定使用vue亲自撸一个【知乎daily】。</p>
<p>虽然gayhub很多现成的项目，但是我并不打算去抄一遍。我在手机上下载了一个知乎日报的APP，按照不同功能截屏来一一实现。没办法，这就是工(zhuang)匠(bi)情(xin)怀(tai).</p>
<p>开发过程中，整体的框架功能上基本没什么问题，该自己写组件就自己写，绝没有偷懒。也遇到很多问题，比如开发环境下的接口代理、知乎图片的同源策略等。这些问题肯定难不倒我，都不值一提。让我觉得难受的还是首页的轮播图实现。这个问题困扰了我2天（准确时间是一天半，还有半天在工作：逃）。</p>
<p>遇到这个功能的时候第一反应是使用一个开源库，分分钟就搞定了。但是经过10s的思想斗争，工匠情怀终于战胜了理智，下定决心打算自己手动实现。然而，带来的结果就是卡顿了半天，没任何进展。网上也有很多教程，也是很简单的，可以说是基础操作了。可惜我被一篇文章带偏了，走了一点弯路。</p>
<p>这篇文章的思路很常规，很有道理。首先将一个框框用来装你要显示的图片，仅仅只能显示这个框框，而图片呢就放后面排排坐，通过定时器去移动图片，就像一格格的胶卷一样，轮到谁谁就被看到了。</p>
<p>我一开始就是按照这种思路去整，结果怎么整都实现不了（在移动端）。在一筹莫展之际，发现了一个更加屌的思路。这个思路和之前的不一样，区别在于后面的图片不是排排坐好，而是叠加到一块去。下面通过代码去一探究竟。</p>
<p>首先得整一个窗口，简单来说就是用来显示一张图片的容器，它的宽度对移动端而言就是屏幕宽度。他得有一个非常重要的属性<code>overflow：hidden</code>，当子元素尺寸超过其父亲的大小多余内容就会被隐藏。这里用<code>ul</code>标签来装图片，其实使用<code>div</code>也是没问题的。元素<code>li</code>的<code>position</code>属性得设置为<code>absolute</code>.因为使用这个属性就能脱离文档流，也就不会“排排坐”了，而是叠加到一起了，当然，最后的肯定叠在最上面，前提是没有显示的设置<code>z-index</code>属性。还有很重要的一点，子元素定位设置为<code>absolute</code>父元素记得也设置一下定位属性，因为子元素的相对位置是按照第一个祖先元素不为<code>static</code>的元素来的，不然会粗大事。 html代码结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"window"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">ref</span>=<span class="string">"imagesWrapper"</span>&gt;</span></div><div class="line">       </div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(e,i) in imgs"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"e.image"</span> <span class="attr">:alt</span>=<span class="string">"e.title"</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"desc"</span>&gt;</span>&#123;&#123;e.title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">     <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"point-wrap"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">:class</span>=<span class="string">"&#123;active:i==currentIndex&#125;"</span> <span class="attr">v-for</span>=<span class="string">"(e,i) in imgs"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">list-style-type</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.container</span> <span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(100%);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.window</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个小技巧，在静态样式中并没有将图片直接展示出来，而是将所有图片向右偏移一个窗口宽度。这是有玄机的。</p>
<p>说了这么多，还没谈到vue的部分。在<code>container</code>容器中有一个<code>ref</code>标签。这是在vue中用来获取dom元素的。也许在vue中操作dom是不被推荐的，但是对于这种动态生成的<code>li</code>元素我找不到怎么去动态绑定其样式。因此采用了这种比较low的办法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">init() &#123;</div><div class="line">     <span class="keyword">let</span> wrappers = <span class="keyword">this</span>.$refs.imagesWrapper;</div><div class="line">     <span class="keyword">let</span> children = wrappers.children;</div><div class="line">     <span class="keyword">let</span> total = <span class="keyword">this</span>.imgs.length;</div><div class="line">     <span class="comment">// 纯js操作 只需要先将三张图片位置确定好</span></div><div class="line">     <span class="comment">// 最左边按道理说是没有图片的 但是为了无限滚动效果 这里将其置为最后一张</span></div><div class="line">     <span class="keyword">let</span> left = total - <span class="number">1</span>;</div><div class="line">     <span class="keyword">let</span> center = <span class="number">0</span>;</div><div class="line">     <span class="keyword">let</span> right = <span class="number">1</span>;</div><div class="line"></div><div class="line">     <span class="comment">// 初始化的时候将li左移动了一个屏幕宽度，就是为了防止叠加的元素挡住要显示的图</span></div><div class="line">     <span class="comment">// 现在第一张显示的图片实际是最后一张 3张轮播起来就行了 没必要对每个图片进行位置计算</span></div><div class="line">     <span class="comment">// left处于最左边的位置 不显示</span></div><div class="line">     children[left].style.transform = <span class="string">"translateX("</span> + -<span class="keyword">this</span>.distance + <span class="string">"px)"</span>;</div><div class="line">     <span class="comment">// center处于中间位置 显示</span></div><div class="line">     children[center].style.transform = <span class="string">"translateX("</span> + <span class="number">0</span> + <span class="string">"px)"</span>;</div><div class="line">     <span class="comment">// right处于右边 不显示</span></div><div class="line">     children[right].style.transform = <span class="string">"translateX("</span> + <span class="keyword">this</span>.distance + <span class="string">"px)"</span>;</div><div class="line">     <span class="keyword">this</span>.sliderItem = children;</div><div class="line">     <span class="comment">// this.play();</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>首先就是初始化显示的内容，之前在静态css样式中将图片移动到右边看不到的地方去了，现在就得手动操作让其可见。刚开始我以为直接将这些图片全部“铺开”，然后滚动，后来发现这么做很笨。直接操作三张就行了！为了实现无限滚动的效果，第一张的逻辑上的前一张是最后一张，因此将第一张的“上一张”给放到屏幕左边，下一张放到屏幕右边，要显示的也就是第一张（下标为0）归位到窗口，这和之前设置的全局的样式<code>transform: translateX(100%)</code>对应起来了。</p>
<p>如此以来，初始化的三张图片就定位好了，逻辑上也是没什么问题的。其余的改不显示还是显示不了，也不会参与移动。下面看看怎么“滚”。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">next() &#123;</div><div class="line">     this.currentIndex++;</div><div class="line">     // 边界判断</div><div class="line">     if (this.currentIndex &gt; this.imgs.length - 1) &#123;</div><div class="line">       this.currentIndex = 0;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     // center 为显示的图片</div><div class="line">     let center = this.currentIndex;</div><div class="line">     // 左边的 如果为负数 就取最后一张图片下标</div><div class="line">     let left = center - 1 &lt; 0 ? this.imgs.length - 1 : center - 1;</div><div class="line">     // 右边的 如果超过了最大图片数量 取第一张图片下标</div><div class="line">     let right = center + 1 == this.imgs.length ? 0 : center + 1;</div><div class="line"></div><div class="line">     let children = this.sliderItem;</div><div class="line">     // 给元素添加过渡</div><div class="line">     children[center].style.transition = "transform .5s";</div><div class="line">     children[left].style.transition = "transform .5s";</div><div class="line">     // 右边的图片是替补图片，不需要走过渡</div><div class="line">     children[right].style.transition = "none";</div><div class="line">     // 3张图片同时移动</div><div class="line">     children[left].style.transform = "translateX(" + -this.distance + "px)";</div><div class="line">     children[center].style.transform = "translateX(0px)";</div><div class="line">     children[right].style.transform = "translateX(" + this.distance + "px)";</div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p><code>currentIndex</code>为全局变量，指当前显示的图片下标，每次调用<code>next</code>会子增，到上限后会回归到0，这些都是很常规的操作。接下来就是计算上一张，下一张图片的下标，也是很容易理解，无非多了一点判断，在最后一张显示的时候下一张的下标得置为0，上一张也是同理，不然就回”空指针”了。接下来就是针对这三张图片改变样式，原则就是移动到哪个下标就显示哪个图片，上一张就移到左边，下一站移动到右边，顺便给加个动画效果。如此而已！</p>
<p>最后就是自动播放的逻辑，也是非常简单，一个定时器就搞定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">play() &#123;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.timer) &#123;</div><div class="line">       <span class="built_in">window</span>.clearInterval(<span class="keyword">this</span>.timer);</div><div class="line">       <span class="keyword">this</span>.timer = <span class="literal">null</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">this</span>.timer = <span class="built_in">window</span>.setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">       <span class="keyword">this</span>.next();</div><div class="line">     &#125;, <span class="keyword">this</span>.interval);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后在钩子函数中将这方法加上去就完事了。一个自制的轮播组件就写完了。简陋但是简单。这里有一个不太重要的细节，针对窗口变化的时候得动态改变偏移量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 窗口变化 重新初始化</span></div><div class="line">   windowChange() &#123;</div><div class="line">     <span class="keyword">const</span> that = <span class="keyword">this</span>;</div><div class="line">     <span class="built_in">window</span>.onresize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">       <span class="keyword">return</span> <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</div><div class="line">         <span class="built_in">window</span>.screenWidth = <span class="built_in">document</span>.body.clientWidth;</div><div class="line">         that.distance = <span class="built_in">window</span>.screenWidth;</div><div class="line">         <span class="keyword">this</span>.init();</div><div class="line">       &#125;)();</div><div class="line">     &#125;;</div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p>这样在pc端下也能正常“滚”动了。</p>
<p>最后，做一下小小的总结。这个组件虽然简单，但是也花了一定时间，毕竟踩坑的路是不能跳过的。其中花了很多时间纠结布局和样式，很是难受，都怪我没有把《CSS世界》看完。虽然简单，但是功能也很局限，比如没有实现手动去滑动。APP上是有这个功能的，那是因为我还没学会怎么在vue下使用touch事件（实际上是懒）。比如没有代码优化等等，总不能要求一个新手来造一个完美的轮子吧（给自己一点上升的空间咯）。造轮子不是目的，理解其中的所以然才是目的，现成的库有很多，完成功能也很容易，但是不能仅仅满足于此，我觉得作为手艺人得有一种格(xi)物(huan)致(zhuang)知(B)的精神。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3117395-0a23d3aadd128f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/662" alt="image"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://web.jobbole.com/94701/" target="_blank" rel="external">CSS深入理解之relative定位</a></p>
<p><a href="https://segmentfault.com/a/1190000011013572#articleHeader2" target="_blank" rel="external">几种原生js轮播图</a></p>
<p><a href="https://github.com/Mr-Vincent/zhihu-daily-app" target="_blank" rel="external">源码地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看完了《Vue实战》这本书，这也是我第一次完整的看完的一本关于前端的书籍（现在还在看的是《CSS世界》，有点想放弃了）。照着书中的demo都写了一遍，虽然很多栗子非常简单，但是值得学习的地方还是挺多的。当然也不得不吐槽很多用法都有点过时，尤其是关于webpack的配置。
    
    </summary>
    
      <category term="前端" scheme="http://www.wei-dong.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="VUE" scheme="http://www.wei-dong.top/tags/VUE/"/>
    
      <category term="Javascript" scheme="http://www.wei-dong.top/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(二)</title>
    <link href="http://www.wei-dong.top/2018/08/09/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%BA%8C)/"/>
    <id>http://www.wei-dong.top/2018/08/09/一起学RPC(二)/</id>
    <published>2018-08-09T10:17:23.000Z</published>
    <updated>2018-08-09T10:02:11.780Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中介绍到关于jupiter的底层通信模块transport的部分实现。仅仅只是讨论了整个server的初始化以及启动流程。很多细枝末节其实还没有涉及到，例如tcp参数设置，超时机制，编解码器等等实现细节。这些东西将会逐步被消化分解。而本文的主题是jupiter的业务编解码器的实现。</p>
<p>在jupiter中有一张图，这张图清晰地描述了整个server的数据流向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">* *********************************************************************</div><div class="line"> *            I/O Request                       I/O Response</div><div class="line"> *                 │                                 △</div><div class="line"> *                                                   │</div><div class="line"> *                 │</div><div class="line"> * ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─ ─ ─</div><div class="line"> * │               │                                                  │</div><div class="line"> *                                                   │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐       ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐   │</div><div class="line"> *     IdleStateChecker#inBound          IdleStateChecker#outBound</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘       └ ─ ─ ─ ─ ─ ─△─ ─ ─ ─ ─ ─ ┘   │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐                                     │</div><div class="line"> *     AcceptorIdleStateTrigger                      │</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                                     │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐       ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐   │</div><div class="line"> *          ProtocolDecoder                   ProtocolEncoder</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘       └ ─ ─ ─ ─ ─ ─△─ ─ ─ ─ ─ ─ ┘   │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                                                                  │</div><div class="line"> *                 │                                 │</div><div class="line"> * │  ┌ ─ ─ ─ ─ ─ ─▽─ ─ ─ ─ ─ ─ ┐                                     │</div><div class="line"> *          AcceptorHandler                          │</div><div class="line"> * │  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                                     │</div><div class="line"> *                 │                                 │</div><div class="line"> * │                    ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐                     │</div><div class="line"> *                 ▽                                 │</div><div class="line"> * │               ─ ─ ▷│       Processor       ├ ─ ─▷                │</div><div class="line"> *</div><div class="line"> * │                    └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘                     │</div><div class="line"> * ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</div><div class="line"> *</div></pre></td></tr></table></figure>
<p>实际上这个图仅仅是针对Netty api的描述，和rpc没有太多直接的关系。如果换做别的通信框架这个图就没有什么意义了。鉴于Netty依旧是目前Java网络开发中最流行的框架，拿出来讨论也是很有意义的。</p>
<p>这个图中有几个核心的概念：decode、encode、IdleStateChecker和handler。在编写一个网络应用的时候首先必须定义的是通信协议。比如上传下载文件使用ftp，即时聊天使用xmpp，浏览网页使用http…当然自己写一个rpc框架也得定义自己的通信协议。为什么要定义协议这个问题对于开发的老手来说没有必要去解释，不过我还是得啰嗦一下。在网络应用程序中，所有的数据在网络上的传输都是二进制格式，也就是0101010这样的机器码。当然也有人会反驳：不是有基于字符的数据吗？我的理解是在宏观上来说确实存在，那是因为上层的协议已经将代表字符串的01010解码成了可读的字符串。但是在底层的传输，也就是在物理层比如网线、电磁波中的传输依旧还是0101。当然用0101来比喻也是不恰当，更准确的说法应该是电平信号。而协议的作用是将通信双方的内容进行规范。就像以前写书信的时候，开头得有称谓，然后写正文，最后是落款这样一种格式。别人收到后就知道，嗯，这是一封信而不是一篇散文或者自传。当然这个比喻不是很恰当，但是就这样吧，不想废话了。</p>
<p>既然定义了协议，那么就得去处理协议。Netty中提供了很多内置的协议解析的类。通常被称作编解码器。顾名思义也就是将二进制转化为我们想要的数据结构，这样方便统一处理。这张图中的具体体现就是先解码，然后再处理，最后将处理结果编码后发送出去。编解码器将是本文讨论的重点。然而还有别的几个组件如空闲链路检查<code>IdleStateChecker</code>和业务处理<code>AcceptorHandler</code>组件，这些放在后面讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">boot.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                ch.pipeline().addLast(</div><div class="line">                        <span class="keyword">new</span> IdleStateChecker(timer, JConstants.READER_IDLE_TIME_SECONDS, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                        idleStateTrigger,</div><div class="line">                        CodecConfig.isCodecLowCopy() ? <span class="keyword">new</span> LowCopyProtocolDecoder() : <span class="keyword">new</span> ProtocolDecoder(),</div><div class="line">                        encoder,</div><div class="line">                        handler);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这段代码就是初始化编解码器等组件。可以看到handler作为业务核心处理器放在了最后。这是Netty的机制所决定的。关于Netty的一些设计可以看看<a href="http://ifeve.com/netty-in-action-1/" target="_blank" rel="external">这本书</a>作为基础入门。</p>
<p>看到解码器和编码器还有点不一样。解码器是直接new的方式添加到pipeline中的，而编码器是new好了再添加到pipeline中。其实具体差别就在于解码器不能共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">ProtocolDecoder</span>.<span class="title">State</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@ChannelHandler</span>.Sharable</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">PayloadHolder</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所谓的能共享，就是意味着每次都能使用这个编码器而不需要每次用就得实例化出来。而解码器不能被共享也是有原因的。因为解码器解码的数据全部来自于网络请求，网络通常而言是不可靠的，不能保证每次都能发送完整的数据包也有可能需要的数据还没收到。那么如何保证接受到的数据是完整的呢？实际上是没法保证，只能够“假装”是完整的。所以decoder是继承自<code>ReplayingDecoder</code>。这个类的作用简单通俗来理解就是如果网络上的数据还没发完，我就继续接收，直到收完为止。具体的工作原理可以参考api文档或者源码，这里不再过多探讨。为什么继承这个类后就不能共享呢？这个类是个泛型，参数是一个state的字眼。看到这里大概可以联想到这个类肯定和状态有关系。这样就很容易理解了，有状态的对象通常不能被共享。想象一下，在多线程环境下，线程A将这个状态改为1线程B这时候拿到执行权又把这个状态改为2，然后线程A又要使用这个状态变量了，这时候就不是他刚开始改变的状态了。如此一来，全部乱套了。这些都是并发基础相关的内容，有兴趣可以去谷歌。这里不再过多描述。而encode则没有状态变量，需要编码的数据一定是确定的，不存在解码器中数据不完整的情况。因此使用共享实例没什么问题。具体可以看看其中的代码实现：<a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-transport/jupiter-transport-netty/src/main/java/org/jupiter/transport/netty/handler/ProtocolDecoder.java" target="_blank" rel="external">ProtocolDecoder</a>  <a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-transport/jupiter-transport-netty/src/main/java/org/jupiter/transport/netty/handler/ProtocolEncoder.java" target="_blank" rel="external">ProtocolEncoder</a></p>
<p>解释完这些鸡毛蒜皮的细节，接下来开始分析一下这个协议的定义以及解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">* **************************************************************************************************</div><div class="line">*                                          Protocol</div><div class="line">*  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</div><div class="line">*       2   │   1   │    1   │     8     │      4      │</div><div class="line">*  ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤</div><div class="line">*           │       │        │           │             │</div><div class="line">*  │  MAGIC   Sign    Status   Invoke Id    Body Size                    Body Content              │</div><div class="line">*           │       │        │           │             │</div><div class="line">*  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</div><div class="line">*</div><div class="line">* 消息头16个字节定长</div><div class="line">* = 2 // magic = (short) 0xbabe</div><div class="line">* + 1 // 消息标志位, 低地址4位用来表示消息类型request/response/heartbeat等, 高地址4位用来表示序列化类型</div><div class="line">* + 1 // 状态位, 设置请求响应状态</div><div class="line">* + 8 // 消息 id, long 类型, 未来jupiter可能将id限制在48位, 留出高地址的16位作为扩展字段</div><div class="line">* + 4 // 消息体 body 长度, int 类型</div><div class="line">*</div></pre></td></tr></table></figure>
<p>作者在代码中将协议格式完全标注出来了:16字节的消息头+消息体。消息头中的MAGIC字段仅仅是为了标识这个数据包是属于jupiter。就像java class文件以<code>0xCAFEBABE</code>开头一样。没有实际的意义，仅仅做个标识而已。其他的字段也就没什么可说的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_COMPOSITE_BUF = SystemPropertyUtil.getBoolean(<span class="string">"jupiter.io.decoder.composite.buf"</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProtocolDecoder</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(State.MAGIC);</div><div class="line">       <span class="keyword">if</span> (USE_COMPOSITE_BUF) &#123;</div><div class="line">           setCumulator(COMPOSITE_CUMULATOR);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">enum</span> State &#123;</div><div class="line">       MAGIC,</div><div class="line">       SIGN,</div><div class="line">       STATUS,</div><div class="line">       ID,</div><div class="line">       BODY_SIZE,</div><div class="line">       BODY</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>解码器的构造函数中直接调用了父类的构造函数，将枚举类型<code>State</code>传入。这个枚举类型所代表的就是要解析协议数据中的位置（下标）。因此构造器中传入的当然是协议的第一个字段，也就表示从第一个位置开始解析。然后有一个布尔标识，这个变量从系统变量中获取，用来决定是否使用<code>COMPOSITE_CUMULATOR</code>。默认的CUMULATOR是<code>MERGE_CUMULATOR</code>.区别可能在性能上有点差距吧。具体差异得去研究源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> JProtocolHeader header = <span class="keyword">new</span> JProtocolHeader();</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (state()) &#123;</div><div class="line">            <span class="keyword">case</span> MAGIC:</div><div class="line">                checkMagic(in.readShort());         <span class="comment">// MAGIC</span></div><div class="line">                checkpoint(State.SIGN);</div><div class="line">            <span class="keyword">case</span> SIGN:</div><div class="line">                header.sign(in.readByte());         <span class="comment">// 消息标志位</span></div><div class="line">                checkpoint(State.STATUS);</div><div class="line">            <span class="keyword">case</span> STATUS:</div><div class="line">                header.status(in.readByte());       <span class="comment">// 状态位</span></div><div class="line">                checkpoint(State.ID);</div><div class="line">            <span class="keyword">case</span> ID:</div><div class="line">                header.id(in.readLong());           <span class="comment">// 消息id</span></div><div class="line">                checkpoint(State.BODY_SIZE);</div><div class="line">            <span class="keyword">case</span> BODY_SIZE:</div><div class="line">                header.bodySize(in.readInt());      <span class="comment">// 消息体长度</span></div><div class="line">                checkpoint(State.BODY);</div><div class="line">            <span class="keyword">case</span> BODY:</div><div class="line">                <span class="keyword">switch</span> (header.messageCode()) &#123;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.HEARTBEAT:</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.REQUEST: &#123;</div><div class="line">                        <span class="keyword">int</span> length = checkBodySize(header.bodySize());</div><div class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">                        in.readBytes(bytes);</div><div class="line"></div><div class="line">                        JRequestPayload request = <span class="keyword">new</span> JRequestPayload(header.id());</div><div class="line">                        request.timestamp(SystemClock.millisClock().now());</div><div class="line">                        request.bytes(header.serializerCode(), bytes);</div><div class="line"></div><div class="line">                        out.add(request);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">case</span> JProtocolHeader.RESPONSE: &#123;</div><div class="line">                        <span class="keyword">int</span> length = checkBodySize(header.bodySize());</div><div class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</div><div class="line">                        in.readBytes(bytes);</div><div class="line"></div><div class="line">                        JResponsePayload response = <span class="keyword">new</span> JResponsePayload(header.id());</div><div class="line">                        response.status(header.status());</div><div class="line">                        response.bytes(header.serializerCode(), bytes);</div><div class="line"></div><div class="line">                        out.add(response);</div><div class="line"></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">default</span>:</div><div class="line">                        <span class="keyword">throw</span> IoSignals.ILLEGAL_SIGN;</div><div class="line">                &#125;</div><div class="line">                checkpoint(State.MAGIC);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>正真的解析逻辑全部在<code>decode</code>方法中。这里的每个case并没有break，道理很简单，每解析一段数据后得接着继续往下解析，如果break掉了后面的数据不全都放弃解析了吗？每当解析到一个位置，都将这个位置上读取的数据放到<code>header</code>变量中，同时将接下来需要解析的位置记录下来（通过<code>checkpoint(...)</code>方法）。之所以要记录下来，万一某个位置解析出错，下次就不用从头再来了，直接上次出错的位置接着来就行了，也是为了提高性能。然而解析到body部分的时候，header里面内容都已经全部填充好了。接下来就是根据消息类型来处理body里的内容。如果是心跳包，那么什么都不做直接返回，因为body里肯定是没有数据的。如果是请求包(<code>REQUEST</code>类型)，先从header里读取这个body到底有多长，然后再去读这么长的数据，最后通过<code>JRequestPayload</code>对象将这个body数据封装起来，同时将消息id和序列化类型code也封装进去了。响应包类型逻辑与之类似。整个解码器解析逻辑就完成了。</p>
<p>与之对应的就是编码器了，编码器逻辑更简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, PayloadHolder msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JRequestPayload) &#123;</div><div class="line">            doEncodeRequest((JRequestPayload) msg, out);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> JResponsePayload) &#123;</div><div class="line">            doEncodeResponse((JResponsePayload) msg, out);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Reflects.simpleClassName(msg));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doEncodeRequest</span><span class="params">(JRequestPayload request, ByteBuf out)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> sign = JProtocolHeader.toSign(request.serializerCode(), JProtocolHeader.REQUEST);</div><div class="line">        <span class="keyword">long</span> invokeId = request.invokeId();</div><div class="line">        <span class="keyword">byte</span>[] bytes = request.bytes();</div><div class="line">        <span class="keyword">int</span> length = bytes.length;</div><div class="line"></div><div class="line">        out.writeShort(JProtocolHeader.MAGIC)</div><div class="line">                .writeByte(sign)</div><div class="line">                .writeByte(<span class="number">0x00</span>)</div><div class="line">                .writeLong(invokeId)</div><div class="line">                .writeInt(length)</div><div class="line">                .writeBytes(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doEncodeResponse</span><span class="params">(JResponsePayload response, ByteBuf out)</span> </span>&#123;</div><div class="line">        <span class="keyword">byte</span> sign = JProtocolHeader.toSign(response.serializerCode(), JProtocolHeader.RESPONSE);</div><div class="line">        <span class="keyword">byte</span> status = response.status();</div><div class="line">        <span class="keyword">long</span> invokeId = response.id();</div><div class="line">        <span class="keyword">byte</span>[] bytes = response.bytes();</div><div class="line">        <span class="keyword">int</span> length = bytes.length;</div><div class="line"></div><div class="line">        out.writeShort(JProtocolHeader.MAGIC)</div><div class="line">                .writeByte(sign)</div><div class="line">                .writeByte(status)</div><div class="line">                .writeLong(invokeId)</div><div class="line">                .writeInt(length)</div><div class="line">                .writeBytes(bytes);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>和解码器相反，编码器就是将对象中的数据按协议中的定义挨个写到buf中。</p>
<p>以上，jupiter中的消息编解码器的实现就全部整理完了。当然还有空闲链路检测部分，因此我决定暂时放弃这部分，太复杂了，等所有逻辑整理完毕后再接着填坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中介绍到关于jupiter的底层通信模块transport的部分实现。仅仅只是讨论了整个server的初始化以及启动流程。很多细枝末节其实还没有涉及到，例如tcp参数设置，超时机制，编解码器等等实现细节。这些东西将会逐步被消化分解。而本文的主题是jupiter的业务
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(一)</title>
    <link href="http://www.wei-dong.top/2018/08/08/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E4%B8%80)/"/>
    <id>http://www.wei-dong.top/2018/08/08/一起学RPC(一)/</id>
    <published>2018-08-08T08:17:23.000Z</published>
    <updated>2018-08-08T08:33:13.567Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中废话了很多“大概”不相关的东西。而这篇就要认认真真的开始讲干货了(也有可能是水货，谁知道呢)。</p>
<p>上一篇文章主要介绍了与rpc中间件相关的但联系不是很大的spring xml标签的自定义实现。可以说是没有太多核心的东西，全文中的关键字就是“抄”。没错，只要有官方文档，什么都能照着抄。实在不行，对着源码的实现也能抄一把。联系到目前的工作中，也是复制粘贴一把梭。不得不说现在的编码要求是越来越低了。</p>
<p>总所周知，rpc顾名思义是远程过程调用，所谓的远程就是不在一个机器上。因此机器与机器之间的可靠通信可以说是rpc的基础设施了。那么本文的重点就是深入剖析这个基础设施的具体实现（的其中一部分，其余的还没认真看）。</p>
<p>在jupiter中，对这些基础设施的设计可算是下了一番功夫的。至少我看明白花了一点时间的。在jupiter的代码组织中，将网络传输这一块单独整成一个模块。很多开源项目也是这样做的，算是中规中矩了。</p>
<p><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/structure-2018-08-01-15-55-21.jpg?raw=true" alt="image"></p>
<p>同时，为了以后的拓展，传输层还定义了一个高层次的抽象模块api。然后根据自己的喜好可以自由去切换传输层实现。这里默认只有基于Netty的实现。如果想添加Mina的实现也很容易，添加Mina依赖然后实现api中的接口就行了。</p>
<p>接下来就仔细探索一下基于Netty的服务端的实现细节。</p>
<h2 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h2><p>jupiter的服务端层次结构十分简单。继承关系也很清晰。这张图很清晰的描述了继承关系：<br><img src="https://github.com/Mr-Vincent/pic-bed/blob/master/images/acceptor-2018-08-01-15-50-40.jpg?raw=true" alt="image"></p>
<p>通过命名可以体现出来这些抽象类或接口的含义。我想写代码的最高境界就是能做到变量名能恰如其分的表达其功用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the transport protocol</div><div class="line">     */</div><div class="line">    <span class="function">Protocol <span class="title">protocol</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 传输层协议.</div><div class="line">     */</div><div class="line">    <span class="keyword">enum</span> Protocol &#123;</div><div class="line">        TCP,</div><div class="line">        DOMAIN  <span class="comment">// Unix domain socket</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最高层次的接口仅仅只定义了一个方法，返回到底使用的是什么协议。这里可选的只有TCP或者DOMAIN。关于tcp无需多言，但是这个unix domain socket就不是那么常见了。简单来讲就是用于机器内的通信，不是机器间的通信。具体使用场景我问了一下作者feng.jc，他回复了一个词：service mesh.然后就没有然后了。对此咱暂且不管。</p>
<p>接下来就是比较细化的一个接口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JAcceptor</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 绑定的地址</div><div class="line">     */</div><div class="line">    <span class="function">SocketAddress <span class="title">localAddress</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 绑定的端口.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">boundPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Acceptor options [parent, child].</div><div class="line">     */</div><div class="line">    <span class="function">JConfigGroup <span class="title">configGroup</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 返回rpc处理器 </div><div class="line">     */</div><div class="line">    <span class="function">ProviderProcessor <span class="title">processor</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置ProviderProcessor 也就是实际的业务逻辑全部由这个东西处理</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withProcessor</span><span class="params">(ProviderProcessor processor)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Start the server and wait until the server socket is closed.</div><div class="line">     * 默认调用start(true)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Start the server.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> sync)</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Shutdown the server gracefully.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdownGracefully</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个接口也很清晰简单。符合一般的思路。接下来就是这些接口的抽象实现。</p>
<h2 id="抽象实现"><a href="#抽象实现" class="headerlink" title="抽象实现"></a>抽象实现</h2><p>在走读抽象实现逻辑之前，有必要看看如果要直接启动这个transporter该怎么做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        JAcceptor acceptor = <span class="keyword">new</span> JNettyTcpAcceptor(<span class="number">9999</span>);</div><div class="line">        acceptor.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>不得不说是非常简单。但是背后的工作可谓是非常多。</p>
<p><code>JNettyTcpAcceptor</code>是最底层的实现类。在实例化的时候会传入参数端口号，这点无可厚非毫无争议。不传也是可以的，因为构造器有重载，会传入默认端口号18090。而实际上是去调用的父类的构造器。父类构造器的重载方法很多，就贴出一个全参数的重载实现,其余的请自行脑补。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyTcpAcceptor</span><span class="params">(SocketAddress localAddress, <span class="keyword">int</span> nBosses, <span class="keyword">int</span> nWorkers, <span class="keyword">boolean</span> isNative)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Protocol.TCP, localAddress, nBosses, nWorkers);</div><div class="line">        <span class="keyword">this</span>.isNative = isNative;</div><div class="line">        init();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然而恶心心的是这个构造器也去调用父类的构造函数。对于聪明的人来说这都不是事儿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyAcceptor</span><span class="params">(Protocol protocol, SocketAddress localAddress, <span class="keyword">int</span> nBosses, <span class="keyword">int</span> nWorkers)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.protocol = protocol;</div><div class="line">        <span class="keyword">this</span>.localAddress = localAddress;</div><div class="line">        <span class="keyword">this</span>.nBosses = nBosses;</div><div class="line">        <span class="keyword">this</span>.nWorkers = nWorkers;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>值得一提的仅仅只有后面两个参数。顾名思义代表的是boss的线程数和worker的线程数。如果对netty很熟悉这点就不需要解释太多。然后就是<code>init()</code>方法了。这个init方法的核心实现实际上是在顶层父类中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        ThreadFactory bossFactory = bossThreadFactory(<span class="string">"jupiter.acceptor.boss"</span>);</div><div class="line">        ThreadFactory workerFactory = workerThreadFactory(<span class="string">"jupiter.acceptor.worker"</span>);</div><div class="line">        boss = initEventLoopGroup(nBosses, bossFactory);</div><div class="line">        worker = initEventLoopGroup(nWorkers, workerFactory);</div><div class="line"></div><div class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap().group(boss, worker);</div><div class="line"></div><div class="line">        <span class="comment">// parent options</span></div><div class="line">        JConfig parent = configGroup().parent();</div><div class="line">        parent.setOption(JOption.IO_RATIO, <span class="number">100</span>);</div><div class="line"></div><div class="line">        <span class="comment">// child options</span></div><div class="line">        JConfig child = configGroup().child();</div><div class="line">        child.setOption(JOption.IO_RATIO, <span class="number">100</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码做了3件事。创建了boss和worker；实例化了ServerBootstrap；把参数配置起来了。仅仅只做了这些事情，很符合抽象类的风格。需要细化的操作请继承，然后自定义实现，爱咋咋地。反正最后肯定会去调用的子类实现，前提是别把我全部覆盖掉，增量去拓展就行。</p>
<p>说了这么多，实际上抽象实现就是对server的“大致”实现。具体的定制得交给子类完成。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>在上面的demo中实例化的一定是一个具体子类。子类通过一系列父类中的初始化方法完成了前期的准备工作：tcp参数设置、boss和worker的设置等。而正真开启一个server的方法是<code>start()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">       start(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> sync)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">       <span class="comment">// wait until the server socket is bind succeed.</span></div><div class="line">       ChannelFuture future = bind(localAddress).sync();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">           logger.info(<span class="string">"Jupiter TCP server start"</span> + (sync ? <span class="string">", and waits until the server socket closed."</span> : <span class="string">"."</span>)</div><div class="line">                   + JConstants.NEWLINE + <span class="string">" &#123;&#125;."</span>, toString());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (sync) &#123;</div><div class="line">           <span class="comment">// wait until the server socket is closed.</span></div><div class="line">           future.channel().closeFuture().sync();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><code>start()</code>方法只是入口，核心是<code>bind()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</div><div class="line">       ServerBootstrap boot = bootstrap();</div><div class="line"></div><div class="line">       initChannelFactory();</div><div class="line"></div><div class="line">       boot.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               ch.pipeline().addLast(</div><div class="line">                       <span class="keyword">new</span> IdleStateChecker(timer, JConstants.READER_IDLE_TIME_SECONDS, <span class="number">0</span>, <span class="number">0</span>),</div><div class="line">                       idleStateTrigger,</div><div class="line">                       CodecConfig.isCodecLowCopy() ? <span class="keyword">new</span> LowCopyProtocolDecoder() : <span class="keyword">new</span> ProtocolDecoder(),</div><div class="line">                       encoder,</div><div class="line">                       handler);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       setOptions();</div><div class="line"></div><div class="line">       <span class="keyword">return</span> boot.bind(localAddress);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannelFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">       SocketChannelProvider.SocketType socketType = socketType();</div><div class="line">       <span class="keyword">switch</span> (socketType) &#123;</div><div class="line">           <span class="keyword">case</span> NATIVE_EPOLL:</div><div class="line">               bootstrap().channelFactory(SocketChannelProvider.NATIVE_EPOLL_ACCEPTOR);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> NATIVE_KQUEUE:</div><div class="line">               bootstrap().channelFactory(SocketChannelProvider.NATIVE_KQUEUE_ACCEPTOR);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> JAVA_NIO:</div><div class="line">               bootstrap().channelFactory(SocketChannelProvider.JAVA_NIO_ACCEPTOR);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid socket type: "</span> + socketType);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>不得不说，bind方法层次也很清晰。其中调用了一个<code>initChannelFactory()</code>方法，其实没有什么高深莫测的地方。简单理解为和下面的代码类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</div></pre></td></tr></table></figure>
<p>到此为止，整个server的启动流程就结束了。整个流程十分干净，没有任何涉及到业务的地方。可能稍微有一点和业务沾边的地方就是编解码器。这个的确是完全耦合到这个acceptor中去的，也就是说如果你想单纯的去用这个acceptor是不行的。因为只能针对特定的网络数据格式进行处理。但是针对这个项目而言是没有任何问题的，我想也没有人会仅仅去用其中的acceptor，再说也不是提供给开发者用的，这是给自己用的。</p>
<p>当然，其中的比较核心的东西没有去分析。因为实在是很复杂。我打算采用抽丝剥茧的方式将其逐步细化，毕竟害怕贪多嚼不烂。接下来要讨论的是jupiter的业务编解码器的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中废话了很多“大概”不相关的东西。而这篇就要认认真真的开始讲干货了(也有可能是水货，谁知道呢)。&lt;/p&gt;
&lt;p&gt;上一篇文章主要介绍了与rpc中间件相关的但联系不是很大的spring xml标签的自定义实现。可以说是没有太多核心的东西，全文中的关键字就是“抄”。没错，
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>一起学RPC(零)</title>
    <link href="http://www.wei-dong.top/2018/08/06/%E4%B8%80%E8%B5%B7%E5%AD%A6RPC(%E9%9B%B6)/"/>
    <id>http://www.wei-dong.top/2018/08/06/一起学RPC(零)/</id>
    <published>2018-08-06T08:17:23.000Z</published>
    <updated>2018-08-06T05:55:33.640Z</updated>
    
    <content type="html"><![CDATA[<p>最近又重新开始看jupiter的源码。这个开源项目是阿里的一位大神写的，比起现在较为流行的dubbo、motan等生产上的开源软件来说轻量很多，也比较容易入门学习。本来想看看dubbo的源码的，无奈第一步都没卖出去，被extension机制给难住了。虽说目前dubbo已经成为apache的孵化项目了，对于研究源码的渣渣我来说还是有一定的难度的。于是退而求其次，jupiter就是一个比较容易入手的选择。为什么说这个jupiter比较容易入门呢？首先代码比较少，不是很多，对阅读来说不会有很多绕的地方。其次这个项目有很多热心的网友也在一起读，可以有很多交流的地方，有一个专门讨论jupiter的交流群，可以很方便的和各路大神交流学习。</p>
<p>因为jupiter源码我没有完全读完，只能看一点写一点。说不定等看完源码后再重新整理一下行文结构呢，也说不定放弃了呢，谁知道呢？</p>
<p>按照常规思路来说肯定是从一个demo来入门，但是我不决定这么做，因为如果对rpc熟悉的伙计一定知道怎么去玩，不知道怎么去玩的现在可以关掉浏览器打lol或者吃鸡去了，因为你不配。没错，就是这么傲娇。</p>
<p>看了这么多java rpc的框架比如motan、dubbo和jupiter，都有一个共同的地方，他们都使用spring作为容器来集成。这样也是情有可原，我相信java应用中没有不使用spring的吧。因此都选择这样去做大概是因为这样很容易去集成到自己的项目中。当然，这类rpc框架并不是一定得和spring集成。把他们称为“框架”其实并不是很准确。更准确的应该称为“中间件”。我的理解是因为他们虽然是集成到自己的项目代码中，但是他们却占用独立的端口。</p>
<p>spring目前在java开发中的地位很高，使用spring来管理bean是非常流行的做法。更重要的是非常方便。对于中间件来说，通过寥寥几行xml的描述就能将一个复杂的bean实例化出来，而且耦合度很低，何乐而不为呢？看一个sonsumer的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"globalInterceptor1"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyGlobalConsumerInterceptor1"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"globalInterceptor2"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyGlobalConsumerInterceptor2"</span> /&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">jupiter:client</span> <span class="attr">id</span>=<span class="string">"jupiterClient"</span> <span class="attr">registryType</span>=<span class="string">"default"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">registryServerAddresses</span>=<span class="string">"127.0.0.1:20001"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">globalConsumerInterceptors</span>=<span class="string">"globalInterceptor1,globalInterceptor2"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 可选配置 --&gt;</span></div><div class="line">       <span class="comment">&lt;!--</span></div><div class="line">           String registryServerAddresses                          // 注册中心地址 [host1:port1,host2:port2....]</div><div class="line">           String providerServerAddresses                          // IP直连到providers [host1:port1,host2:port2....]</div><div class="line">           ConsumerInterceptor[] globalConsumerInterceptors;       // 全局拦截器</div><div class="line">       --&gt;</div><div class="line"></div><div class="line">       <span class="comment">&lt;!-- 网络层配置选项 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:netOptions</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:childOption</span> <span class="attr">SO_RCVBUF</span>=<span class="string">"8192"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:childOption</span> <span class="attr">SO_SNDBUF</span>=<span class="string">"8192"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:childOption</span> <span class="attr">ALLOW_HALF_CLOSURE</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">jupiter:netOptions</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">jupiter:client</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor1"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyConsumerInterceptor1"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"interceptor2"</span> <span class="attr">class</span>=<span class="string">"org.jupiter.example.spring.interceptor.consumer.MyConsumerInterceptor2"</span> /&gt;</span></div><div class="line"></div><div class="line">   <span class="comment">&lt;!-- consumer --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">jupiter:consumer</span> <span class="attr">id</span>=<span class="string">"serviceTest"</span> <span class="attr">client</span>=<span class="string">"jupiterClient"</span> <span class="attr">interfaceClass</span>=<span class="string">"org.jupiter.example.ServiceTest"</span>&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 以下都选项可不填 --&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 服务版本号, 通常在接口不兼容时版本号才需要升级 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">version</span>=<span class="string">"1.0.0.daily"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 序列化/反序列化类型: (proto_stuff, hessian, kryo, java)可选, 默认proto_stuff --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">serializerType</span>=<span class="string">"proto_stuff"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 软负载均衡类型[random, round_robin] --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">loadBalancerType</span>=<span class="string">"round_robin"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 派发方式: (round, broadcast)可选, 默认round(单播) --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">dispatchType</span>=<span class="string">"round"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 调用方式: (sync, async)可选, 默认sync(同步调用) --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">invokeType</span>=<span class="string">"sync"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 集群容错策略: (fail_fast, fail_over, fail_safe)可选, 默认fail_fast(快速失败) --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">clusterStrategy</span>=<span class="string">"fail_over"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 在fail_over策略下的失败重试次数 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">failoverRetries</span>=<span class="string">"2"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 超时时间设置 --&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">timeoutMillis</span>=<span class="string">"3000"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:methodSpecials</span>&gt;</span></div><div class="line">           <span class="comment">&lt;!-- 方法的单独配置 --&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">jupiter:methodSpecial</span> <span class="attr">methodName</span>=<span class="string">"sayHello"</span> <span class="attr">timeoutMillis</span>=<span class="string">"5000"</span> <span class="attr">clusterStrategy</span>=<span class="string">"fail_fast"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">jupiter:methodSpecials</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">jupiter:property</span> <span class="attr">consumerInterceptors</span>=<span class="string">"interceptor1,interceptor2"</span> /&gt;</span></div><div class="line">       <span class="comment">&lt;!-- 可选配置 --&gt;</span></div><div class="line">       <span class="comment">&lt;!--</span></div><div class="line">           SerializerType serializerType                   // 序列化/反序列化方式</div><div class="line">           LoadBalancerType loadBalancerType               // 软负载均衡类型[random, round_robin]</div><div class="line">           long waitForAvailableTimeoutMillis = -1         // 如果大于0, 表示阻塞等待直到连接可用并且该值为等待时间</div><div class="line">           InvokeType invokeType                           // 调用方式 [同步, 异步]</div><div class="line">           DispatchType dispatchType                       // 派发方式 [单播, 广播]</div><div class="line">           long timeoutMillis                              // 调用超时时间设置</div><div class="line">           List&lt;MethodSpecialConfig&gt; methodSpecialConfigs; // 指定方法的单独配置, 方法参数类型不做区别对待</div><div class="line">           ConsumerInterceptor[] consumerInterceptors      // 消费者端拦截器</div><div class="line">           String providerAddresses                        // provider地址列表, 逗号分隔(IP直连)</div><div class="line">           ClusterInvoker.Strategy clusterStrategy;        // 集群容错策略</div><div class="line">           int failoverRetries                             // fail_over的重试次数</div><div class="line">       --&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">jupiter:consumer</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对于一个相对比较成熟的rpc中间件来说，核心的bean配置是比较复杂的。你看看其中的参数就知道。通过spring的这种xml描述文件起码能够稍微容易地理解到一个bean需要哪些参数，哪些可以不要，同时根据xsd的约束能够让开发者更清楚的知道自己的配置有什么问题。如果不给api文档的情况下干巴巴的给你一个类，让你去实例化这个复杂的class，我相信很多人都会抓狂。在这个配置文件中很容易的看出要有2个节点：client和consumer。子节点的内容就是参数。consumer会去引用client去执行一个请求。而我们的业务中直接去调用consumer就完事了。如此而已，简单直观。</p>
<p>这里的spring xml配置使用的是自定义的标签，算是对spring的拓展。不仅是jupiter，基本上大多数rpc中间件都实现了自己的一套标签，似乎不去自己实现一套自定义标签都不好意思开源。比如dubbo的自定义标签就是<code>&lt;dubbo:xxx&gt;</code>，motan类似如此。然而实际上也不是必须得实现自定义标签，使用spring的bean也是可以的，只不过显得很臃肿，不是那么直观罢了。</p>
<p>对于一个新手来讲，这些东西显得格外的高大上。其实里面没有什么黑魔法，在spring的reference中对自定义标签有介绍。感兴趣的去看看这个官方文档：<a href="https://docs.spring.io/spring/docs/4.3.19.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#xml-custom" target="_blank" rel="external">spring xml extension</a>.</p>
<p>要实现一个自定义的spring xml标签需要做一下几个步骤：</p>
<ul>
<li>定义一个约束文件，用来规范xml的内容。现在都流行使用xsd去编写约束文件，dtd已经成为老古董了。<a href="http://www.w3school.com.cn/schema/schema_intro.asp" target="_blank" rel="external">xsd了解一下</a>.</li>
<li>自定义一个<code>NamespaceHandler</code>的实现。实际上是去实现这个接口。非常容易，复制粘贴一把梭。</li>
<li>写一个或者多个<code>BeanDefinitionParser</code>的实现。也是去实现接口，当然继承抽象类也是ok的。这个是最核心的内容。</li>
<li>将上面所定义的全部注册到spring中，让spring知道有这些玩意儿。也就是在<code>META-INF</code>文件夹下新增两个配置文件：<code>spring.handlers</code>和<code>spring.schemas</code></li>
</ul>
<p>下面就结合jupiter中自定义的spring标签来谈谈他是如何实现的。</p>
<p>首先得定义xsd约束文件,完整的定义在<a href="https://github.com/Mr-Vincent/Jupiter/blob/master/jupiter-spring-support/src/main/resources/jupiter.xsd" target="_blank" rel="external">这里</a>.这个没什么好说的，枯燥的xml定义罢了。无非就是定义有哪些元素，哪些元素下有哪些属性，其中有没有子元素，属性类型是什么，是不是必填的等等。</p>
<p>接下来就是配置一个<code>handler</code>。这个handler用来解析自定义的标签。用过spring都知道，除了最常见的bean标签还有很多其他的标签，比如<code>&lt;context:component-scan&gt;</code>、<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt;</code>以及<code>&lt;mvc:annotation-driven/&gt;</code>等。这些标签和bean标签的不同之处在于都有一个前缀。我们称这个叫做命名空间。然而自定义的当然也得加上命名空间。虽说不能和bean平起平坐，但是和aop、context这样的标签还是可以一视同仁的。</p>
<p>基于这种思路，那就很容易来自定义自己的标签了。难怪文档中对这个步骤加了一个说明：</p>
<blockquote>
<p>Coding a custom NamespaceHandler implementation (this is an easy step, don’t worry).</p>
</blockquote>
<p>的确如此，常人的思路就是照着spring的实现抄一把。如此简单！</p>
<p>而比较复杂的就是对<code>BeanDefinitionParser</code>的实现了。这个是最核心的步骤。根据文档中的描述，这个可以有一个或者多个。但是在jupiter中只定义了一个实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JupiterNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        registerBeanDefinitionParser(<span class="string">"server"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringServer.class));</div><div class="line">        registerBeanDefinitionParser(<span class="string">"client"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringClient.class));</div><div class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringProviderBean.class));</div><div class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> JupiterBeanDefinitionParser(JupiterSpringConsumerBean.class));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>spring的<code>TaskNamespaceHandler</code>中就使用了多个paser：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"executor"</span>, <span class="keyword">new</span> ExecutorBeanDefinitionParser());</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"scheduled-tasks"</span>, <span class="keyword">new</span> ScheduledTasksBeanDefinitionParser());</div><div class="line">		<span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"scheduler"</span>, <span class="keyword">new</span> SchedulerBeanDefinitionParser());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个paser用通俗的话来解释就是将在xml的配置参数给set到相应的实例中去。举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">getBeanClass</span><span class="params">(Element element)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SimpleDateFormat.class; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder bean)</span> </span>&#123;</div><div class="line">        <span class="comment">// this will never be null since the schema explicitly requires that a value be supplied</span></div><div class="line">        String pattern = element.getAttribute(<span class="string">"pattern"</span>);</div><div class="line">        bean.addConstructorArg(pattern);</div><div class="line"></div><div class="line">        <span class="comment">// this however is an optional property</span></div><div class="line">        String lenient = element.getAttribute(<span class="string">"lenient"</span>);</div><div class="line">        <span class="keyword">if</span> (StringUtils.hasText(lenient)) &#123;</div><div class="line">            bean.addPropertyValue(<span class="string">"lenient"</span>, Boolean.valueOf(lenient));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个栗子是继承自<code>AbstractSingleBeanDefinitionParser</code>并没有去实现<code>BeanDefinitionParser</code>接口。道理都知道，没有必要去实现一个要啥没啥的接口，吃现成的就好。重写父类的<code>getBeanClass</code>方法，将需要纳入spring管理的对象返回掉。这里不仅仅可以重写这个方法，还有其他例如<code>getBeanClassName</code>也行。值得注意的是如果采用继承抽象类的方式，这两个方法必须选择一个来重写。这个也非常容易理解，因为这个方法返回的class实例或者类的全路径名就是用来实例化的对象。如果通过实现接口的方式来定义paser就不需要考虑这个规则了，只需要创建出<code>BeanDefinition</code>的实例即可。jupiter中就是采用实现接口的方式，因为继承抽象类有一定的局限性，实现接口会有更多的灵活性。</p>
<p>有了要煮饭的锅，就差下锅的米了。这个栗子中重写父类的<code>doParser</code>方法。从代码的表现上来看实际上就是将xml配置文件中的属性获取到，然后做一下检查放到实例化的对象中去。当然这里没有那么直接，这里使用的是<code>BeanDefinitionBuilder</code>来操作的。这只是最简单的实现。</p>
<p>复杂的parser都是自己去实现接口的。比如jupiter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JupiterBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JupiterBeanDefinitionParser</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanClass = beanClass;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (beanClass == JupiterSpringServer.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterServer(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanClass == JupiterSpringClient.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterClient(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanClass == JupiterSpringProviderBean.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterProvider(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanClass == JupiterSpringConsumerBean.class) &#123;</div><div class="line">            <span class="keyword">return</span> parseJupiterConsumer(element, parserContext);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Unknown class to definition: "</span> + beanClass.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jupiter的自定义parser中需要纳入spring管理的bean class对象是通过构造器传进来的。根据不同的class来作不同的处理。其中具体的逻辑很枯燥无味，就不再细细探讨了。不过我在看源码的过程中发现了一个细节的地方，也是值得注意的地方。</p>
<p><code>JupiterSpringConsumerBean</code>不仅仅和其他(如<code>JupiterSpringServer</code>等)实现<code>InitializingBean</code>，还实现了一个叫做<code>FactoryBean</code>的接口。这说明了一个问题，这个bean不是普通的bean，而是一个factory bean。相信很多人都会疑惑factory bean 和bean factory有什么区别。要我说两者都没有直接的联系，如果在面试的时候有人问我这个问题，我一定直接怼回去：雷锋和雷峰塔有什么区别？言归正传，这个factory bean本质上也是bean，但是与其他bean不同的是这个bean在spring容器中获取的方式和别的不一样。通常在spring中获取一个bean采用<code>ctx.getBean(xxx.class)</code>方法。通过这个方法获取的factory bean并不是他自己，而是它的某个成员。可以看看这个接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    Class&lt;?&gt; getObjectType();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说返回的对象是<code>getObject()</code>返回值。那么这个接口存在的意义是什么呢？我也不复制粘贴了，觉着<a href="https://www.jianshu.com/p/6f0a59623090" target="_blank" rel="external">这篇文章</a>写得很不错，浅显易懂。那么如何获取这个bean本身呢？干嘛想着获取它本身，简直是无聊！也有方法，加个前缀”&amp;”就行了(<code>ctx.getBean(&quot;&amp;sb&quot;)</code>)。</p>
<p>最后呢，就是照着spring的官方文档抄一下配置文件。依葫芦画瓢，非常简单。</p>
<p>完成了以上的几个步骤，自定义的spring xml标签就大功告成了。接下来要做的就是去使用自定义的标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:myns</span>=<span class="string">"http://www.mycompany.com/schema/myns"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- as a top-level bean --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">myns:dateformat</span> <span class="attr">id</span>=<span class="string">"defaultDateFormat"</span> <span class="attr">pattern</span>=<span class="string">"yyyy-MM-dd HH:mm"</span> <span class="attr">lenient</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jobDetailTemplate"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dateFormat"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- as an inner bean --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">myns:dateformat</span> <span class="attr">pattern</span>=<span class="string">"HH:mm MM-dd-yyyy"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里是抄的官方文档的栗子。标签<code>myns:dateformat</code>实际上定义了一个<code>SimpleDateFormat</code>的bean实例。在spring容器加载的时候这个实例就回被初始化。在使用自定义的标签的时候，需要注意的是得声明好命名空间和指定location，不然会报无法找到这个标签的错误。其实这些东西照着抄就行了，只是不要忘记了或者抄错了。</p>
<p>自定义spring xml标签如此简单。无非就是照着文档抄一把，自己再改吧改吧万事就大吉了。对于其中核心的东西实际上还是一知半解，比方说<code>BeanDefinition</code>的具体实现原理等。上层的封装太抽象了，留给开发者的仅仅只是一个需要实现的方法。要想知道为什么要这样做，还得去研究spring的源码。</p>
<p>rpc中的最简单的一个可选模块就这样简单的实现了。这是一小步，也是一大步。接下来会继续探索稍微核心一点的jupiter实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又重新开始看jupiter的源码。这个开源项目是阿里的一位大神写的，比起现在较为流行的dubbo、motan等生产上的开源软件来说轻量很多，也比较容易入门学习。本来想看看dubbo的源码的，无奈第一步都没卖出去，被extension机制给难住了。虽说目前dubbo已经成
    
    </summary>
    
      <category term="一起读源码" scheme="http://www.wei-dong.top/categories/%E4%B8%80%E8%B5%B7%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Jupiter" scheme="http://www.wei-dong.top/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>浅析JDK中的定时器Timer实现</title>
    <link href="http://www.wei-dong.top/2018/04/21/Timer/"/>
    <id>http://www.wei-dong.top/2018/04/21/Timer/</id>
    <published>2018-04-21T08:17:23.000Z</published>
    <updated>2018-05-17T06:30:16.624Z</updated>
    
    <content type="html"><![CDATA[<p>在jdk中处理定时任务工具类中有2种：Timer和ScheduledExecutorService。前者是在java.util包中，从1.3版本开始，属于比较老的工具类了。而ScheduledExecutorService属于java.util.concurrent包，作者是老爷子Doug Lea，1.5版本开始才有。虽然现在大多使用ScheduledExecutorService，但是我觉得很有必要对其“同宗”Timer的实现进行解读。</p>
<h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>官方文档中的解释是这样的：</p>
<blockquote>
<p>A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.</p>
</blockquote>
<p>线程的工具，用于在后台线程中安排将来执行的任务。 可以安排一次性执行任务，或定期重复执行任务。</p>
<blockquote>
<p>This class is thread-safe: multiple threads can share a single Timer object without the need for external synchronization.<br>This class does not offer real-time guarantees: it schedules tasks using the Object.wait(long) method.<br>Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn’t require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer.</p>
</blockquote>
<p>这个类是线程安全的，但不能保证是实时的，因为使用的是wait方法来调度任务。文档还说了建议使用JUC下的ScheduledThreadPoolExecutor（ScheduledExecutorService的实现）类来处理定时任务，这个类提供的功能更多，参数更灵活，而且是多线程的。当线程池size指定为一那就和Timer一个样了。</p>
<p>下面通过一个demo来展示一下相关api的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkTimerDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="string">"timer-demo"</span>);</div><div class="line">        MyTask[] tasks = <span class="keyword">new</span> MyTask[<span class="number">20</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</div><div class="line">            tasks[i] = <span class="keyword">new</span> MyTask(i);</div><div class="line">            System.out.println(<span class="string">"time no "</span> + i + <span class="string">" task start at "</span> + <span class="keyword">new</span> Date());</div><div class="line">            timer.schedule(tasks[i], <span class="number">2</span> * <span class="number">1000</span>, <span class="number">3</span> * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"timer started at: "</span> + <span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> timeNo;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> timeNo)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.timeNo = timeNo;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果任务出现异常不被捕获，其他任务不会被执行</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (timeNo == <span class="number">8</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"time no "</span> + timeNo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个demo展示一个Timer的弊端。当任务中出现未被捕获的异常，接下来的任务都不会被执行，定时器crash掉。这个demo中定义了20个task交给timer调度，timer启动2秒后开始执行任务，每隔3秒执行一次。接下来就跟着demo一步一步看看其中的实现原理。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>首先看看构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name, <span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.setDaemon(isDaemon);</div><div class="line">    thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器的参数代表着timer的名字和这个timer是否是后台运行的（timer本质上是一个线程）。一旦实例化就将这个线程给启动了。这个线程是核心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</div></pre></td></tr></table></figure>
<p>可以看到这个成员属性TimerThread内部维护着一个queue。这个queue上什么稍后再讲。</p>
<p>实例化结束后就得调用它的schedule方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</div><div class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</div><div class="line">    sched(task, System.currentTimeMillis()+delay, -period);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 核心的是这段逻辑</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Constrain value of period sufficiently to prevent numeric</span></div><div class="line">    <span class="comment">// overflow while still being effectively infinitely large.</span></div><div class="line">    <span class="comment">// 防止溢出 如果周期比最大值的一半还大 那就将其除以2 道理何在？</span></div><div class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</div><div class="line">        period &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">            <span class="comment">// 如果任务状态不为新创建的 直接抛异常</span></div><div class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Task already scheduled or cancelled"</span>);</div><div class="line">            <span class="comment">// 设置任务下次执行时间 执行周期 以及 状态</span></div><div class="line">            task.nextExecutionTime = time;</div><div class="line">            task.period = period;</div><div class="line">            task.state = TimerTask.SCHEDULED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		  <span class="comment">// 任务实际上是放在队列中 并不是直接执行的 </span></div><div class="line">        queue.add(task);</div><div class="line">        <span class="comment">// 为什么需要queue.getMin() == task时才调用notify方法呢？</span></div><div class="line">        <span class="keyword">if</span> (queue.getMin() == task)</div><div class="line">            queue.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看似简单，但也是有点门道的。在设置任务属性的时候采用加锁，避免并发下把不同任务的执行周期等参数搞混乱了。添加任务到队列中也使用了加锁，实际上是针对add方法加的锁。保证add任务不出乱（这个队列不是安全的队列）。最后有个判断，为什么需要queue.getMin() == task时才调用notify方法呢？因为只有新加入的task是所有Task中要被最早执行的task时，才会需要打断TimeThread的等待状态。举个例子，当前队列中有两个task，分别是A（3分钟后到时间）、B（5分钟后到时间），此时TimerThread正在等待A的时间到来，所以会调用queue.wait(3min)，这个时候，队列中新增一个任务C（1分钟后到时），如果不打断queue.wait(3min)，那当wait(3min)自然结束时，C任务已经过期了… 但是如果新加入的C任务是需要在4分钟后执行，那就没必要打断wait(3min)的状态，因为就算wait(3min)自然结束时，C也还没到时间.</p>
<h5 id="任务是什么"><a href="#任务是什么" class="headerlink" title="任务是什么"></a>任务是什么</h5><p>说了这么久，还没弄清楚这个任务是个什么玩意？按照直觉说到任务第一想到就是Runnable对象，但是也有其他情况下不是这样的。然而这个任务确实是个Runnable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">// 对象锁</span></div><div class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line">   </div><div class="line">    <span class="comment">// 任务状态 新建 已调度 已执行 已取消</span></div><div class="line">    <span class="comment">// 默认是新建</span></div><div class="line">    <span class="keyword">int</span> state = VIRGIN;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRGIN = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULED   = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTED    = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">3</span>;</div><div class="line">	 <span class="comment">// 下次执行的时间</span></div><div class="line">    <span class="keyword">long</span> nextExecutionTime;</div><div class="line">	 <span class="comment">// 周期</span></div><div class="line">    <span class="keyword">long</span> period = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TimerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">boolean</span> result = (state == SCHEDULED);</div><div class="line">            state = CANCELLED;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">scheduledExecutionTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">return</span> (period &lt; <span class="number">0</span> ? nextExecutionTime + period</div><div class="line">                               : nextExecutionTime - period);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TimeTask对Runnable进行简单封装。暴露出抽象的run方法让用户的具体实现类去完成。同时提供了取消任务的方法。和JUC中不同的是这里状态的转化非常简单，没有JUC中动不动就用CAS的骚操作。老版本的代码就是好理解些。</p>
<h5 id="任务的调度（定时器的核心）"><a href="#任务的调度（定时器的核心）" class="headerlink" title="任务的调度（定时器的核心）"></a>任务的调度（定时器的核心）</h5><p>既然都知道任务是什么了，接下来看看队列中的任务是怎么被取出来和执行的。首先得看看这个线程是个什么样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">// 标记这个线程是不是要被挂起</span></div><div class="line">    <span class="keyword">boolean</span> newTasksMayBeScheduled = <span class="keyword">true</span>;</div><div class="line">	 <span class="comment">// 维护一个队列 用于存放任务的队列</span></div><div class="line">    <span class="keyword">private</span> TaskQueue queue;</div><div class="line"></div><div class="line">    TimerThread(TaskQueue queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mainLoop();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></div><div class="line">            <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">                queue.clear();  <span class="comment">// Eliminate obsolete references</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 具体执行核心逻辑 开死循环跑</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimerTask task;</div><div class="line">                <span class="keyword">boolean</span> taskFired;</div><div class="line">                <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                    <span class="comment">// Wait for queue to become non-empty</span></div><div class="line">                    <span class="comment">// 如果队列中没有任务，而且定时器没有被取消（默认为true，只有将timer取消cancel方法调用的时候将其置为false，还有一个地方） 就得将这个线程挂起 不然就造成了死循环 cpu直接上100%</span></div><div class="line">                    <span class="comment">// 而唤起的地方只有cancel方法和threadReaper</span></div><div class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</div><div class="line">                        queue.wait();</div><div class="line">                    <span class="comment">// 任务队列空了 定时器取消了 跳出循环 线程结束</span></div><div class="line">                    <span class="keyword">if</span> (queue.isEmpty())</div><div class="line">                        <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></div><div class="line"></div><div class="line">                    <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></div><div class="line">                    <span class="keyword">long</span> currentTime, executionTime;</div><div class="line">                    <span class="comment">// 从队列中取出最delay时间最小的任务 得最早执行的任务</span></div><div class="line">                    task = queue.getMin();</div><div class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">                    	 <span class="comment">// 任务取消了，将其移出队列 继续取下一个</span></div><div class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</div><div class="line">                            queue.removeMin();</div><div class="line">                            <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// currentTimeMillis()返回以毫秒为单位的当前时间，返回的是当前时间与1970 年 1 月 1 日午夜之间的时间差</span></div><div class="line">                        currentTime = System.currentTimeMillis();</div><div class="line">                        executionTime = task.nextExecutionTime;</div><div class="line">                        <span class="comment">// 如果给定的到期时间小于当前时间（1970-01-01到现在的差值）说明任务到期了 需要被执行 把taskFired置为true</span></div><div class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</div><div class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></div><div class="line">                            	  <span class="comment">// 不是周期执行的任务 直接从队列中移除掉 将任务状态置为已执行</span></div><div class="line">                                queue.removeMin();</div><div class="line">                                task.state = TimerTask.EXECUTED;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></div><div class="line">                                <span class="comment">// 是周期任务 重新计算下次执行的时间 即当前时间+间隔时间为下次任务执行的时间</span></div><div class="line">                                <span class="comment">// 这里是➖因为之前传进来的是一个负值</span></div><div class="line">                                queue.rescheduleMin(</div><div class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</div><div class="line">                                                : executionTime + task.period);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果没到期 就等一个delay长的时间</span></div><div class="line">                    <span class="comment">// executionTime  = System.currentTimeMillis()+delay</span></div><div class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></div><div class="line">                        queue.wait(executionTime - currentTime);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 任务启动 执行业务逻辑</span></div><div class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></div><div class="line">                    task.run();</div><div class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="小疑惑"><a href="#小疑惑" class="headerlink" title="小疑惑"></a>小疑惑</h5><p>整个定时器的核心逻辑在代码注释中都一一解释了。其中一个细节：变量newTasksMayBeScheduled用来做什么的。<br>首先得看看它的值被置为false的情形在哪些地方出现。</p>
<ul>
<li>Timer#cancel方法</li>
<li>TimerThread的mainloop执行完了finally块中</li>
<li>Timer的成员属性threadReaper的finalize方法中</li>
</ul>
<p>前两者都不必多解释，值得注意的是最后一种情况。这种写法我还是第一次见，还不明白其中的玄机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This object causes the timer's task execution thread to exit</div><div class="line"> * gracefully when there are no live references to the Timer object and no</div><div class="line"> * tasks in the timer queue.  It is used in preference to a finalizer on</div><div class="line"> * Timer as such a finalizer would be susceptible to a subclass's</div><div class="line"> * finalizer forgetting to call it.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object threadReaper = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">            thread.newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">            queue.notify(); <span class="comment">// In case queue is empty.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当queue为空，并且没人调用add或cancel方法时，TimerThread永远都不会stop，那么还有别的可能吗？</p>
<p>上述的做法就提供了另外的思路。当队列中没有任务的时候，TimerThread会wait，如果不手动调用cancel这个线程一直会挂起。聪明的jdk就提供了上述的方法。当在GC的时候会触发finalize方法调用，那什么时候会触发GC呢？当Timer对象没有被任何对象引用的时候如果有GC那么这段代码被调用：newTasksMayBeScheduled置为false同时将挂起的TimerThread唤醒，这时候mainloop死循环就跳出了，TimerThread线程结束！</p>
<p>具体验证可以使用Jprofile这个工具。事实上确实可行。但是通过这段代码让我联想到一个这个定时器的弊端：没做到像ExecutorService能够等到任务全部执行完成后再将其关闭。手动关闭只能通过cancel这种粗暴的方式,还好jdk工程师提供这样一个“后门”，交给jvm来管理。这也不失为一种补救措施，但是对于之后的JUC而言，这种做法显得有点“小儿科”了。但是对于学习者而言，这种代码组织显得更容易读懂，设计思想很容易呈现在我们面前。时代不断进步，总会有好的设计来取代老的旧的东西。并不是意味着老的旧的真正被取代，而是以另外一种价值呈现在我们后来人面前。通过比较，我们可能会更加理解什么是好的设计。</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>整个Timer定时任务的核心逻辑就梳理完了。其中有一些细节被忽略掉了，比如这个任务队列queue的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * This class represents a timer task queue: a priority queue of TimerTasks,</div><div class="line"> * ordered on nextExecutionTime.  Each Timer object has one of these, which it</div><div class="line"> * shares with its TimerThread.  Internally this class uses a heap, which</div><div class="line"> * offers log(n) performance for the add, removeMin and rescheduleMin</div><div class="line"> * operations, and constant time performance for the getMin operation.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护一个长度为128的数组</span></div><div class="line">    <span class="keyword">private</span> TimerTask[] queue = <span class="keyword">new</span> TimerTask[<span class="number">128</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 队列长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Adds a new task to the priority queue.</div><div class="line">     * 当前队列长度为最大长度-1的时候就进行扩容 新队列长度为当前2倍</div><div class="line">     * 为什么要在最大长度-1的时候扩容呢？因为不提前扩容当前的元素加不进去😂</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TimerTask task)</span> </span>&#123;</div><div class="line">        <span class="comment">// Grow backing store if necessary</span></div><div class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> == queue.length)</div><div class="line">            queue = Arrays.copyOf(queue, <span class="number">2</span>*queue.length);</div><div class="line"></div><div class="line">        queue[++size] = task;</div><div class="line">        fixUp(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function">TimerTask <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下标从1开始取</span></div><div class="line">    <span class="function">TimerTask <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 移除第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra reference to prevent memory leak</span></div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickRemove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> i &lt;= size;</div><div class="line"></div><div class="line">        queue[i] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra ref to prevent memory leak</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 改第一个元素的到期时间属性</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rescheduleMin</span><span class="params">(<span class="keyword">long</span> newTime)</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>].nextExecutionTime = newTime;</div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Null out task references to prevent memory leak</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=size; i++)</div><div class="line">            queue[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) assuming the heap</div><div class="line">     * satisfies the invariant except possibly for the leaf-node indexed by k</div><div class="line">     * (which may have a nextExecutionTime less than its parent's).</div><div class="line">     *</div><div class="line">     * This method functions by "promoting" queue[k] up the hierarchy</div><div class="line">     * (by swapping it with its parent) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is greater than or equal to that of its parent.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> j = k &gt;&gt; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the subtree</div><div class="line">     * rooted at k, which is assumed to satisfy the heap invariant except</div><div class="line">     * possibly for node k itself (which may have a nextExecutionTime greater</div><div class="line">     * than its children's).</div><div class="line">     *</div><div class="line">     * This method functions by "demoting" queue[k] down the hierarchy</div><div class="line">     * (by swapping it with its smaller child) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is less than or equal to those of its children.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">while</span> ((j = k &lt;&lt; <span class="number">1</span>) &lt;= size &amp;&amp; j &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (j &lt; size &amp;&amp;</div><div class="line">                queue[j].nextExecutionTime &gt; queue[j+<span class="number">1</span>].nextExecutionTime)</div><div class="line">                j++; <span class="comment">// j indexes smallest kid</span></div><div class="line">            <span class="keyword">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the entire tree,</div><div class="line">     * assuming nothing about the order of the elements prior to the call.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</div><div class="line">            fixDown(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个队列是一个优先队列，以task的到期时间来排序，时间越小越靠前。这个队列是用堆结构实现的（废话，优先队列本身就是堆），实际上堆本质上就是完全二叉树。对于add remove操作的复杂度为log(n)。最核心的操作就是fixDown fixUp。堆也分为大根堆和小根堆，这是一个小根堆，最小的放到最上面，也就是下标为1的位置（只是Timer中的实现将下标为0的位置给弃用了）。每次添加元素都得调整堆结构，同理移除的时候也得这样做。</p>
<p>本文中的<a href="https://github.com/Mr-Vincent/simple-rpc/blob/a570c16128062b14ac0f0fa75e769d76060d3ad2/simple-example/src/main/java/top/weidong/example/netty/nettyinpractice/timer/JdkTimerDemo.java#L95-L94" target="_blank" rel="external">demo</a>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>源码读起来没那么难受，仔细推敲还是很有意思的。</li>
<li>相比老爷子Doug Lea的骚代码，这种中规中矩的写法看起来更让人容易理解。</li>
<li>建议使用ScheduledExecutorService，毕竟Timer的适用场景很局限。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在jdk中处理定时任务工具类中有2种：Timer和ScheduledExecutorService。前者是在java.util包中，从1.3版本开始，属于比较老的工具类了。而ScheduledExecutorService属于java.util.concurrent包，作者
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.wei-dong.top/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.wei-dong.top/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>写给2017</title>
    <link href="http://www.wei-dong.top/2017/12/31/my%202017/"/>
    <id>http://www.wei-dong.top/2017/12/31/my 2017/</id>
    <published>2017-12-31T09:42:35.000Z</published>
    <updated>2018-01-01T10:44:55.854Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2018年一月一号，2018年的第一天。胡斐早上去HK买手机到现在还没回来，阿华刚刚出去约会去了。现在就剩下我一个人在家，坐在沙发上思量着这篇文章该怎么去写。傍晚了，余晖渐渐褪。和往常不同的是今天的天际线边没有往日那样红了。曾几何时，多少个黄昏十分，我就坐在沙发上，静静等着，等着太阳落山，等着晚霞映红天际线。每到那个点儿，总有飞机飞过，在晚霞的映衬下，缓缓地划过去，一架又一架。那是去年年底的时候。</p>
<p>12月份，被公司劝退。当时走的时候心里别提多高兴了，终于可以不用上班了，终于不用天天做一些无聊又没有意义的事情了。没有马上去找工作，而是什么都不干，玩他么2个星期再说。果真玩了一个星期，什么都没有去想，安安静静的看看书，看看电视剧，睡睡觉。那时候觉得不用工作真的是很幸福的一件事情。第二周把简历随便写了写，又随便投了投，没什么回应。也不在乎，反正也不想上班，继续玩呗。书也看的差不多了，得找些更加有意思的事情来做。在网易云课堂上报了一个素描班，开始学习画画。虽然现在都没怎么动笔去画了，但是我对素描的热情还是没有褪去。买了好几本书还没开始看，我知道总会看的，总会去坚持下去，总会实践出来。仔细回想过去，对于每天的枯燥无聊的coding和加班，是时候该问问自己到底想要什么，想达到一个什么样的层次。培养一种兴趣爱好对于我们这种生活单调无聊的人来说很重要。不光仅仅学素描，还时不时去谈谈吉他，虽然手上的茧都消地差不多了，但是热情还在。</p>
<p>没上班的日子我想过很多。目前这个职业我想我不会一直走下去，万一走不下去了我得给自己找条后路。但不论怎么说，目前还是得走下去，还是得不断去学习。</p>
<p>总觉得有很多时候，能一个人独处是一件多么愉快的事情。屋子里就我一个人，心没有那么浮躁。不会去看阿华打游戏，不会找胡斐扯淡。可以看书，可以写点东西…</p>
<p>总是将看书作为一件很重要的事情。离开校园，踏入社会参加工作，可能没有机会去碰书。因此读书就显得十分可贵。感触最明显的时候就是和别人交流的时候，有时候觉得对方说的自己都没办法接。去年我也读了部分书，仅仅只是读过，还没有什么深刻认识。印象中耗时最长的是《白鹿原》。以前上下班在地铁上就拿着手机看，每天都能看一点。现在没有那么多大把大把的时间了。零碎的时间也不知道该怎么利用。收获最大的一本书是《How Tomcat Works》。这本书本身就写得不错，浅显易懂。很久以来，我读书都没有记笔记的习惯。但是读这本书我用纸笔将其中有意思的内容记下来了。以前一直认为不会的或者忘记了的去百度谷歌就好了。现在则是觉得有必要就可以用笔记下来，画一下也行，这样容易帮助理解和记忆。虽然现在的各种软件APP都很多很方便，但是有时候就是记下来就很少去看了。走过一遭，总得留下点什么吧。</p>
<p>前些日子，把玩了差不多2年的游戏王者农药卸载了。以后不再这上面浪费时间了。然而可耻的是开始了吃鸡。我想我也不会沉迷于吃鸡太久，比较一个人玩也没多大意思。玩着玩着可能就无聊了。可能会将注意力转移到写作或者素描上来。去年屯的书也还一本没看完，总得给自己一点交代吧。</p>
<p>出来工作这么久了，难过的是一个新朋友都没有交到。很多老朋友却没什么联系了。有时候就觉得人情薄如纸。圈子不同了，可能认知也不太一样了。仅仅只是我还在原地踏步而已，却总暗示自己要向前走。即使如此那又怎样？我初心不改，我依旧是那个我。虽与孤独为伴，但是内心依旧丰富。从此再也不委屈自己，不再热脸贴冷屁股。我也有我自己的世界。</p>
<p>每当回首过去的时候，总是觉得许多日子都虚度了。有些事情，做好规划还是很有必要，前提是呀有足够的自律，否则其他都是瞎扯淡。</p>
<p>不论过去有怎样的懊悔和不满，路还长，总得往前走。只希望在下个路标回头的时候，我能依然记得此时的我对自己的期许。</p>
<p>2018，我已准备好！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2018年一月一号，2018年的第一天。胡斐早上去HK买手机到现在还没回来，阿华刚刚出去约会去了。现在就剩下我一个人在家，坐在沙发上思量着这篇文章该怎么去写。傍晚了，余晖渐渐褪。和往常不同的是今天的天际线边没有往日那样红了。曾几何时，多少个黄昏十分，我就坐在沙发上，静
    
    </summary>
    
      <category term="beyound coding" scheme="http://www.wei-dong.top/categories/beyound-coding/"/>
    
    
      <category term="所想" scheme="http://www.wei-dong.top/tags/%E6%89%80%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《How Tomcat Works》读书笔记</title>
    <link href="http://www.wei-dong.top/2017/12/06/%E3%80%8AHow%20Tomcat%20Works%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.wei-dong.top/2017/12/06/《How Tomcat Works》读书笔记/</id>
    <published>2017-12-06T04:37:23.000Z</published>
    <updated>2017-12-06T04:39:19.177Z</updated>
    
    <content type="html"><![CDATA[<p>这本书看了这么久，差不多可以算是看完了。准确来讲是还剩两个章节没有读完。最后那两个章节的的确确是很不得劲，也有可能是自己开始浮躁起来了。我看的是中文翻译的，可气的是中文翻译很多错别字不说，居然有些地方根本就没有翻译到，“缺斤少两”很可气。然后又找原版对照着看，避免被“误入歧途”。<br><a id="more"></a><br>差不多“读完”后，有那么一点小收获：</p>
<ul>
<li>观察者模式</li>
<li>责任链模式</li>
<li>门面模式</li>
<li>想到了再写</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>这个模式是我印象最深刻的，也是我最想学习的。尤其是看到了Tomcat源码中的那些骚操作。当然不仅仅是在Tomcat中有这种设计，<br>我在看Spring源码的时候也留意到了也有这种设计思想，内心不禁发出一个信号：教练我也想学。</p>
<p>接下来就针对Tomcat中的源码来对观察者模式进行简单的整理。Tomcat中许多组件都有生命周期，其实不止Tomcat，很多其他地方也有生命周期的概念：Spring生命周期，Servlet生命周期等等。生命周期就是观察者模式最好的体现。举个栗子，Service组件：<code>StandardService</code>就有生命周期：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span></span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Lifecycle</span>, <span class="title">Service</span> &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The set of Connectors associated with this Service.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Connector connectors[] = <span class="keyword">new</span> Connector[<span class="number">0</span>];</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The Container associated with this Service.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Container container = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The debugging detail level for this component.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> debug = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Descriptive information about this component implementation.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String info =</div><div class="line">        <span class="string">"org.apache.catalina.core.StandardService/1.0"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Has this component been initialized?</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The name of this service.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String name = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The lifecycle event support for this component.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LifecycleSupport lifecycle = <span class="keyword">new</span> LifecycleSupport(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The string manager for this package.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm =</div><div class="line">        StringManager.getManager(Constants.Package);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The &lt;code&gt;Server&lt;/code&gt; that owns this Service, if any.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Server server = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Has this component been started?</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The property change support for this component.</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> PropertyChangeSupport support = <span class="keyword">new</span> PropertyChangeSupport(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// ------------------------------------------------------ Lifecycle Methods</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a LifecycleEvent listener to this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to add</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">        lifecycle.addLifecycleListener(listener);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the lifecycle listeners associated with this lifecycle. If this </div><div class="line">     * Lifecycle has no listeners registered, a zero-length array is returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> lifecycle.findLifecycleListeners();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove a LifecycleEvent listener from this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to remove</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">        lifecycle.removeLifecycleListener(listener);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Prepare for the beginning of active use of the public methods of this</div><div class="line">     * component.  This method should be called before any of the public</div><div class="line">     * methods of this component are utilized.  It should also send a</div><div class="line">     * LifecycleEvent of type START_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that prevents this component from being used</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Validate and update our current component state</span></div><div class="line">        <span class="keyword">if</span> (started) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException</div><div class="line">                (sm.getString(<span class="string">"standardService.start.started"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        System.out.println</div><div class="line">            (sm.getString(<span class="string">"standardService.start.name"</span>, <span class="keyword">this</span>.name));</div><div class="line">        lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Container first</span></div><div class="line">        <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (container) &#123;</div><div class="line">                <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Lifecycle) &#123;</div><div class="line">                    ((Lifecycle) container).start();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Connectors second</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (connectors[i] <span class="keyword">instanceof</span> Lifecycle)</div><div class="line">                    ((Lifecycle) connectors[i]).start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Gracefully terminate the active use of the public methods of this</div><div class="line">     * component.  This method should be the last one called on a given</div><div class="line">     * instance of this component.  It should also send a LifecycleEvent</div><div class="line">     * of type STOP_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that needs to be reported</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Validate and update our current component state</span></div><div class="line">        <span class="keyword">if</span> (!started) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException</div><div class="line">                (sm.getString(<span class="string">"standardService.stop.notStarted"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        lifecycle.fireLifecycleEvent(STOP_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        System.out.println</div><div class="line">            (sm.getString(<span class="string">"standardService.stop.name"</span>, <span class="keyword">this</span>.name));</div><div class="line">        started = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Stop our defined Connectors first</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (connectors[i] <span class="keyword">instanceof</span> Lifecycle)</div><div class="line">                    ((Lifecycle) connectors[i]).stop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Stop our defined Container second</span></div><div class="line">        <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (container) &#123;</div><div class="line">                <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Lifecycle) &#123;</div><div class="line">                    ((Lifecycle) container).stop();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Invoke a pre-startup initialization. This is used to allow connectors</div><div class="line">     * to bind to restricted ports under Unix operating environments.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">throws</span> LifecycleException &#123;</div><div class="line">        <span class="keyword">if</span> (initialized)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException (</div><div class="line">                sm.getString(<span class="string">"standardService.initialize.initialized"</span>));</div><div class="line">        initialized = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Initialize our defined Connectors</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                    connectors[i].initialize();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中只保留了有关<code>Lifecycle</code>接口的方法实现。看看<code>Lifecycle</code>接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</div><div class="line">    <span class="comment">// ----------------------------------------------------- Manifest Constants</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component start" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String START_EVENT = <span class="string">"start"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component before start" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_START_EVENT = <span class="string">"before_start"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component after start" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_START_EVENT = <span class="string">"after_start"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component stop" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOP_EVENT = <span class="string">"stop"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component before stop" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE_STOP_EVENT = <span class="string">"before_stop"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The LifecycleEvent type for the "component after stop" event.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_STOP_EVENT = <span class="string">"after_stop"</span>;</div><div class="line">    <span class="comment">// --------------------------------------------------------- Public Methods</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a LifecycleEvent listener to this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to add</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the lifecycle listeners associated with this lifecycle. If this </div><div class="line">     * Lifecycle has no listeners registered, a zero-length array is returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove a LifecycleEvent listener from this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to remove</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Prepare for the beginning of active use of the public methods of this</div><div class="line">     * component.  This method should be called before any of the public</div><div class="line">     * methods of this component are utilized.  It should also send a</div><div class="line">     * LifecycleEvent of type START_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that prevents this component from being used</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Gracefully terminate the active use of the public methods of this</div><div class="line">     * component.  This method should be the last one called on a given</div><div class="line">     * instance of this component.  It should also send a LifecycleEvent</div><div class="line">     * of type STOP_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that needs to be reported</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了定义两个动作<code>start</code>和<code>stop</code>外，还定义了一系列常量。当然还有对监听器的操作：添加、查找和移除。监听器可以说是观察者模式中的订阅者，它向感兴趣的事件注册，等事件发生的时候它获得通知。这个模型在Tomcat中可以这样解释：某个监听器对<code>start</code>事件感兴趣，因此对某个生命周期组件注册了，当<code>start</code>事件发生了，这个监听器获得通知，响应的代码被执行。可能用语言不好解释清楚，看代码是最好理解的了。<br>单独去看看<code>StandardService</code>中的生命周期方法<code>start()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Prepare for the beginning of active use of the public methods of this</div><div class="line">     * component.  This method should be called before any of the public</div><div class="line">     * methods of this component are utilized.  It should also send a</div><div class="line">     * LifecycleEvent of type START_EVENT to any registered listeners.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@exception</span> LifecycleException if this component detects a fatal error</div><div class="line">     *  that prevents this component from being used</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Validate and update our current component state</span></div><div class="line">        <span class="keyword">if</span> (started) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException</div><div class="line">                (sm.getString(<span class="string">"standardService.start.started"</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        System.out.println</div><div class="line">            (sm.getString(<span class="string">"standardService.start.name"</span>, <span class="keyword">this</span>.name));</div><div class="line">        lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Container first</span></div><div class="line">        <span class="comment">// 调用子组件的生命周期方法</span></div><div class="line">        <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (container) &#123;</div><div class="line">                <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Lifecycle) &#123;</div><div class="line">                    ((Lifecycle) container).start();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Start our defined Connectors second</span></div><div class="line">        <span class="keyword">synchronized</span> (connectors) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; connectors.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (connectors[i] <span class="keyword">instanceof</span> Lifecycle)</div><div class="line">                    ((Lifecycle) connectors[i]).start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Notify our interested LifecycleListeners</span></div><div class="line">        lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我想这段代码中最惹人注意的地方肯定是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, <span class="keyword">null</span>);</div><div class="line">lifecycle.fireLifecycleEvent(START_EVENT, <span class="keyword">null</span>);</div><div class="line">lifecycle.fireLifecycleEvent(AFTER_START_EVENT, <span class="keyword">null</span>);</div></pre></td></tr></table></figure></p>
<p>我觉得其他的都可以忽略，仅仅关心这三行就够了。正如<code>Lifecycle</code>接口中常量描述的一样，<code>start</code>对应开始前，开始和开始后三个状态。因此在调用<code>start</code>的时候将这个三个事件顺序触发，那么谁去接收这几个事件呢？这就得问问我们之前说的监听器了。这里还有一个细节值得注意：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> LifecycleSupport lifecycle = <span class="keyword">new</span> LifecycleSupport(<span class="keyword">this</span>);</div></pre></td></tr></table></figure></p>
<p>这也是生命周期方法的直接调用者。由此引出一个问题：我直接实现了<code>Lifecycle</code>接口不就完了，里面的方法自己实现就行了，干嘛还得引入这个东西再去调用一次？这个就体现一种设计思想：设想一下，加入每个组件都自己去实现一次，但是很多代码都是类似的，这样就造成了很多冗余代码，维护起来很要命。不信可以看看这个<code>LifecycleSupport</code>具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleSupport</span> </span>&#123;</div><div class="line">    <span class="comment">// ----------------------------------------------------------- Constructors</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Construct a new LifecycleSupport object associated with the specified</div><div class="line">     * Lifecycle component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lifecycle The Lifecycle component that will be the source</div><div class="line">     *  of events that we fire</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleSupport</span><span class="params">(Lifecycle lifecycle)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ----------------------------------------------------- Instance Variables</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The source component for lifecycle events that we will fire.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Lifecycle lifecycle = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The set of registered LifecycleListeners for event notifications.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LifecycleListener listeners[] = <span class="keyword">new</span> LifecycleListener[<span class="number">0</span>];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// --------------------------------------------------------- Public Methods</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Add a lifecycle event listener to this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to add</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">          LifecycleListener results[] =</div><div class="line">            <span class="keyword">new</span> LifecycleListener[listeners.length + <span class="number">1</span>];</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++)</div><div class="line">              results[i] = listeners[i];</div><div class="line">          results[listeners.length] = listener;</div><div class="line">          listeners = results;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the lifecycle listeners associated with this lifecycle. If this </div><div class="line">     * Lifecycle has no listeners registered, a zero-length array is returned.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> LifecycleListener[] findLifecycleListeners() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> listeners;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Notify all lifecycle event listeners that a particular event has</div><div class="line">     * occurred for this Container.  The default implementation performs</div><div class="line">     * this notification synchronously using the calling thread.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> type Event type</div><div class="line">     * <span class="doctag">@param</span> data Event data</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(lifecycle, type, data);</div><div class="line">        LifecycleListener interested[] = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">            interested = (LifecycleListener[]) listeners.clone();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interested.length; i++)</div><div class="line">            interested[i].lifecycleEvent(event);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove a lifecycle event listener from this component.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener The listener to remove</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">            <span class="keyword">int</span> n = -<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (listeners[i] == listener) &#123;</div><div class="line">                    n = i;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            LifecycleListener results[] =</div><div class="line">              <span class="keyword">new</span> LifecycleListener[listeners.length - <span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (i != n)</div><div class="line">                    results[j++] = listeners[i];</div><div class="line">            &#125;</div><div class="line">            listeners = results;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是对<code>Lifecycle</code>的部分方法的实现，这些方法一般是不会变化的，因此单独抽离出来，假如以后想改动也仅仅对这个类去改，而不是针对每个生命周期组件去改。</p>
<p>我觉得有个地方很值得借鉴：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLifecycleListener</span><span class="params">(LifecycleListener listener)</span> </span>&#123;</div><div class="line">      <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">          LifecycleListener results[] =</div><div class="line">            <span class="keyword">new</span> LifecycleListener[listeners.length + <span class="number">1</span>];</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listeners.length; i++)</div><div class="line">              results[i] = listeners[i];</div><div class="line">          results[listeners.length] = listener;</div><div class="line">          listeners = results;</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>假如是我去写这个接口我首先不会想到用数组去装<code>listeners</code>，我可能会使用一个<code>list</code>去存，这样进行添加的时候不会有这么复杂的操作。但是这里使用的是数组来处理，却达到了同样的效果。不得不佩服底层代码对这些细节的考虑。</p>
<p>继续接着那三行代码，看看具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireLifecycleEvent</span><span class="params">(String type, Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">        LifecycleEvent event = <span class="keyword">new</span> LifecycleEvent(lifecycle, type, data);</div><div class="line">        LifecycleListener interested[] = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">synchronized</span> (listeners) &#123;</div><div class="line">            interested = (LifecycleListener[]) listeners.clone();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interested.length; i++)</div><div class="line">            interested[i].lifecycleEvent(event);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>一眼往去，无非就是触发监听器感兴趣的事件，而且是挨个来。这里有一个<code>LifecycleEvent</code>类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleEvent</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">EventObject</span> &#123;</div><div class="line">    <span class="comment">// ----------------------------------------------------------- Constructors</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Construct a new LifecycleEvent with the specified parameters.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lifecycle Component on which this event occurred</div><div class="line">     * <span class="doctag">@param</span> type Event type (required)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleEvent</span><span class="params">(Lifecycle lifecycle, String type)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>(lifecycle, type, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Construct a new LifecycleEvent with the specified parameters.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lifecycle Component on which this event occurred</div><div class="line">     * <span class="doctag">@param</span> type Event type (required)</div><div class="line">     * <span class="doctag">@param</span> data Event data (if any)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifecycleEvent</span><span class="params">(Lifecycle lifecycle, String type, Object data)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(lifecycle);</div><div class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ----------------------------------------------------- Instance Variables</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The event data associated with this event.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Object data = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The Lifecycle on which this event occurred.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Lifecycle lifecycle = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The event type this instance represents.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String type = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ------------------------------------------------------------- Properties</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the event data of this event.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.data);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the Lifecycle on which this event occurred.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.lifecycle);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the event type of this event.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.type);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类继承了JDK中的<code>EventObject</code>，不用去管它。从构造器中可以看到有三个参数：生命周期对象，类型以及数据。有了这几个属性，这个生命周期事件对象可以放心去玩了。具体怎么去玩呢，和谁一起玩呢？这个得问问监听器了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleListener</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Acknowledge the occurrence of the specified event.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> event LifecycleEvent that has occurred</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>fireLifecycleEvent(String type, Object data)</code>方法中有这么个调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LifecycleListener interested[] = <span class="keyword">null</span>;</div><div class="line">...</div><div class="line">interested[i].lifecycleEvent(event);</div></pre></td></tr></table></figure></p>
<p>事件传给监听器了！<br>监听器拿到生命周期事件，由于事件中的数据全都有：当前生命周期对象、生命周期类型及携带的数据，因此监听器可以想怎么玩就怎么玩。演示一下怎么玩：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Lifecycle.START_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============START_EVENT================="</span>);</div><div class="line">      Context context = (Context) event.getLifecycle();</div><div class="line">      context.setConfigured(<span class="keyword">true</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Lifecycle.BEFORE_START_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============BEFORE_START_EVENT================="</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Lifecycle.BEFORE_STOP_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============BEFORE_STOP_EVENT=================="</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Lifecycle.STOP_EVENT.equals(event.getType())) &#123;</div><div class="line">    	System.out.println(<span class="string">"==============STOP_EVENT=================="</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以说是简单到无聊。<br>忘了一点，事件监听得注册上去，不然事件发生了没法响应：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LifecycleListener listener = <span class="keyword">new</span> ContextConfig();</div><div class="line">((Lifecycle) context).addLifecycleListener(listener);</div></pre></td></tr></table></figure></p>
<p>多添加几个也无妨，只要你想。<br>Tomcat中给我印象最深刻的也就是Lifecycle观察者模式。相比去找一些设计模式的栗子去学习，我觉得阅读优秀的源码要理解地更透彻一些。除了观察者模式还有其他的设计思想也值得学习，慢慢总结，不断更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书看了这么久，差不多可以算是看完了。准确来讲是还剩两个章节没有读完。最后那两个章节的的确确是很不得劲，也有可能是自己开始浮躁起来了。我看的是中文翻译的，可气的是中文翻译很多错别字不说，居然有些地方根本就没有翻译到，“缺斤少两”很可气。然后又找原版对照着看，避免被“误入歧途”。&lt;br&gt;
    
    </summary>
    
      <category term="Tomcat 笔记" scheme="http://www.wei-dong.top/categories/Tomcat-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Tomcat" scheme="http://www.wei-dong.top/tags/Tomcat/"/>
    
      <category term="读书笔记" scheme="http://www.wei-dong.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Securing Web Applications with Apache Shiro[译]</title>
    <link href="http://www.wei-dong.top/2017/10/26/Securing%20Web%20Applications%20with%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.wei-dong.top/2017/10/26/Securing Web Applications with Apache Shiro[译]/</id>
    <published>2017-10-26T12:41:23.000Z</published>
    <updated>2017-10-26T12:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是介绍使用Shiro一步一步保护你的web应用的教程。它包含了Shiro的知识，以及和最近两篇文章很相似：</p>
<ul>
<li><a href="https://www.infoq.com/articles/apache-shiro" target="_blank" rel="external">Application Security with Apache Shiro</a></li>
<li><a href="http://shiro.apache.org/10-minute-tutorial.html" target="_blank" rel="external">Apache Shiro 10 Minute Tutorial</a><br>这个入门教程会花费大约45分钟到一个小时。当你读完后，你就会知道Shiro在web应用中怎么工作了的。<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3></li>
<li>概括</li>
<li>设置</li>
<li>第一步：开启Shiro</li>
<li>第二步：连接到用户存储</li>
<li>第三步：开启登录和登出</li>
<li>第四步：改变用户指定UI</li>
<li>第五步：仅仅允许认证用户访问</li>
<li>第六步：基于角色访问控制</li>
<li>第七步：基于权限访问控制</li>
</ul>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>虽然Shiro设计的核心目标可以用于保护任何基于JVM的应用，例如命令行应用，后台服务，网页应用等。这篇文章专注最常见的应用：保护跑在Servlet容器上的web应用，例如Tomca或者Jetty。</p>
<h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>下面的工具是要安装到你本地开发机器上的，以便遵循本教程。</p>
<ul>
<li>Git (tested w/ 1.7)</li>
<li>Java SDK 7</li>
<li>Maven 3</li>
<li>你自己喜欢的编辑器，IDEA或者Eclipse都行，甚至文本编辑器也行。</li>
</ul>
<h4 id="教程格式"><a href="#教程格式" class="headerlink" title="教程格式"></a>教程格式</h4><p>这是一步接着一步的教程。该教程和所有步骤都在GIT仓库中存着。当你clone git仓库，master分支就是你的起点。在这个教程中的每个步骤都是单独的分支。你可以通过检出你正在看的教程步骤的git分支来读这个教程（就是边看代码边读这个教程的意思）。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>我们将构建的Web应用程序是一个超级webapp，可以作为你自己的应用程序的起点。它将演示用户登录，注销，用户特定的欢迎消息，对Web应用程序的某些部分的访问控制以及与可插拔安全数据存储的集成。</p>
<p>我们将首先设置项目，包括构建工具和声明依赖关系，以及配置servlet web.xml文件以启动Web应用程序和Shiro环境。</p>
<p>完成设置后，我们将分层单独的功能，包括与安全数据存储集成，然后启用用户登录，注销和访问控制。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>我们已经在git仓库中设置完成了，因此你不必手动去设置目录结构初始化文件等。</p>
<h4 id="1-Fork-the-tutorial-project"><a href="#1-Fork-the-tutorial-project" class="headerlink" title="1. Fork the tutorial project"></a>1. Fork the tutorial project</h4><p>在github中访问<a href="https://github.com/lhazlewood/apache-shiro-tutorial-webapp" target="_blank" rel="external">这个</a>，点击<code>fork</code>按钮。</p>
<h4 id="2-Clone-your-tutorial-repository"><a href="#2-Clone-your-tutorial-repository" class="headerlink" title="2. Clone your tutorial repository"></a>2. Clone your tutorial repository</h4><p>现在你把那个仓库fork到你自己的账号中去了，clone到你自己的机器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git@github.com:<span class="variable">$YOUR_GITHUB_USERNAME</span>/apache-shiro-tutorial-webapp.git</div></pre></td></tr></table></figure></p>
<h4 id="3-Review-project-structure"><a href="#3-Review-project-structure" class="headerlink" title="3. Review project structure"></a>3. Review project structure</h4><p>完成clone后，你当前的<code>master</code>分支将有下面的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">apache-shiro-tutorial-webapp/</div><div class="line">     |-- src/</div><div class="line">     |  |-- main/</div><div class="line">     |    |-- resources/</div><div class="line">     |      |-- logback.xml</div><div class="line">     |    |-- webapp/</div><div class="line">     |      |-- WEB-INF/</div><div class="line">     |        |-- web.xml</div><div class="line">     |      |-- home.jsp</div><div class="line">     |      |-- include.jsp</div><div class="line">     |      |-- index.jsp</div><div class="line">     |-- .gitignore</div><div class="line">     |-- .travis.yml</div><div class="line">     |-- LICENSE</div><div class="line">     |-- README.md</div><div class="line">     |-- pom.xml</div></pre></td></tr></table></figure></p>
<p>这些是每个文件表示的含义：</p>
<ul>
<li>pom.xml 不解释</li>
<li>README.md 描述文件</li>
<li>LICENSE 证书</li>
<li>.travis.yml CI的配置文件，假如你想持续集成</li>
<li>.gitignore 忽略文件，包含后缀。你不想加入版本控制的都能写这里</li>
<li>src/main/resources/logback.xml 简单的Logback配置文件，在这个教程中，我们选择SELF4J作为日志API，Logback作为实现。这个比Log4J和JUL简单。</li>
<li>src/main/webapp/WEB-INF/web.xml web配置文件</li>
<li>src/main/webapp/include.jsp  公用的JSP文件，用于导入和声明。方便在一个地方管理。</li>
<li>src/main/webapp/home.jsp 默认的homepage</li>
<li>src/main/webapp/index.jsp 默认主页，仅仅是将请求指向home.jsp</li>
</ul>
<h4 id="4-Run-the-webapp"><a href="#4-Run-the-webapp" class="headerlink" title="4. Run the webapp"></a>4. Run the webapp</h4><p>现在你将工程克隆到本地了，你可以通过使用一下命令来跑这个web应用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>然后打开你的浏览器，输入 localhost:8080 你可以看到主页显示的Hello，World！按ctl-c停止web。</p>
<h3 id="Step-1-Enable-Shiro"><a href="#Step-1-Enable-Shiro" class="headerlink" title="Step 1: Enable Shiro"></a>Step 1: Enable Shiro</h3><p>我们初始化仓库master分支仅仅是一个简单通用的可用于任何应用的模板的web应用。Let’s add the bare minimum to enable Shiro in the web app next(这句话不知道怎么翻译)。</p>
<p>执行下面的git检出命令加载step1的分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step1</div></pre></td></tr></table></figure></p>
<p>检出后你会发现两个变化：</p>
<ol>
<li>多了<code>src/main/webapp/WEB-INF/shiro.ini</code>这个文件</li>
<li><code>src/main/webapp/WEB-INF/web.xml</code>被改了</li>
</ol>
<h4 id="添加shiro-ini文件"><a href="#添加shiro-ini文件" class="headerlink" title="添加shiro.ini文件"></a>添加shiro.ini文件</h4><p>在web应用中油很多种方式配置Shiro，这取决于你使用的是什么web框架。例如，你可以通过Spring、Guice、Tapestry等配置Shiro。</p>
<p>现在为了方便，我们将使用Shiro默认的配置,<a href="http://shiro.apache.org/configuration.html" target="_blank" rel="external">基于ini的配置</a>。</p>
<p>如果你检出了step1的分支，你可以看到这个新的配置文件<code>src/main/webapp/WEB-INF/shiro.ini</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line"></div><div class="line"># Let&apos;s use some in-memory caching to reduce the number of runtime lookups against a remote user store.</div><div class="line"># A real application might want to use a more robust caching solution (e.g. ehcache or a</div><div class="line"># distributed cache).  When using such caches, be aware of your cache TTL settings: too high</div><div class="line"># a TTL and the cache won&apos;t reflect any potential changes in Stormpath fast enough.  Too low</div><div class="line"># and the cache could evict too often, reducing performance.</div><div class="line">cacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager</div><div class="line">securityManager.cacheManager = $cacheManager</div></pre></td></tr></table></figure></p>
<p>这个ini配置文件包含一个<code>[main]</code>的最小配置。</p>
<ul>
<li>定义了一个<code>cacheManager</code>实例。缓存在Shiro架构中是一个很重要的部分。它减少了重复的数据交互。这个例子使用<code>MemoryConstrainedCacheManager</code>，仅仅对单个JVM应用很棒。如果你的应用部署在多个主机，你最好使用集群的CacheManager 实现。</li>
<li>它在Shiro securityManager上配置新的cacheManager实例。Shiro SecurityManager实例始终存在，因此不需要明确定义。</li>
</ul>
<h4 id="在web-xml中开启Shiro"><a href="#在web-xml中开启Shiro" class="headerlink" title="在web.xml中开启Shiro"></a>在web.xml中开启Shiro</h4><p>虽然我们有shiro.ini配置文件，但是我们确实需要把它加载进去然后开启Shiro环境让web应用能够使用它。</p>
<p>我们在<code>src/main/webapp/WEB-INF/web.xml</code>配置文件中添加这些东西：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.apache.shiro.web.env.EnvironmentLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.shiro.web.servlet.ShiroFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ShiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>INCLUDE<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ul>
<li><code>&lt;listener&gt;</code>声明定义了一个<code>ServletContextListener</code>用于在web用于启动的时候创建一个Shiro环境。默认这个listener会去自动找<code>WEB-INF/shiro.ini</code>配置文件。</li>
<li><code>&lt;filter&gt;</code>定义了一个主要的<code>ShiroFilter</code>。这个过滤器会去过滤所有的请求，这样Shiro能够在允许请求到达应用程序之前执行必要的身份和访问控制操作。</li>
</ul>
<h4 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h4><p>拉去了分支后，继续跑起来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>这个时候，你会看到下面熟悉的输出，这表示Shiro确实在你的web应用中跑起来了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">16:04:19.807 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Starting Shiro environment initialization.</div><div class="line">16:04:19.904 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Shiro environment initialized in 95 ms.</div></pre></td></tr></table></figure></p>
<h3 id="Step-2-Connect-to-a-User-Store"><a href="#Step-2-Connect-to-a-User-Store" class="headerlink" title="Step 2: Connect to a User Store"></a>Step 2: Connect to a User Store</h3><p>执行下面的命令检出step2的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step2</div></pre></td></tr></table></figure></p>
<p>现在我们将Shiro集成并运行在webapp中.但是我们还没有告诉Shiro要做什么事情。</p>
<p>在我们登录，退出或执行基于角色或权限的访问控制或任何其他安全相关之前，我们需要用户！</p>
<p>我们需要配置Shiro来访问某种类型的用户存储，这样它可以查找用户做登录操作或者检查角色等等。有许多类型的用户存储，任何应用程序可能需要访问：也许你将用户存在MySql数据库中，或者MongoDB，或者LDAP，或者Active Directory，或者简单的文件中。</p>
<p>Shiro将这叫做<code>Realm</code>.来自Shiro的文档：</p>
<blockquote>
<p>Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application.<br>In this sense a Realm is essentially a security-specific DAO: it encapsulates connection details for data sources and makes the associated data available to Shiro as needed. When configuring Shiro, you must specify at least one Realm to use for authentication and/or authorization. The SecurityManager may be configured with multiple Realms, but at least one is required.<br>Shiro provides out-of-the-box Realms to connect to a number of security data sources (aka directories) such as LDAP, relational databases (JDBC), text configuration sources like INI and properties files, and more. You can plug-in your own Realm implementations to represent custom data sources if the default Realms do not meet your needs.</p>
</blockquote>
<p>因此我们需要配置一个<code>realm</code>这样我们就能够得到用户了。</p>
<h4 id="Set-up-Stormpath"><a href="#Set-up-Stormpath" class="headerlink" title="Set up Stormpath"></a>Set up Stormpath</h4><p>本着越简单越好的原则，没有介绍Shiro的复杂性，我们使用一个最简单的realm的实现：Stormpath realm。</p>
<p>Stormpath 是一个云平台上的用户管理服务。对开发者免费。这意味着使用了Stormpath以后，帮你做了做以下的事情：</p>
<ul>
<li>一个用于管理应用，目录、账户、和组的接口。Shiro根本不提供这些东西，因此当你浏览这篇教程的时候能够节约时间，这是很方便的。</li>
<li>一个为用户存储密码的安全机制。你的应用不必担心密码安全，密码比较或存储密码。虽然Shiro能做这些事情，但是你有必要去配置一下，然后注意一下加密的概念。 Stormpath自动的对密码进行保护，因此你不必担心这些东西。</li>
<li>安全的工作流，类似于邮箱验证密码重置。Shiro对此没有任何支持，因为这是应用程序来把控的。</li>
<li>主机托管总是在基础设施上的（云平台），你没有必要来维护这些东西。</li>
</ul>
<p>为了本教程的目的，Stormpath比设置单独的RDBMS服务器要简单得多，并且担心SQL或密码加密问题。</p>
<p>当然，Stormpath只是Shiro可以进行沟通的许多后端数据存储之一。 稍后将介绍更复杂的数据存储和应用程序特定的配置。</p>
<h5 id="Sign-up-for-Stormpath"><a href="#Sign-up-for-Stormpath" class="headerlink" title="Sign up for Stormpath"></a>Sign up for Stormpath</h5><p>blabla…..</p>
<h5 id="Get-a-Stormpath-API-Key"><a href="#Get-a-Stormpath-API-Key" class="headerlink" title="Get a Stormpath API Key"></a>Get a Stormpath API Key</h5><p>Stormpath API Key对于Stormpath来说是必须的。可以这样获取：</p>
<ol>
<li>登录到Stormpath中（这个网站关了，合并到okta）。</li>
<li>页面的右边，访问API KEY：Manage API KEY</li>
<li><p>在账号详情页面，点击Create API Key。此时会生成你的API key，然后下载到你的电脑。如果你打开看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apiKey.id = 144JVZINOF5EBNCMG9EXAMPLE</div><div class="line">apiKey.secret = lWxOiKqKPNwJmSldbiSkEbkNjgh2uRSNAb+AEXAMPLE</div></pre></td></tr></table></figure>
</li>
<li><p>保存到一个安全的地方，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$HOME/.stormpath/apiKey.properties</div></pre></td></tr></table></figure>
</li>
<li><p>当然也可以改一下这个文件的权限。例如在*nix下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chmod go-rwx <span class="variable">$HOME</span>/.stormpath/apiKey.properties</div><div class="line">$ chmod u-w <span class="variable">$HOME</span>/.stormpath/apiKey.properties</div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="Retrieve-the-default-Stormpath-Application"><a href="#Retrieve-the-default-Stormpath-Application" class="headerlink" title="Retrieve the default Stormpath Application"></a>Retrieve the default Stormpath Application</h5><p>当你登录到Stormpath，自动的创建了一个空的应用，名字叫做：<code>My Application</code></p>
<p>我们必须使用Strompath注册我们的web应用，这样就能使用Strompath来管理我们的用户和对用户授权。为了使用我的应用程序Stormpath应用程序注册我们的Web应用程序，我们需要了解一些信息。幸运的是，我们可以使用Stormpath API来检索这些信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -i --user <span class="variable">$YOUR_API_KEY_ID</span>:<span class="variable">$YOUR_API_KEY_SECRET</span> \</div><div class="line"><span class="string">'https://api.stormpath.com/v1/tenants/current'</span></div></pre></td></tr></table></figure></p>
<p>你能得到这些返回信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 302 Found</div><div class="line">Date: Fri, 28 Aug 2015 18:34:51 GMT</div><div class="line">Location: https://api.stormpath.com/v1/tenants/sOmELoNgRaNDoMIdHeRe</div><div class="line">Server: Apache</div><div class="line">Set-Cookie: rememberMe=deleteMe; Path=/; Max-Age=0; Expires=Thu, 27-Aug-2015 18:34:52 GMT</div><div class="line">Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</div><div class="line">Content-Length: 0</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure></p>
<p>注意到<code>Location</code>，这个就是你的Stormpath tenant.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -u <span class="variable">$API_KEY_ID</span>:<span class="variable">$API_KEY_SECRET</span> \</div><div class="line">     -H <span class="string">"Accept: application/json"</span> \</div><div class="line">     <span class="string">'$TENANT_HREF/applications?name=My%20Application'</span></div></pre></td></tr></table></figure></p>
<p>这个回应有很多的信息。 这是一个从响应中摘录的例子.<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    "href": "https://api.stormpath.com/v1/applications/aLoNGrAnDoMAppIdHeRe",</div><div class="line">    "name": "My Application",</div><div class="line">    "description": "This application was automatically created for you in Stormpath for use with our Quickstart guides(https://docs.stormpath.com). It does apply to your subscription's number of reserved applications and can be renamed or reused for your own purposes.",</div><div class="line">    "status": "ENABLED",</div><div class="line">    "tenant": &#123;</div><div class="line">        "href": "https://api.stormpath.com/v1/tenants/sOmELoNgRaNDoMIdHeRe"</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面注意你的最上面的<code>href</code>，接下来我们将在shiro.ini配置中使用这个<code>href</code>。</p>
<h5 id="Create-an-application-test-user-account"><a href="#Create-an-application-test-user-account" class="headerlink" title="Create an application test user account"></a>Create an application test user account</h5><p>现在我们有一个应用程序，我们将要为该应用程序创建一个示例/测试用户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">curl --request POST --user <span class="variable">$YOUR_API_KEY_ID</span>:<span class="variable">$YOUR_API_KEY_SECRET</span> \</div><div class="line">    -H <span class="string">"Accept: application/json"</span> \</div><div class="line">    -H <span class="string">"Content-Type: application/json"</span> \</div><div class="line">    <span class="_">-d</span> <span class="string">'&#123;</span></div><div class="line">           "givenName": "Jean-Luc",</div><div class="line">           "surname": "Picard",</div><div class="line">           "username": "jlpicard",</div><div class="line">           "email": "capt@enterprise.com",</div><div class="line">           "password":"Changeme1"</div><div class="line">        &#125;' \</div><div class="line"> <span class="string">"<span class="variable">$YOUR_APPLICATION_HREF</span>/accounts"</span></div></pre></td></tr></table></figure></p>
<h4 id="Configure-the-Realm-in-shiro-ini"><a href="#Configure-the-Realm-in-shiro-ini" class="headerlink" title="Configure the Realm in shiro.ini"></a>Configure the Realm in shiro.ini</h4><p>按照Shiro的要求，你选择至少一个用户存储的连接，我们将需要配置一个表示该数据存储的域，然后告诉Shiro SecurityManager。</p>
<p>如果你检出step2的分支，你会看到<code>src/main/webapp/WEB-INF/shiro.ini</code>中的[main]部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># Configure a Realm to connect to a user datastore.  In this simple tutorial, we&apos;ll just point to Stormpath since it</div><div class="line"># takes 5 minutes to set up:</div><div class="line">stormpathClient = com.stormpath.shiro.client.ClientFactory</div><div class="line">stormpathClient.cacheManager = $cacheManager</div><div class="line"></div><div class="line"># (Optional) If you put your apiKey.properties in the non-default location, you set the location here</div><div class="line">#stormpathClient.apiKeyFileLocation = $HOME/.stormpath/apiKey.properties</div><div class="line"></div><div class="line">stormpathRealm = com.stormpath.shiro.realm.ApplicationRealm</div><div class="line">stormpathRealm.client = $stormpathClient</div><div class="line"></div><div class="line"># Find this URL in your Stormpath console for an application you create:</div><div class="line"># Applications -&gt; (choose application name) --&gt; Details --&gt; REST URL</div><div class="line"># (Optional) If you only have one Application</div><div class="line">#stormpathRealm.applicationRestUrl = https://api.stormpath.com/v1/applications/$STORMPATH_APPLICATION_ID</div><div class="line"></div><div class="line">stormpathRealm.groupRoleResolver.modeNames = name</div><div class="line">securityManager.realm = $stormpathRealm</div></pre></td></tr></table></figure></p>
<p>注意看可选的那行：</p>
<ul>
<li>如果你已经使用Stormpath一段时间，并且你有更多的Stormpath应用程序，<code>stormpathRealm.applicationRestUrl</code>这个属性必须被设置。</li>
</ul>
<h4 id="Run-the-webapp"><a href="#Run-the-webapp" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>在完成上面的改动后，使用下面的命令来跑一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<p>这时候就会看到熟悉的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">16:08:25.466 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Starting Shiro environment initialization.</div><div class="line">16:08:26.201 [main] INFO  o.a.s.c.IniSecurityManagerFactory - Realms have been explicitly set on the SecurityManager instance - auto-setting of realms will not occur.</div><div class="line">16:08:26.201 [main] INFO  o.a.shiro.web.env.EnvironmentLoader - Shiro environment initialized in 731 ms.</div></pre></td></tr></table></figure></p>
<h3 id="Step-3-Enable-Login-and-Logout"><a href="#Step-3-Enable-Login-and-Logout" class="headerlink" title="Step 3: Enable Login and Logout"></a>Step 3: Enable Login and Logout</h3><p>现在我们有用户，而且我们能很容易的添加，移除和禁用他们。现在我们可以在我们的应用程序中开始启用登录/注销和访问控制等功能。</p>
<p>检出step3的分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step3</div></pre></td></tr></table></figure></p>
<p>添加了2个东西:</p>
<ul>
<li><code>src/main/webapp/login.jsp</code>中加了一个简单的登录表单，我们使用它登录。</li>
<li><code>shiro.ini</code>文件已更新，以支持Web（URL）特定功能。</li>
</ul>
<h4 id="Enable-Shiro-form-login-and-logout-support"><a href="#Enable-Shiro-form-login-and-logout-support" class="headerlink" title="Enable Shiro form login and logout support"></a>Enable Shiro form login and logout support</h4><p>step3中<code>src/main/webapp/WEB-INF/shiro.ini</code>添加了下面2个东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line"></div><div class="line">shiro.loginUrl = /login.jsp</div><div class="line"></div><div class="line"># Stuff we&apos;ve configured here previously is omitted for brevity</div><div class="line"></div><div class="line">[urls]</div><div class="line">/login.jsp = authc</div><div class="line">/logout = logout</div></pre></td></tr></table></figure></p>
<p>在[main]这个部分多了一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shiro.loginUrl = /login.jsp</div></pre></td></tr></table></figure></p>
<p>这是一个告诉Shiro的特殊配置指令:”对于任何具有loginUrl属性的Shiro的默认过滤器，我希望该属性值设置为/login.jsp。”</p>
<p>这个就是让Shiro的默认认证过滤器（默认的是FormAuthenticationFilter）知道登录页面是哪个。这个让FormAuthenticationFilter正确的工作是很有必要的。</p>
<p>[urls]部分允许你使用非常简洁的键值对语法来告诉Shiro怎么样去过滤给定的url请求。urls中的所有路径都是相对于Web应用程序的HttpServletRequest.getContextPath()的值.</p>
<p>这些键值对提供一个极其强大的方式来过滤请求，允许各种各样的安全规则。URL和过滤器链的更深入的覆盖范围超出了本文档的范围，但如果你有兴趣，请详细阅读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/login.jsp = authc</div><div class="line">/logout = logout</div></pre></td></tr></table></figure>
<ul>
<li>第一行指出不论Shiro什么时候遇到请求<code>/login.jsp</code>的url，在请求中开启authc过滤器。</li>
<li>第二行表示不论Shiro遇到<code>/login.jsp</code>的url，在请求中开启logout 过滤器。</li>
</ul>
<p>这两个过滤器都有一点特殊的地方，他们都不需要在背后进行额外的处理。它们实际上只是完全处理请求，而不是过滤。这意味着你对这些URL的请求没有任何要求，不需要写任何controller。Shiro将根据需要处理这些请求。</p>
<h4 id="Add-a-login-page"><a href="#Add-a-login-page" class="headerlink" title="Add a login page"></a>Add a login page</h4><p>在上个步骤中我们开启了对登录和登出的支持。现在我们需要保证有一个<code>/login.jsp</code>页面来显示登录表单。</p>
<p>step3的分支中包含<code>src/main/webapp/login.jsp</code>页面。这是一个简单的bootstrap主题的登录页面，但是依旧有四点需要注意：</p>
<ul>
<li>这个表单的<code>action</code>值是空的字符串。当表单中没有<code>action</code>值，浏览器将提交请求到同一个URL。这很好，因为我们会告诉Shiro那个URL很短，所以Shiro可以自动处理任何登录提交。<code>/login.jsp = authc</code>这行是告诉authc过滤器处理这个提交。</li>
<li>有一个<code>username</code>字段，Shiro authc过滤器将在登录提交期间自动查找用户名请求参数，并将其用作登录期间的值（许多域允许此为电子邮件或用户名）。</li>
<li>有一个<code>password</code>字段，Shiro authc过滤器将在登录提交期间自动查找密码请求参数。</li>
<li>有一个rememberMe复选框，其“checked”状态可以是“true”值（true，t，1，enabled，y，yes或on）。</li>
</ul>
<p>我们的login.jsp表单只使用默认的用户名，密码和rememberMe表单字段名称。 如果您想更改这些名称，这些名称是可配置的。参见<a href="http://shiro.apache.org/static/1.3.2/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html" target="_blank" rel="external">FormAuthenticationFilter</a>.</p>
<h4 id="Run-the-webapp-1"><a href="#Run-the-webapp-1" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>再跑一次：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mvn jetty:run</div></pre></td></tr></table></figure></p>
<h4 id="Try-to-Login"><a href="#Try-to-Login" class="headerlink" title="Try to Login"></a>Try to Login</h4><p>使用您的Web浏览器，导航到localhost：8080 / login.jsp，您将看到我们新的登录表单。</p>
<p>输入你在步骤2结束时创建的帐户的用户名和密码，然后点击“登录”。 如果登录成功，你将被引导到主页！ 如果登录失败，你将再次显示登录页面。</p>
<p>提示：如果你希望成功登录将用户重定向到主页（上下文路径/）以外的其他页面，则可以在INI的main部分中设置authc.successUrl = / any。</p>
<h3 id="Step-4-User-specific-UI-changes"><a href="#Step-4-User-specific-UI-changes" class="headerlink" title="Step 4: User-specific UI changes"></a>Step 4: User-specific UI changes</h3><p>通常需要根据用户是谁来更改web用户界面。我们可以很容易地做到这一点，因为Shiro支持JSP标签库根据当前登录的Subject（用户）进行操作。</p>
<p>检出step4的分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step4</div></pre></td></tr></table></figure></p>
<p>在<code>home.jsp</code>页面中新增了：</p>
<ul>
<li>当浏览该页面的当前用户未登录时，他们将看到一个“欢迎访客”消息，并查看登录页面的链接。</li>
<li>当浏览该页面的当前用户登录后，他们将看到自己的名字“欢迎xxx”和一个链接以注销。</li>
</ul>
<p>这种类型的UI定制对于导航栏是非常常见的，用户控件位于屏幕的右上方。</p>
<h4 id="Add-the-Shiro-Tag-Library-Declaration"><a href="#Add-the-Shiro-Tag-Library-Declaration" class="headerlink" title="Add the Shiro Tag Library Declaration"></a>Add the Shiro Tag Library Declaration</h4><p>在<code>home.jsp</code>顶部包含了这两行：<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">"http://shiro.apache.org/tags"</span> %&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"c"</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span></div></pre></td></tr></table></figure></p>
<p>这两个JSP页面指令允许页面中的Core（c )和Shiro（shiro )标签库。</p>
<h4 id="Add-Shiro-Guest-and-User-tags"><a href="#Add-Shiro-Guest-and-User-tags" class="headerlink" title="Add Shiro Guest and User tags"></a>Add Shiro Guest and User tags</h4><p><code>home.jsp</code>文件进一步修改了body里的内容，以包含<shiro：guest>和<shiro：user>标签。<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi <span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span>Guest<span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span><span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%</span></span></div><div class="line">    //<span class="attr">This</span> <span class="attr">should</span> <span class="attr">never</span> <span class="attr">be</span> <span class="attr">done</span> <span class="attr">in</span> <span class="attr">a</span> <span class="attr">normal</span> <span class="attr">page</span> <span class="attr">and</span> <span class="attr">should</span> <span class="attr">exist</span> <span class="attr">in</span> <span class="attr">a</span> <span class="attr">proper</span> <span class="attr">MVC</span> <span class="attr">controller</span> <span class="attr">of</span> <span class="attr">some</span> <span class="attr">sort</span>, <span class="attr">but</span> <span class="attr">for</span> <span class="attr">this</span></div><div class="line">    //<span class="attr">tutorial</span>, <span class="attr">we</span>'<span class="attr">ll</span> <span class="attr">just</span> <span class="attr">pull</span> <span class="attr">out</span> <span class="attr">Stormpath</span> <span class="attr">Account</span> <span class="attr">data</span> <span class="attr">from</span> <span class="attr">Shiro</span>'<span class="attr">s</span> <span class="attr">PrincipalCollection</span> <span class="attr">to</span> <span class="attr">reference</span> <span class="attr">in</span> <span class="attr">the</span></div><div class="line">    //&lt;<span class="attr">c:out</span>/&gt; tag next:</div><div class="line"></div><div class="line">    request.setAttribute("account", org.apache.shiro.SecurityUtils.getSubject().getPrincipals().oneByType(java.util.Map.class));</div><div class="line"></div><div class="line">%&gt;</div><div class="line"><span class="tag">&lt;<span class="name">c:out</span> <span class="attr">value</span>=<span class="string">"$&#123;account.givenName&#125;"</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span>!</div><div class="line">    ( <span class="tag">&lt;<span class="name">shiro:user</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">logout</span>"/&gt;</span>"&gt;Log out<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:user</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:guest</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">login.jsp</span>"/&gt;</span>"&gt;Log in<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:guest</span>&gt;</span> )</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></shiro：user></shiro：guest></p>
<p>给定的格式有点难以阅读，但是在这里使用了两个标签：</p>
<ul>
<li><code>&lt;shiro:guest&gt;</code>这个标签仅仅显示它内部的内容，假如当前的subject是一个访客的话。Shiro将guest定义为未登录到应用程序的任何Subject，或者在之前登录没有被记住的用户。</li>
<li><code>&lt;shiro:user&gt;</code>Shiro将用户定义为当前登录到（认证）应用程序或从先前登录记录的主题的任何主题。</li>
</ul>
<p>如果subject是访客，上述代码段将呈现以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi Guest! (Log in)</div></pre></td></tr></table></figure></p>
<p>如果subject是“用户”，它将呈现以下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi jsmith! (Log out)</div></pre></td></tr></table></figure></p>
<p>你可以看到，您可以关闭整个页面部分，功能和UI组件。<br>除了这两个标签，Shiro还提供其他标签供你来定制你自己的UI。</p>
<h4 id="Run-the-webapp-2"><a href="#Run-the-webapp-2" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>跑吧！</p>
<h3 id="Step-5-Allow-Access-to-Only-Authenticated-Users"><a href="#Step-5-Allow-Access-to-Only-Authenticated-Users" class="headerlink" title="Step 5: Allow Access to Only Authenticated Users"></a>Step 5: Allow Access to Only Authenticated Users</h3><p>虽然你可以根据subject的状态来改变内容，但是通常情况下，你将要限制webapp的整个部分，这取决于有人在当前与Web应用程序的互动过程中是否已证明其身份（已验证）。</p>
<p>如果webapp的用户专区部分显示敏感信息（如帐单明细或控制其他用户的能力），这一点尤为重要。</p>
<p>检出step5：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step5</div></pre></td></tr></table></figure></p>
<p>Step 5有3个更新：</p>
<ul>
<li>添加了一个新的部分（url path），我们要限制只有经过身份验证的用户。</li>
<li>我们更改了shiro.ini，以告诉Shiro只允许经过身份验证的用户访问该Web应用程序的该部分。</li>
<li>我们修改了主页，根据当前的主题是否被认证来更改其输出。</li>
</ul>
<h4 id="Add-a-new-restricted-section"><a href="#Add-a-new-restricted-section" class="headerlink" title="Add a new restricted section"></a>Add a new restricted section</h4><p><code>src/main/webapp/account</code>目录被添加进来了。此目录（及其下方的所有路径）会模拟网站的“私有”或“仅验证”部分，你可能希望将其限制为只能登录用户。<code>src/main/webapp/account/index.jsp</code>文件只是模拟“主页”页面的占位符。</p>
<h4 id="Configure-shiro-ini"><a href="#Configure-shiro-ini" class="headerlink" title="Configure shiro.ini"></a>Configure shiro.ini</h4><p>在<code>shiro.ini</code>的<code>[urls]</code>这个章节的结尾，添加了下面的一行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/account/** = authc</div></pre></td></tr></table></figure></p>
<p>这个Shiro过滤器链定义意味着“对/ account（或其任何子路径）的任何请求必须被认证”。<br>但是，如果有人尝试访问该路径或其任何子路径，会发生什么？<br>你还记得在步骤3中,当我们将以下行添加到main部分吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shiro.loginUrl = /login.jsp</div></pre></td></tr></table></figure></p>
<p>这一行自动使用我们的webapp登录URL配置authc过滤器。<br>基于这一行配置，authc过滤器现在足够聪明，可以知道当访问/帐户当前主题未被验证时，它将自动将主题重定向到/login.jsp页面。成功登录后，它将自动将用户重定向到他们试图访问的页面（/帐户）。 很方便！</p>
<h4 id="Update-our-home-page"><a href="#Update-our-home-page" class="headerlink" title="Update our home page"></a>Update our home page</h4><p>步骤5的最终更改是更新/home.jsp页面，让用户知道他们可以访问网站的新部分。这些行被添加到欢迎消息下:<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">shiro:authenticated</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Visit your <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">account</span>"/&gt;</span>"&gt;account page<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">shiro:authenticated</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">shiro:notAuthenticated</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>If you want to access the authenticated-only <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">account</span>"/&gt;</span>"&gt;account page<span class="tag">&lt;/<span class="name">a</span>&gt;</span>, you will need to log-in first.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">shiro:notAuthenticated</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果当前的Subject在当前会话期间已经登录（认证），则<shiro：authenticated>标签内的内容被显示。这是Subject知道他们可以去访问网站的新部分。<br>如果当前Subject在当前会话期间尚未验证，则<shiro：notauthenticated>标签内的内容被显示。<br>但是你注意到了吗，未经身份验证的内容仍然具有/ account部分的URL？没关系 - 我们的authc过滤器将如上所述处理login-and-then-redirect流程。<br>用新的更改启动webapp并尝试一下！</shiro：notauthenticated></shiro：authenticated></p>
<h4 id="Run-the-webapp-3"><a href="#Run-the-webapp-3" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>跑一下吧。</p>
<h3 id="Step-6-Role-Based-Access-Control"><a href="#Step-6-Role-Based-Access-Control" class="headerlink" title="Step 6: Role-Based Access Control"></a>Step 6: Role-Based Access Control</h3><p>除了基于身份验证控制访问之外，还经常需要根据分配给当前主体的角色来限制对应用程序某些部分的访问。<br>检出代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout step6</div></pre></td></tr></table></figure></p>
<h4 id="Add-Roles"><a href="#Add-Roles" class="headerlink" title="Add Roles"></a>Add Roles</h4><p>为了执行基于角色的访问控制，我们需要有角色。<br>在本教程中最快的方法是在Stormpath中添加一些组。要做到这一点，登录到UI并导航如下：<br><strong>Directories &gt; My Application Directory &gt; Groups</strong><br>添加下面三个组：</p>
<ul>
<li>Captains</li>
<li>Officers</li>
<li>Enlisted</li>
</ul>
<p>创建组后，将Jean-Luc Picard帐户添加到Captains和Officers组。您可能需要创建一些临时帐户，并将它们添加到您喜欢的任何组；确保某些帐户不重叠组，因此你可以基于分配给用户帐户的单独组查看变更。</p>
<h4 id="Role-Based-Access-Control-RBAC-Tags"><a href="#Role-Based-Access-Control-RBAC-Tags" class="headerlink" title="Role Based Access Control (RBAC) Tags"></a>Role Based Access Control (RBAC) Tags</h4><p>我们更新/home.jsp页面，让用户知道他们有什么角色，哪些角色没有。这些消息将添加到主页的新的<code>&lt;h2&gt;</code>角色<code>&lt;/ h2&gt;</code>部分:<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Roles<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Here are the roles you have and don't have. Log out and log back in under different user</div><div class="line">    accounts to see different roles.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Roles you have:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"Captains"</span>&gt;</span>Captains<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"Officers"</span>&gt;</span>Bad Guys<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"Enlisted"</span>&gt;</span>Enlisted<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Roles you DON'T have:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"Captains"</span>&gt;</span>Captains<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"Officers"</span>&gt;</span>Officers<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksRole</span> <span class="attr">name</span>=<span class="string">"Enlisted"</span>&gt;</span>Enlisted<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">shiro:lacksRole</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果当前主体被分配了指定的角色，<shiro：hasrole>标签将显示其中的内容。<shiro：lacksrole>标签只会在当前主体未分配指定角色时显示其中的内容。</shiro：lacksrole></shiro：hasrole></p>
<h4 id="RBAC-filter-chains"><a href="#RBAC-filter-chains" class="headerlink" title="RBAC filter chains"></a>RBAC filter chains</h4><p>向读者留下的一个练习（不是一个定义的步骤）是根据分配给当前用户的角色，创建网站的一个新的部分，并限制URL访问该网站的该部分。<br>提示：使用 <code>filter chain definition</code>为webapp的新部分创建过滤器链定义。</p>
<h4 id="Run-the-webapp-4"><a href="#Run-the-webapp-4" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>run一下咯</p>
<h3 id="Step-7-Permission-Based-Access-Control"><a href="#Step-7-Permission-Based-Access-Control" class="headerlink" title="Step 7: Permission-Based Access Control"></a>Step 7: Permission-Based Access Control</h3><p>基于角色的访问控制对于许多情况是行得通的，但是它存在一个主要问题：你不能在运行时添加或删除角色。角色检查使用角色名称进行硬编码，所以如果你改变了角色名称或角色配置，或添加或删除角色，你必须回去更改代码！<br>因此，Shiro具有强大的功能：内置的权限支持。<br>在Shiro，权限是一个原始的功能说明，例如“打开门”，创建博客条目“，”删除jsmith用户“等。权限反映了您的应用程序的原始功能，所以在更改应用程序的功能时，您只需要更改权限检查，而不是要更改角色或用户模型。<br>为了演示这一点，我们将创建一些权限并将其分配给用户，然后根据用户的授权（权限）自定义我们的Web UI。</p>
<h4 id="Add-Permissions"><a href="#Add-Permissions" class="headerlink" title="Add Permissions"></a>Add Permissions</h4><p>Shiro的Realm是只读组件:每个数据存储模型的角色，组，权限，帐户和他们的关系不同,所以Shiro没有一个’write’API来修改这些资源。要修改模型对象的底层，你只需通过任何您想要的API直接修改它们。你的Shiro的Realm然后知道如何阅读这些信息，并以Shiro理解的格式表示它。<br>因此，由于我们在此示例应用程序中使用Stormpath，因此我们将以特定于Stormpath API的方式为帐户和组分配权限。<br>让我们执行一个cURL请求，为以前创建的Jean-Luc Picard帐户添加一些权限。 使用该帐户的href URL，我们将通过自定义数据将一些apacheShiroPermissions发布到该帐户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">curl -X POST --user <span class="variable">$YOUR_API_KEY_ID</span>:<span class="variable">$YOUR_API_KEY_SECRET</span> \</div><div class="line">    -H <span class="string">"Accept: application/json"</span> \</div><div class="line">    -H <span class="string">"Content-Type: application/json"</span> \</div><div class="line">    <span class="_">-d</span> <span class="string">'&#123;</span></div><div class="line">            "apacheShiroPermissions": [</div><div class="line">                "ship:NCC-1701-D:command",</div><div class="line">                "user:jlpicard:edit"</div><div class="line">            ]</div><div class="line">        &#125;' \</div><div class="line"><span class="string">"https://api.stormpath.com/v1/accounts/<span class="variable">$JLPICARD_ACCOUNT_ID</span>/customData"</span></div></pre></td></tr></table></figure></p>
<p>其中$ JLPICARD_ACCOUNT_ID与你在本教程开头创建的Jean-Luc Picard的插槽相匹配。<br>这将直接向Stormpath帐户添加两个权限：</p>
<ul>
<li>ship:NCC-1701-D:command</li>
<li>user:jlpicard:edit</li>
</ul>
<p>这些使用Shiro的WildcardPermission语法。<br>第一个基本上是指用“NCC-1701-D”标识符来“命令”’船’的能力。这是实例级权限的一个示例：控制对资源船的特定实例NCC-1701-D的访问。第二个也是一个实例级权限，指出使用标识符jlpicard编辑用户的能力。<br>如何在Stormpath中存储权限，以及如何在Stormpath中自定义存储和访问选项超出本文档的范围，但这是在Shiro Stormpath插件文档中解释的。</p>
<h4 id="Permission-Tags"><a href="#Permission-Tags" class="headerlink" title="Permission Tags"></a>Permission Tags</h4><p>就像我们有用于角色检查的JSP标签一样，还有同样用于权限检查的标签。我们更新/home.jsp页面，让用户知道是否允许你根据分配给他们的权限执行某些操作。这些消息将添加到主页的新的<code>&lt;h2&gt;</code>权限<code>&lt;/ h2&gt;</code>部分：<br><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Permissions<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>You may <span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"ship:NCC-1701-D:command"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>NOT<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span> command the <span class="tag">&lt;<span class="name">code</span>&gt;</span>NCC-1701-D<span class="tag">&lt;/<span class="name">code</span>&gt;</span> Starship!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>You may <span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"user:$&#123;account.username&#125;:edit"</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>NOT<span class="tag">&lt;/<span class="name">b</span>&gt;</span> <span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span> edit the $&#123;account.username&#125; user!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>当你第一次访问主页时，在登录之前，你将看到以下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You may NOT command the NCC-1701-D Starship!</div><div class="line">You may NOT edit the user!</div></pre></td></tr></table></figure></p>
<p>但是，在你使用Jean-Luc Picard帐户登录后，你将看到这一点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You may command the NCC-1701-D Starship!</div><div class="line">You may edit the user!</div></pre></td></tr></table></figure></p>
<p>你可以看到Shiro解决了经过身份验证的用户具有权限，并以适当的方式呈现输出。<br>您还可以使用<shiro：haspermission>标签进行肯定权限检查。<br>最后，我们将注意到极其强大的权限检查功能。 你能看到第二个权限检查如何使用运行时生成的权限值吗？<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"user:$&#123;account.username&#125;:edit"</span>&gt;</span> ...</div></pre></td></tr></table></figure></shiro：haspermission></p>
<p><code>${account.username}</code>在运行的时候将<code>user:aUsername:edit</code>的值组装起来，最后这个最终的值被用来权限检查。<br>这种运行时的权限检查机制是用来构建高度定制化和安全的应用的常规技术。</p>
<h4 id="Run-the-webapp-5"><a href="#Run-the-webapp-5" class="headerlink" title="Run the webapp"></a>Run the webapp</h4><p>run一run咯</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>我们希望这篇指南能对你使用Shiro构建webapp有帮助。在下个版本我们将推出这些内容：</p>
<ul>
<li>不同用户数据的存储插件，像RDBMS或者NoSQL之类的。</li>
</ul>
<p>原文<a href="http://shiro.apache.org/webapp-tutorial.html" target="_blank" rel="external">Securing Web Applications with Apache Shiro</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是介绍使用Shiro一步一步保护你的web应用的教程。它包含了Shiro的知识，以及和最近两篇文章很相似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.infoq.com/articles/apache-shiro&quot;&gt;Application Security with Apache Shiro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://shiro.apache.org/10-minute-tutorial.html&quot;&gt;Apache Shiro 10 Minute Tutorial&lt;/a&gt;&lt;br&gt;这个入门教程会花费大约45分钟到一个小时。当你读完后，你就会知道Shiro在web应用中怎么工作了的。
    
    </summary>
    
      <category term="Apache" scheme="http://www.wei-dong.top/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.wei-dong.top/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Java Authorization Guide with Apache Shiro[译]</title>
    <link href="http://www.wei-dong.top/2017/09/25/Java%20Authorization%20Guide%20with%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.wei-dong.top/2017/09/25/Java Authorization Guide with Apache Shiro[译]/</id>
    <published>2017-09-25T12:05:23.000Z</published>
    <updated>2017-09-25T12:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>授权或者说访问控制指的是为资源分配访问权限。换句话说就是谁能干什么。</p>
<p>举个授权的栗子：用户允许看网页、改数据、看按钮或者打印吗？这些都能决定用户能不能做什么。<br><a id="more"></a></p>
<h3 id="Elements-of-Authorization"><a href="#Elements-of-Authorization" class="headerlink" title="Elements of Authorization"></a>Elements of Authorization</h3><p>授权有三个我们在Shiro中使用很多的核心元素–权限、角色和用户。</p>
<h3 id="Permissions-Defined"><a href="#Permissions-Defined" class="headerlink" title="Permissions Defined"></a>Permissions Defined</h3><p>权限是安全策略的最原子级别，它们是功能语句。权限就是在你的应用中能做什么。权限描述了资源类型以及当你与这些资源进行交互时可能采取的操作。你能开门吗？你能读取文件吗？你能删除客户记录吗？你能按按钮吗？</p>
<p>数据相关资源的常见操作是创建，读取，更新和删除，通常称为CRUD。</p>
<p>重要的是要明白，权限不是谁能执行的操作 - 它们只是可以执行哪些操作的语句。</p>
<h4 id="Levels-of-permission-granularity"><a href="#Levels-of-permission-granularity" class="headerlink" title="Levels of permission granularity"></a>Levels of permission granularity</h4><p>以上权限都指定资源（门，文件，客户记录等）上的操作（打开，读取，删除等）。在Shiro，您可以定义任何您喜欢的粒度的权限。以下是粒度顺序的几个常见权限级别。</p>
<ul>
<li>资源级别 - 这最广泛最简单构建。 用户可以编辑客户记录或打开门。 资源被指定，但不是该资源的特定实例。</li>
<li>实例级别 - 权限可以指定资源的实例。 用户可以编辑IBM的客户记录或打开厨房门。</li>
<li>属性级别 - 权限现在可以指定实例或资源的属性。 用户可以编辑IBM客户记录上的地址。</li>
</ul>
<p>获取更多信息:<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external">Permissions Documentation</a></p>
<h3 id="Roles-Defined"><a href="#Roles-Defined" class="headerlink" title="Roles Defined"></a>Roles Defined</h3><p>在授权的上下文中，角色实际上是用于简化权限和用户管理的权限集合。因此，用户可以分配角色，而不是直接分配权限，这可能会使较大的用户基础和更复杂的应用程序变得复杂。因此，例如，银行应用程序可能具有管理员角色或银行出纳员角色。</p>
<p>有2中类型的角色你需要知道，Shiro同时也支持。</p>
<h4 id="Implicit-Roles（隐式的角色）"><a href="#Implicit-Roles（隐式的角色）" class="headerlink" title="Implicit Roles（隐式的角色）"></a>Implicit Roles（隐式的角色）</h4><p>代码中的角色检查通常是隐含角色的反映。你可以查看患者数据，因为你具有管理员角色。你可以创建一个帐户，因为你有银行出纳员角色。事实上这些名字的存在和软件具体能做的没有任何关系。大多数人以这种方式使用角色。这是最简单的，但它可以为所有但最简单的应用程序造成大量的维护和管理问题。</p>
<h4 id="Explicit-Roles（显式的角色）"><a href="#Explicit-Roles（显式的角色）" class="headerlink" title="Explicit Roles（显式的角色）"></a>Explicit Roles（显式的角色）</h4><p>显式角色具有明确分配给它的权限，因此是明确的权限集合。代码中的权限检查反映了明确的角色。你可以查看患者的数据，因为你将患者数据视图视为管理员角色的一部分。你可以创建一个帐户，因为你有创建帐户权限作为你的银行柜员角色的一部分。你可以执行这些操作，而不是因为基于字符串的一些隐式角色名称，而是因为相应权限被明确分配给你的角色。</p>
<p>明确角色的最大好处是易于管理，降低了应用程序的维护。如果你需要添加，删除或更改角色，则可以在不触摸源代码的情况下执行此操作。在Shiro中，你还可以在运行时动态添加，删除或更改角色，并且你的授权检查将始终具有最新值。这意味着你不必强制用户注销并重新登录以获取他们的新权限。</p>
<h3 id="Users-Defined"><a href="#Users-Defined" class="headerlink" title="Users Defined"></a>Users Defined</h3><p>用户就是谁在用这个应用程序。然而，在Shiro，用户的概念实际上是Subject实例。我们使用Subject这个词而不是用户，因为用户通常意味着人类，而在Shiro中，Subject可以与你的应用程序进行任何交互 - 无论是人类还是服务。</p>
<p>用户就是允许在你的应用程序中通过角色或者权限的关联执行某些动作。因此你可以打开一个客户的记录，因为你已经被分配了打开客户记录的权限，或者你被分配了带有权限的角色。</p>
<h3 id="How-to-perform-Authorization-in-Java-with-Shiro"><a href="#How-to-perform-Authorization-in-Java-with-Shiro" class="headerlink" title="How to perform Authorization in Java with Shiro"></a>How to perform Authorization in Java with Shiro</h3><p>在Shiro中授权有四种：</p>
<ul>
<li>以编程方式 - 你可以在java代码中执行授权检查，其结构如if和else。</li>
<li>JDK注解 - 你可以将授权注解附加到Java方法。</li>
<li>JSP / GSP TagLibs  - 你可以根据角色和权限来控制jsp或gsp页面输出</li>
</ul>
<h4 id="Programmatic-Authorization"><a href="#Programmatic-Authorization" class="headerlink" title="Programmatic Authorization"></a>Programmatic Authorization</h4><p>检查角色和权限，在你的代码中使用编程方式是一种传统方式来处理授权。</p>
<h5 id="Role-Check"><a href="#Role-Check" class="headerlink" title="Role Check"></a>Role Check</h5><p>这是一个使用编程方式来检查角色的栗子。我们想检查用户是否具有管理员角色，如果有，那么我们将显示一个特殊的按钮，否则我们不会显示它。</p>
<p>首先我们得到当前用户，也就是Subject。然后我们将admin传给Subject的<code>hasRole()</code>方法。它会返回<code>TRUE</code>或者 <code>FALSE</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get the current Subject </span></div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (currentUser.hasRole(<span class="string">"administrator"</span>)) &#123;</div><div class="line">    <span class="comment">//show a special button‏</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?)‏</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，基于角色的检查是快速和容易实现的，但它具有主要的缺点。 这是隐式的。</p>
<p>如果你只想稍后添加，删除或重新定义角色怎么办？你必须打开源代码，并更改所有角色检查以反映你的安全模型的变化。你必须关闭应用程序，破解代码，测试它，然后重新启动它。</p>
<p>在非常简单的应用程序中，这可能足够好，但对于较大的应用程序，这可能是应用程序的整个生命周期中的主要问题，并为你的软件带来大量维护成本。</p>
<h5 id="Permission-Check"><a href="#Permission-Check" class="headerlink" title="Permission Check"></a>Permission Check</h5><p>这是你如何通过权限进行安全检查的示例。我们想检查用户是否有权打印到laserjet3000n，如果是这样，那么我们将显示打印按钮，否则我们不会显示。这是一个实例级权限或实例级授权的示例。</p>
<p>再次，首先你可以访问当前的用户，Subject。然后构造一个Permission对象或者实例来表示一个动作或者资源。在这个栗子中这个实例可以命名为printPermission,资源是laserjet3000n，动作是打印。然后我们将printPermission传给Subject的<code>.isPermitted()</code>方法。它返回true或者false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">Permission printPermission = <span class="keyword">new</span> PrinterPermission(<span class="string">"laserjet3000n"</span>,<span class="string">"print"</span>);</div><div class="line"></div><div class="line">If (currentUser.isPermitted(printPermission)) &#123;</div><div class="line">    <span class="comment">//do one thing (show the print button?)‏</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Permission-Check-String-based"><a href="#Permission-Check-String-based" class="headerlink" title="Permission Check (String-based)"></a>Permission Check (String-based)</h5><p>你也可以用一个简单的字符串而不是permission类做权限检查。</p>
<p>因此，如果你不想实现我们permission 接口，你仅仅传一个string字符串就行了。在这个栗子中，我们传<code>.isPermitted()</code>一个字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String perm = <span class="string">"printer:print:laserjet4400n"</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(currentUser.isPermitted(perm))&#123;</div><div class="line">    <span class="comment">//show the print button?</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//don’t show the button?</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只要你的域知道如何使用它，你可以按照你想要的方式构建权限字符串。在这个栗子中，我们使用Shiro的可选的权限语法，<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external"> WildCardPermissions</a>.WildCardPermissions功能强大直观。</p>
<p>通过使用基于字符串的权限检查，你可以获得的功能和之前的栗子是一样的。好处是你不必强制实现权限接口，你可以通过简单的字符串构造权限。缺点是你没有类型安全，如果你需要更复杂的许可权限，这些权限超出了这个处理的范围。接下来讲如何基于Permission接口实现权限对象。</p>
<h4 id="Annotation-Authorization"><a href="#Annotation-Authorization" class="headerlink" title="Annotation Authorization"></a>Annotation Authorization</h4><p>如果你不想在代码层做权限控制，你也可以使用Java注解。Shiro提供很多注解可以让你放在方法上面。</p>
<h5 id="Enabling-Annotation-Support"><a href="#Enabling-Annotation-Support" class="headerlink" title="Enabling Annotation Support"></a>Enabling Annotation Support</h5><p>在你使用Java注解之前，你需要在你的应用中开启AOP支持。有很多不同的AOP框架，因此不幸的是，在应用中没有一个标准的方式开启AOP。</p>
<p>对AspectJ而言，看栗子<a href="https://github.com/apache/shiro/tree/master/samples/aspectj" target="_blank" rel="external">AspectJ sample application</a></p>
<p>对Spring而言，看栗子<a href="http://shiro.apache.org/spring.html" target="_blank" rel="external"> Spring Integration </a></p>
<p>对Guice而言，看栗子<a href="http://shiro.apache.org/guice.html" target="_blank" rel="external"> Guice Integration</a></p>
<h5 id="Permission-Check-1"><a href="#Permission-Check-1" class="headerlink" title="Permission Check"></a>Permission Check</h5><p>在这个栗子中，我们想检查一个用户在调用<code>openAccount</code>方法之前是否有<code>account:create</code>权限。如果有，按照期望的调用，如果没得，那就抛异常。</p>
<p>和通过编程方式检查权限一样，你可以使用Permission对象或者简单的字符串方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Will throw an AuthorizationException if none</span></div><div class="line"><span class="comment">//of the caller’s roles imply the Account</span></div><div class="line"><span class="comment">//'create' permission</span></div><div class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"account:create"</span>)‏</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openAccount</span><span class="params">( Account acct )</span> </span>&#123;</div><div class="line">    <span class="comment">//create the account</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Role-Check-1"><a href="#Role-Check-1" class="headerlink" title="Role Check"></a>Role Check</h5><p>在这个栗子中，我们想检查一个用户在执行<code>openAccount</code>方法前是否有<code>teller</code>角色。如果有就按照期望的走下去，没有就抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Throws an AuthorizationException if the caller</span></div><div class="line"><span class="comment">//doesn’t have the ‘teller’ role:</span></div><div class="line"><span class="meta">@RequiresRoles</span>( <span class="string">"teller"</span> )</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openAccount</span><span class="params">( Account acct )</span> </span>&#123;</div><div class="line">    <span class="comment">//do something in here that only a teller</span></div><div class="line">    <span class="comment">//should do</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="JSP-TagLib-Authorization"><a href="#JSP-TagLib-Authorization" class="headerlink" title="JSP TagLib Authorization"></a>JSP TagLib Authorization</h4><p>对于基于JSP / GSP的Web应用程序，Shiro还提供了一个标签库供您使用。</p>
<p>在此示例中，我们将向用户显示user:manage权限,一个指向“管理用户”页面的链接。如果他们没有权限，那么我们会给他们一个友好的消息提示。</p>
<p>首先，我们需要将Shiro taglib添加到我们的Web应用程序中。接着我们为user:manage权限添加<shiro:haspermission>标签。在<shiro：haspermission>标签中，如果用户具有我们正在检查的权限，我们就放置要执行的代码。如果我们要执行一个动作假如这个用户缺少权限，我们需要添加<shiro:lackspermission> 标签，再次检查users:manage权限。如果用户缺少权限，我们想要执行的任何代码都需要放在<shiro：lackspermission>标签中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> <span class="attr">uri</span>=<span class="string">http://shiro.apache.org/tags</span> %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"users:manage"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"manageUsers.jsp"</span>&gt;</span></div><div class="line">            Click here to manage users</div><div class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">shiro:lacksPermission</span> <span class="attr">name</span>=<span class="string">"users:manage"</span>&gt;</span></div><div class="line">        No user management for you!</div><div class="line">    <span class="tag">&lt;/<span class="name">shiro:lacksPermission</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></shiro：lackspermission></shiro:lackspermission></shiro：haspermission></shiro:haspermission></p>
<p>当然，还有用于检查角色和其他用户数据和状态的标签。</p>
<p>有关JSP / GSP标签的更多信息，请查看JSP标签库，以及有关将应用程序集成到Web应用程序中的更多信息，请阅读<a href="http://shiro.apache.org/web.html" target="_blank" rel="external">Web集成文档</a>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;授权或者说访问控制指的是为资源分配访问权限。换句话说就是谁能干什么。&lt;/p&gt;
&lt;p&gt;举个授权的栗子：用户允许看网页、改数据、看按钮或者打印吗？这些都能决定用户能不能做什么。&lt;br&gt;
    
    </summary>
    
      <category term="Apache" scheme="http://www.wei-dong.top/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.wei-dong.top/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Application Security With Apache Shiro[译]</title>
    <link href="http://www.wei-dong.top/2017/09/21/Application%20Security%20With%20Apache%20Shiro%5B%E8%AF%91%5D/"/>
    <id>http://www.wei-dong.top/2017/09/21/Application Security With Apache Shiro[译]/</id>
    <published>2017-09-21T04:41:23.000Z</published>
    <updated>2017-09-21T04:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你为你的应用添加安全措施的时候有没有觉得很受挫？你有没有觉得Java在安全这一块的解决方案用起来很难，让你更加觉得困惑？这篇文章介绍<a href="http://shiro.apache.org/" target="_blank" rel="external">Apache Shiro</a>,一个简单又强大为你应用提供安全的Java框架。本文对Apache Shiro的愿景、架构设计及怎样去使用Shiro来保护你的应用进行解释。</p>
<h3 id="Apache-Shiro是什么？"><a href="#Apache-Shiro是什么？" class="headerlink" title="Apache Shiro是什么？"></a>Apache Shiro是什么？</h3><p>Apache Shiro（发音为“歇肉”，在日本的发音是城堡的意思）是一个强大又好用的Java安全框架，它提供认证、授权、加密和会话管理，它可以被用在保护任何应用–从命令行应用、移动应用到大型的web企业级应用。</p>
<p>Shiro为以下几个方面提供应用安全的API。</p>
<ul>
<li>认证-证明用户身份，通常叫做登录</li>
<li>授权-访问控制</li>
<li>加密-保护或隐藏数据不被窥视</li>
<li>会话管理-每个用户的状态是对时间敏感的</li>
</ul>
<p>Shiro还提供辅助的特性，比如说web安全，单元测试，和多线程的支持。这些都是为了加强上面提到的几个特性。</p>
<h3 id="Apache-Shiro为什么被发明？"><a href="#Apache-Shiro为什么被发明？" class="headerlink" title="Apache Shiro为什么被发明？"></a>Apache Shiro为什么被发明？</h3><p>对于一个框架而言，它存在的意义就是它满足你的需求而找不到其他的替代方案。为了理解这些东西，我们有必要翻一番Shiro的历史以及当时的替代品。</p>
<p>在2008年加入ASF之前，Shiro都5岁了，而且和早在2003年开始的JSecurity一样有名了。在2003年，没有太多为Java开发者提供可选的安全方案。我们坚持使用Java认证和Java授权服务，称作JAAS。然而JASS有很多缺点当然认证能力是可以接受的，授权方面让人用起来觉得很崩溃。JAAS和JVM级别的安全密切相关，比方说决定一个class该不该被加载到JVM。作为一个应用开发者，我更关心的是应用程序用户能做什么，而不是我的代码在JVM里能做什么。</p>
<p>由于我当时着手的工作，我需要一个干净的和容器无关的会话机制。当时在游戏（我猜作者的工作就是写游戏）中唯一的选择就是HttpSession，这个玩意需要一个web容器或者EJB容器。我需要的是能够从容器中解耦，而且在任何环境下都好用的。</p>
<p>最后有一个密码的问题。有很多情况下我们需要加密数据，但是Java加密架构除了密码专家外普通人很难理解。它的API到处都是异常检查，用起来感觉很笨重。我迫切希望一个干净的开箱即用的可以满足我的需求的解决方案。</p>
<p>看了一下在2003年早期的安全概况，你能很快的意识到没有一款单一的框架能够满足这些需求。正因为如此，JSecurity还有后来的Shiro诞生了。</p>
<h3 id="如今你为何用Apache-Shiro"><a href="#如今你为何用Apache-Shiro" class="headerlink" title="如今你为何用Apache Shiro?"></a>如今你为何用Apache Shiro?</h3><p>自2003年来，框架的格局发生了很大的变化，因此现在有一个让人信服的理由来使用Shiro。理由如下：</p>
<ul>
<li>好用–好用是一个项目最关键的目标。应用安全可能是非常让人沮丧和困惑，因此被称作“必要的罪恶”。假如你让它变得新手程序员都容易使用，那就不那么痛苦了。</li>
<li>全面–没有比Shiro更广泛的安全框架了，因此它可以一站式满足你对安全的需要。</li>
<li>灵活–Shiro能在任何环境下工作。虽然它在web、EJB、和ioC容器中工作，但是它不依赖他们。Shiro没有太多的规定，也没有太多的依赖。</li>
<li>支持web–Shiro对web应用有全面的支持，你可以创建基于web协议和url的灵活的安全策略，同时提供一套控制页面输出的JSP库。</li>
<li>可插拔–Shiro干净的API（干净可以翻译为简洁）和设计思想可以让你很容易地集成到其他框架和应用。你可以看到Shiro和Spring、Grails等框架无缝集成。</li>
<li>支持–Shiro是ASF的一部分。这个项目的开发和用户群会友好的提供帮助。如果需要，像<a href="https://stormpath.com/" target="_blank" rel="external">Katasoft</a>商业公司也会提供专业的支持和服务。</li>
</ul>
<h3 id="谁在用Shiro？"><a href="#谁在用Shiro？" class="headerlink" title="谁在用Shiro？"></a>谁在用Shiro？</h3><p>Shiro和它的先驱JSecurity在很多行业很多公司的项目中用了很多年。在成为ASF顶级项目之后，它的网站流量和使用率大增。也有许多开源的组织使用Shiro，比方说Spring, Grails, Wicket, Tapestry, Tynamo, Mule, 和 Vaadin。</p>
<p>商业公司像Katasoft、Sonatype、MuleSoft等也使用Shiro来保护他们的商业软件和网站。</p>
<h3 id="核心概念：主体，安全管理器，域"><a href="#核心概念：主体，安全管理器，域" class="headerlink" title="核心概念：主体，安全管理器，域"></a>核心概念：主体，安全管理器，域</h3><p>目前我们讲了Shiro的优点，我们直接来看看它的API，让你直接感受它。Shiro的架构有3个核心的概念–主体、安全管理器和域。</p>
<h4 id="Subject-主体"><a href="#Subject-主体" class="headerlink" title="Subject(主体)"></a>Subject(主体)</h4><p>当你要对你的应用进行保护的时候，你最大的可能要问的问题就是“当前用户是谁？”或者“当前用户允许做这件事吗？”，我们问自己这些问题是很正常的，就像我们在写代码或者设计接口一样。应用程序通常是基于用户故事来构建，而且你想基于每个用户来构建你的功能。因此，你考虑在你应用安全最常规的思路就是基于当前用户。Shiro API中的主体概念基本上体现了这种思路。</p>
<p>主体是安全术语中的一个名词，代表的是当前执行的用户。不能仅仅只称作“用户”因为“用户”这个词通常和人类关联起来。在安全领域，主体这个词可以代表一个人，也可以代表第三方进程、一个后台账号或者类似的东西。简单来讲，就是和当前软件交互的东西。然而对于大多数目的和用途，你可以把它当做Shiro用户的概念。你能很容易地在你的代码中获取Shiro的主体，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import org.apache.shiro.subject.Subject;</div><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">...</div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div></pre></td></tr></table></figure></p>
<p>一旦你获取了主体，你就能使用Shiro为当前用户拿到90%的访问权限，比如登录，退出登录，获取session，执行权限检查等。这里关键点是Shiro的API大体上是很直观的，从中可以体现开发者在针对每个用户的安全控制中的思路（这句话实在是不知道怎么翻译）。在代码中任何地方获取主体很容易，在需要进行安全操作的地方进行控制也很容易。</p>
<h4 id="SecurityManager-安全管理器"><a href="#SecurityManager-安全管理器" class="headerlink" title="SecurityManager(安全管理器)"></a>SecurityManager(安全管理器)</h4><p>在主体背后后与之配对的是安全管理器。主体提供当前用户的安全操作，然而安全管理器为所有用户管理着安全操作。这是Shiro架构的核心，有类似于很多“伞”的作用。这些伞内部引用了很多嵌套的安全组件而形成一个伞图（翻译很晦涩，意思就是很多组件组合而成）。然而，一旦安全管理器及内部的“伞图”配置好了，应用开发者几乎将所有时间都花在了主体API上，通常这个安全管理器是独立的。</p>
<p>在每一个应用中总有一个安全管理器实例。本质上是一个单例应用（虽然不必是静态单例）。像Shiro中其他东西一样，默认的安全管理器的实现是POJO，可以通过任何与POJO兼容的配置机制–普通的Java代码、Spring XML、YAML、.properties和ini文件等等。通常来讲，能够被实例化的类和能够调用JavaBean兼容方法的都可以使用。</p>
<p>为此，Shiro借助基于文本的INI配置提供了一个缺省的“公共”解决方案。INI读起来很容易，用起来很简单，而且依赖的东西也很少。你可以看到，通过简单了解对象图导航，INI可以很高效的配置简单的对象图,像SecurityManager。注意Shiro也支持Spring XML配置合其他替代品。我们这里只谈INI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">cm = org.apache.shiro.authc.credential.HashedCredentialsMatcher</div><div class="line">cm.hashAlgorithm = SHA-512</div><div class="line">cm.hashIterations = 1024</div><div class="line">#Base64 encoding (less text):</div><div class="line">cm.storedCredentialsHexEncoded = false</div><div class="line">iniRealm.credentialsMatcher = $cm</div><div class="line">[users]</div><div class="line">jdoe = TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJpcyByZWFzb2</div><div class="line">asmith = IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbXNoZWQsIG5vdCB</div></pre></td></tr></table></figure></p>
<p>在上面的INI配置例子中，我们看到配置SecurityManager 实例。在INI配置中有2个部分：[main]和[users].</p>
<p>[main]部分用于配置SecurityManager对象或者被SecurityManager 使用的任何对象。在这个例子中，我们看到了两个对象被配置：</p>
<ol>
<li>cm对象，Shiro中的HashedCredentialsMatcher 类的一个实例。你能看到，很多cm的属性通过嵌套的点的语法被配置。清单3所示的IniSecurityManagerFactory使用的约定来表示对象图形导航和属性设置。</li>
<li>iniRealm对象，它是SecurityManager用于表示以INI格式定义的用户帐户的组件。</li>
</ol>
<p>在[users]这部分中你可以指定一个静态的用户列表，对于简单的应用是很方便来测试的。</p>
<p>介绍这些的目的不是去理解每个部分的复杂性，而是INI配置方式是一种简单的Shiro配置。更多关于INI配置的细节，详情可以参考<a href="http://shiro.apache.org/documentation.html" target="_blank" rel="external">Shiro文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import org.apache.shiro.SecurityUtils;</div><div class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</div><div class="line">import org.apache.shiro.mgt.SecurityManager;</div><div class="line">import org.apache.shiro.util.Factory;</div><div class="line">...</div><div class="line">//1. Load the INI configuration</div><div class="line">Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</div><div class="line">//2. Create the SecurityManager SecurityManager securityManager = factory.getInstance();</div><div class="line">//3. Make it accessible</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，我们有3个步骤：</p>
<ol>
<li>加载配置SecurityManager及其组件的INI配置文件。</li>
<li>基于这个配置创建SecurityManager实例(使用Shiro的工厂概念)。</li>
<li>把SecurityManager变成单例。在这个例子中，我们将它设置成VM静态单例，但是这不是必须的。你的应用配置机制可以决定你要不要使用静态内存(这段翻译真的一点都不容易理解)。</li>
</ol>
<h4 id="Realms-域"><a href="#Realms-域" class="headerlink" title="Realms(域)"></a>Realms(域)</h4><p>Shiro中第三个核心概念就是域。域在你的应用数据和Shiro中承担一个桥梁或者说是连接器的角色。也就是说，当和安全相关的数据交互，比方说认证（登录）和授权（访问控制）时，Shiro从为应用配置的一个或者多个域配置中去找这些东西。</p>
<p>在某种意义上，一个域本质上就是一个安全的DAO：它为数据源封装了连接细节以及在需要的时候让Shiro能够访问关联的数据。当在配置Shiro的时候，你必须指定至少一个域用来做认证或者授权。可以配置多个，但至少要有一个。</p>
<p>Shiro提供开箱即用的域来连接各种安全的数据源，比方说LDAP、数据库相关的（JDBC）、文本文件配置类似INI文件和properties配置文件等。如果默认的域不能满足你的需求，你也可以将你自己实现的域插入到其中。下面通过INI配置Shiro的例子就是用LDAP来作为应用的一个域实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">ldapRealm = org.apache.shiro.realm.ldap.JndiLdapRealm</div><div class="line">ldapRealm.userDnTemplate = uid=&#123;0&#125;,ou=users,dc=mycompany,dc=com</div><div class="line">ldapRealm.contextFactory.url = ldap://ldapHost:389</div><div class="line">ldapRealm.contextFactory.authenticationMechanism = DIGEST-MD5</div></pre></td></tr></table></figure></p>
<p>现在我们知道了怎么配置一个基础的Shiro环境，我们接下来一起讨论作为一个开发者你改怎么使用这个框架。</p>
<h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>认证是验证用户的唯一性的过程。就是说，当用户使用应用进行认证的时候，他们在证明他们确实是他们所说的那个人。通常有时候我们把它称作登录。典型的三个步骤：</p>
<ol>
<li>收集用户身份信息，也叫作principals，并支持身份证明，称为credentials。</li>
<li>提交principals和credentials到系统。</li>
<li>如果提交的credentials和系统期望该用户身份匹配，这个用户就可以认为认证通过。如果不匹配，那就是认证不通过。</li>
</ol>
<p>每个人都熟悉的最常见的例子就是用户名和密码的组合。当用户登录到系统，他们通常提供他的用户名（principal）和密码（credential）。如果存储在系统中的 密码和用户提供的一致，他就被认证成功。</p>
<p>Shiro以简单直观的方式支持类似的流程。正如我们说的，Shiro有一套以主体为中心的API–几乎所有在运行时你和Shiro关心的都是通过与当前执行的主体交互实现的。因此，要登录一个主体，你只需要调用它的登录方法，传一个带有principals 和credentials的AuthenticationToken实例。下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//1. Acquire submitted principals and credentials:</div><div class="line"> AuthenticationToken token = new UsernamePasswordToken(username,password);</div><div class="line">//2. Get the current Subject:</div><div class="line">Subject currentUser = SecurityUtils.getSubject();</div><div class="line"> //3. Login:</div><div class="line"> currentUser.login(token);</div></pre></td></tr></table></figure></p>
<p>如你所见，Shiro的APi很简单的表示了这个流程。你可以将这种对所有主体操作的简单性作为一种特色。当登录方法被调用，SecurityManager将接收AuthenticationToken然后将其分发到一个或者多个配置好的域中用来做认证。每个域都有能力根据需要对提交的AuthenticationToken进行处理。但是假如登录失败了会发生什么呢？假如用户的密码输错了呢？你可以通过运行时的AuthenticationException 来处理这些失败，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//3. Login:</div><div class="line">try &#123;</div><div class="line">    currentUser.login(token);</div><div class="line">&#125; catch (IncorrectCredentialsException ice) &#123; …</div><div class="line">&#125; catch (LockedAccountException lae) &#123; …</div><div class="line">&#125;</div><div class="line">…</div><div class="line">catch (AuthenticationException ae) &#123;…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以选择捕获AuthenticationException的一个子类来进行具体的处理，或者统一处理任何AuthenticationException（比如说，通常显示“用户名或者密码错误”消息）。这是根据你应用的需求来选择的。</p>
<p>一个主体登录成功后，他们被认为认证通过，通常你允许他们使用你的应用。但是，由于用户仅证明了自己的身份不代表他们在应用中能做任何他们想做的事情。这就提出了下一个问题：“我如何控制用户被允许做什么？”决定用户允许做什么叫做授权。接下来我们讨论Shiro怎么启用授权。</p>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>授权是基本的访问控制–控制你的用户在你的应用中可以访问什么，比方说资源、web页面等等。大多数用户通过使用角色和权限等概念来执行访问控制。就是说，一个用户通常允许做什么事或者不允许做什么事是基于他们分配的角色或者权限的。然后，你的应用程序可以根据对这些角色和权限的检查来控制显示哪些功能。正如你期望的，主体API允许你非常容易的执行权限和角色检查。代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.hasRole(“administrator”) ) &#123;</div><div class="line">    //show the ‘Create User’ button</div><div class="line">&#125; else &#123;</div><div class="line">    //grey-out the button?</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如你所见，你的应用可以基于访问控制开启或者关闭功能。</p>
<p>权限检查是另一种执行授权的方式。在上面的例子中检查权限有一个很大的缺陷：你不能再运行的时候添加或者删除角色。你的代码是和角色名字硬编码进去的，因此假如你改变了角色名或者配置，你的代码将会爆炸！假如你需要可以在运行时改变角色的含义，或者根据需要添加删除角色，那么你就必须依靠别的东西了。</p>
<p>为此，Shiro支持权限的概念。权限是原始功能的说明，举个栗子，‘开门’、‘创建博客实体’、‘删除xx用户’等等。有权限代表你有应用的原始功能，当你更改应用程序的功能时，你只需要更改权限检查。反过来，在运行时必要的时候你可以分配权限到角色或者用户。下面的代码使用权限检查：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.isPermitted(“user:create”) ) &#123;</div><div class="line">    //show the ‘Create User’ button</div><div class="line">&#125; else &#123;</div><div class="line">    //grey-out the button?</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，任何分配了“user：create”权限的角色或用户可以单击“创建用户”按钮,而且这些角色和分配甚至可以在运行时更改，给你提供了一种非常灵活的安全模型。</p>
<p>“user：create”字符串是遵守某些解析约定的权限字符串的示例。Shiro通过其WildcardPermission支持这个开箱即用的约定。虽然超出本导言文章的范围，你将看到WildcardPermission在创建安全策略时可以非常灵活，甚至支持诸如实例级访问控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if ( subject.isPermitted(“user:delete:jsmith”) ) &#123;</div><div class="line">    //delete the ‘jsmith’ user</div><div class="line">&#125; else &#123;</div><div class="line">    //don’t delete ‘jsmith’</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子展示了你能控制，甚至可以细化到更细粒度的级别，如果有需要可以访问单个资源。如果你想的话你也可以发明自己的权限语法。参考<a href="http://shiro.apache.org/permissions.html" target="_blank" rel="external">Shiro Permission</a>获取更多详情。最后，就像身份验证一样，上面的调用最终也进入了SecurityManager，SecurityManager将会查询一个或多个域，以作出访问控制决定。这允许领域根据需要对认证和授权操作进行响应。</p>
<p>到此就是一个队Shiro授权功能的一个简要概述。很多安全框架在认证和授权面前停了下来，而Shiro不止于此。接下来我们要讨论Shiro的高级会话管理功能。</p>
<h4 id="Session-Management"><a href="#Session-Management" class="headerlink" title="Session Management"></a>Session Management</h4><p>Shiro提供安全框架里独一无二的：可用于任何应用和任何结构层一致的会话API。也就是说，Shiro为任何应用程序启用了会话编程范例–从小的后台应用到大型集群web应用。这意味着希望使用会话的应用程序开发人员不再强制使用Servlet或EJB容器。或者，如果使用这些容器，开发人员现在可以选择在任何层中使用统一和一致的会话API，而不是使用servlet或EJB特定的机制。</p>
<p>但是或许一个最重要的好处是Shiro会话是独立于容器的。这具有微妙但非常强大的含义。例如我们考虑会话集群。有多少以指定容器的方式来集群会话以进行容错和故障转移？Tomcat和Jetty做的不一样，和Websphere也不一样。但是使用Shiro session，你可以获得一个容器无关的集群解决方案。Shiro的架构允许可插拔的会话数据存储，例如企业级缓存，关系型数据库。NoSQL等。这意味着你可以一次配置会话群集，并且无论你的部署环境如何，它都将以相同的方式工作–Tomcat、Jetty、JEE Server或者独立的应用。实在是没用必要根据你怎么部署你的应用来重新配置你的应用。</p>
<p>另一个Shiro session的好处是session数据如果需要可以跨客户端共享。举个栗子，如果需要，Swing桌面客户端可以参与相同的Web应用程序会话–如果终端用户同时使用两者，则很有用。因此你怎样在任何环境下访问主体的session？下面的代码主体的2个方法会展示出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Session session = subject.getSession();</div><div class="line">Session session = subject.getSession(boolean create);</div></pre></td></tr></table></figure></p>
<p>如你所见，这些方法在概念上与HttpServletRequest API相同。第一个方法将会返回主体存在的session，如果没有，那就创建一个再返回。第二个方法接收一个bool参数，这个参数决定是否在session不存在的时候创建新的session。一旦你请求主体的session，你可以使用它和几乎使用HttpSession一样。Shiro团队考虑到HTTPSession对Java开发人员很友好，因此我们有这种感觉。最大的区别就是你可以在任何应用中使用Shiro Session，不仅限于web应用。下面的代码展示了其相同之处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Session session = subject.getSession();</div><div class="line">session.getAttribute(“key”, someValue);</div><div class="line">Date start = session.getStartTimestamp();</div><div class="line">Date timestamp = session.getLastAccessTime();</div><div class="line">session.setTimeout(millis);</div></pre></td></tr></table></figure></p>
<h4 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h4><p>密码学是隐藏或混淆数据的过程，所以窥探眼睛无法理解它。Shiro在密码学中的目标是简化和使用JDK的加密支持。要注意的是，一般来说密码学对于主体来说不是特定的，所以它是Shiro API的一个领域，和主体无关。你可以使用Shiro的加密用在任何地方，即使主体没有使用。Shiro真正关注的两个领域一个是哈希加密和密码加密。</p>
<h5 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h5><p>如果你用过JDK的MessageDigest类，你很快会发现用起来有一点笨重。它有一套基于工厂的笨重的静态方法API，而不是面向对象的，而且你被迫捕获那些永远不会被捕获的异常。假如你需要16进制或者base64编码消息摘要的输出，你得自己写–没有标准的JDK实现。Shiro以干净直观的散列API解决了这些问题。</p>
<p>打个比方，我们考虑一下比较常见的MD5散列文件并确定该哈希值的十六进制值的情况。“校验和”，这是在提供文件下载时经常使用的 - 用户可以在下载的文件上执行自己的MD5哈希，并声明其校验和与下载站点的校验和匹配。假如匹配，用户可以充分地假设该文件在传输过程中没有被篡改。</p>
<p>在不使用Shiro情况下这个过程：</p>
<ol>
<li>将文件转化为字节数组。JDK不能帮你完成，因此你得自己创建一个打开FileInputStream的方法，使用字节缓冲，然后抛出可能的异常等等。</li>
<li>用MessageDigest类来对字节数组求哈希，处理异常。</li>
<li>对哈希后的字节数组编码成16进制。JDK中也没有现成的帮你完成，因此你得创建另一个帮助类，并且可能在你的实现中使用按位操作和位移。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);</div><div class="line">    md.digest(bytes);</div><div class="line">    byte[] hashed = md.digest();</div><div class="line">&#125; catch (NoSuchAlgorithmException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这么简单和相对普遍的事情来说，这是一个很繁琐的工作。<br>看看Shiro怎么做相同的事情的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String hex = new Md5Hash(myFile).toHex();</div></pre></td></tr></table></figure></p>
<p>当你使用Shiro来简化所有这些工作时，这是非常简单和容易理解的。  SHA-512散列和Base64编码的密码同样简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String encodedPassword =</div><div class="line">    new Sha512Hash(password, salt, count).toBase64();</div></pre></td></tr></table></figure>
<p>可以看到在哈希和编码上Shiro帮你简化了多少，在这个过程中节省了你不少时间。</p>
<h5 id="Ciphers"><a href="#Ciphers" class="headerlink" title="Ciphers"></a>Ciphers</h5><p>密码是可以使用密钥可逆地转换数据的加密算法。我们通常用作保护数据安全，特别在传输或者存储数据的时候，数据特别容易被窥探。</p>
<p>如果你曾经使用过JDK加密API，特别是 javax.crypto.Cipher类，你知道这可以是一个难以置信的复杂野兽驯服（翻译为这是一个很困难的过程）。对于入门者而言，每个密码配置始终由javax.crypto.Cipher的一个实例表示。需要公钥/私钥加密吗？</p>
<p>然而怎么创建你需要的Cipher 实例？你创建一个复杂的，非直观的令牌分隔的密码选项字符串，称为“转换字符串”，并将此字符串传递给Cipher.getInstance静态工厂方法。使用这种密码选项String方法，没有类型安全性来确保你使用有效的选项。这也隐含意味着没有JavaDoc帮助你了解相关选项。而且您还需要处理检查的异常情况，以防你的String配置不正确，即使你知道配置正确。正如你所看到的，使用JDK密码是一项相当麻烦的任务。这些技术曾经是Java API在很久以前的标准，但时代已经改变，我们想要一个更简单的方法。</p>
<p>Shiro尝试通过引入其CipherService API来简化加密密码的整个概念。CipherService是大多数开发人员在保护数据时所需要的：一种简单，无状态，线程安全的API，可以在一个方法调用中对数据进行全面加密或解密。所有你需要做的是提供你的密钥，可以根据需要进行加密或解密。例如，可以使用256位AES加密：</p>
<blockquote>
<p>AesCipherService cipherService = new AesCipherService();<br>cipherService.setKeySize(256);<br>//create a test key:<br>byte[] testKey = cipherService.generateNewKey();<br>//encrypt a file’s bytes:<br>byte[] encrypted =<br>    cipherService.encrypt(fileBytes, testKey);</p>
</blockquote>
<p>与JDK的Cipher API相比，Shiro示例更简单:</p>
<ul>
<li>你可以直接实例化CipherService  - 没有奇怪或混乱的工厂方法。</li>
<li>密码配置选项表示为与JavaBeans兼容的getter和setter  - 没有奇怪和难以理解的“转换字符串”。</li>
<li>加密和解密在单一方法调用中执行。</li>
<li>没有强制检查异常。 如果你想要的话，可以捕获Shiro的CryptoException。</li>
</ul>
<p>Shiro的CipherService API还有其他优点，例如支持基于字节数组的加密/解密（称为“块”操作）以及基于流的加密/解密（例如，加密音频或视频）的能力。</p>
<p>Java加密技术不必如此难受。<br>Shiro对密码的支持旨在简化你保护数据安全的付出。</p>
<h4 id="Web-Support"><a href="#Web-Support" class="headerlink" title="Web Support"></a>Web Support</h4><p>最后，但不是不重要的，我们简要介绍Shiro对web的支持。Shiro拥有强大的web支持模块，来保护web应用安全。为一个web应用设置Shiro是很简单的。仅需要在web.xml中定义一个Shiro Servlet Filter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;</div><div class="line">        org.apache.shiro.web.servlet.IniShiroFilter</div><div class="line">    &lt;/filter-class&gt;</div><div class="line">    &lt;!-- no init-param means load the INI config</div><div class="line">        from classpath:shiro.ini --&gt; </div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">     &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt;</div><div class="line">     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>这个过滤器能够读之前的shiro.ini配置文件，因此无论在什么样的部署环境下，配置都是一样的。一旦配置好了，Shiro filter就会过滤一切请求，并确保在请求期间特定的请求主体可被访问。由于过滤所有请求，你可以执行指定安全的逻辑代码，以确保仅允许符合特定条件的请求。</p>
<h4 id="URL-Specific-Filter-Chains"><a href="#URL-Specific-Filter-Chains" class="headerlink" title="URL-Specific Filter Chains"></a>URL-Specific Filter Chains</h4><p>Shiro通过它特有的URL链来支持安全的过滤规则。它允许你为任何匹配的URL模式指定特殊过滤器链。这意味着在使用Shiro过滤机制的时候你有很大的灵活性–比在web.xml中定义的过滤器好很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[urls]</div><div class="line">/assets/** = anon</div><div class="line">/user/signup = anon</div><div class="line">/user/** = user</div><div class="line">/rpc/rest/** = perms[rpc:invoke], authc</div><div class="line">/** = authc</div></pre></td></tr></table></figure></p>
<p>如你所见，有一个用于web应用的[urls]部分。每一行等号的左边表示一个上下文相关的web应用路径。等号右边定义了一个过滤器链–有序的、逗号分隔的为指定路径执行servlet过滤器列表。每一个过滤器是一个servlet filter，但是你在上述看到的过滤器是特殊的，是与安全相关的由Shiro提供开箱即用的过滤器。你可以组合和匹配这些安全过滤器，以创建自定义的安全体验。你还可以指定任何其他现有的可能拥有的Servlet过滤器。</p>
<p>使用Shiro，更容易看出为给定的匹配路径执行的过滤器链。只要你想，你可以只在web.xml中定义Shiro filter然后在ini配置文件中定义其他过滤器和过滤器链，这样比web.xml更简洁，易于理解的过滤器链定义机制。即使你没有使用任何Shiro的安全特性，这个小小的方便让Shiro值得使用。</p>
<h4 id="JSP-Tag-Library"><a href="#JSP-Tag-Library" class="headerlink" title="JSP Tag Library"></a>JSP Tag Library</h4><p>Shiro还提供一套JSP标签来允许你基于当前主体的状态控制页面输出。一个常见有用的例子就是当一个用户登录后显示‘Hello <username>’文本。但是假如他们是匿名的，你就得显示点别的，像“Hello! Register Today!”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib prefix=&quot;shiro&quot;</div><div class="line">    uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</div><div class="line">...</div><div class="line">&lt;p&gt;Hello</div><div class="line">&lt;shiro:user&gt;</div><div class="line">    &lt;!-- shiro:principal prints out the Subject’s main</div><div class="line">        principal - in this case, a username: --&gt;</div><div class="line">    &lt;shiro:principal/&gt;!</div><div class="line">&lt;/shiro:user&gt;</div><div class="line">&lt;shiro:guest&gt;</div><div class="line">    &lt;!-- not logged in - considered a guest. Show</div><div class="line">        the register link: --&gt;</div><div class="line">    ! &lt;a href=”register.jsp”&gt;Register today!&lt;/a&gt;</div><div class="line">&lt;/shiro:guest&gt;</div><div class="line">&lt;/p&gt;</div></pre></td></tr></table></figure></username></p>
<p>还有其他标签基于用户有哪些角色或者没有哪些角色，分配了哪些权限，有没有被认证，“记住我”了的，或者一个匿名用户来允许你输出。<br>Shiro支持很多web特有的feature，像记住我，REST和BASIC认证，当然，如果你希望使用Shiro的本地企业会话，也可以使用透明的HttpSession支持。参见<a href="http://shiro.apache.org/web.html" target="_blank" rel="external">Apache Shiro web documentation</a></p>
<h4 id="Web-Session-Management"><a href="#Web-Session-Management" class="headerlink" title="Web Session Management"></a>Web Session Management</h4><p>最后，有趣的是探讨Shiro在web环境中对session的支持。</p>
<h5 id="Default-Http-Sessions"><a href="#Default-Http-Sessions" class="headerlink" title="Default Http Sessions"></a>Default Http Sessions</h5><p>对web应用而言，Shiro默认的session架构是我们现有常使用的Servlet Container。当你调用<code>subject.getSession()</code>和<code>subject.getSession(boolean)</code>方法的时候，Shiro会返回一个由Servlet 容器支持的session实例。这种方法的优点是调用subject.getSession（）的业务层代码与Shiro Session实例进行交互–它并不知道是和一个基于web的HTTPSession对象一起工作的。分层架构保持代码整洁是很好的做法。</p>
<h5 id="Shiro’s-Native-Sessions-in-the-Web-Tier"><a href="#Shiro’s-Native-Sessions-in-the-Web-Tier" class="headerlink" title="Shiro’s Native Sessions in the Web Tier"></a>Shiro’s Native Sessions in the Web Tier</h5><p>假如你在web应用中开启了Shiro的本地session管理，你需要Shiro的企业session特性（类似独立于容器的集群），当然你想<code>HttpServletRequest.getSession()</code> 和<code>HttpSession</code> API和本地session一起使用而不是servlet容器的session。如果你要重构任何使用HttpServletRequest和HttpSession API的代码，而不是使用Shiro的Session API，那将是非常令人沮丧的。Shiro永远不期望你这样做。相反，Shiro完全实现了Servlet规范的Session部分，以支持Web应用程序中的本机会话。这意味着每当你调用相应的HttpServletRequest或HttpSession方法调用时，Shiro会将这些调用委托给其内部本地Session API。结果就是你不需要去改动你的代码，即使你使用Shiro本地会话管理–实际上是一个非常方便和必要的特性。</p>
<h3 id="Additional-Features"><a href="#Additional-Features" class="headerlink" title="Additional Features"></a>Additional Features</h3><p>在Shiro框架中其他用于让Java应用安全的特性，例如（中文翻译太晦涩，还是直接贴原文的）：</p>
<ul>
<li>Threading and Concurrency support for maintaining Subjects across threads (Executor and ExecutorService support)</li>
<li>Callable and Runnable support for executing logic as a specific Subject</li>
<li>“Run As” support for assuming the identity of another Subject (e.g. useful in administrative applications)</li>
<li>Test harness support, making it very easy to have full testing of Shiro secured-code in unit and integration tests</li>
</ul>
<h3 id="Framework-Limitations"><a href="#Framework-Limitations" class="headerlink" title="Framework Limitations"></a>Framework Limitations</h3><p>就像我们想要的那样，Apache Shiro不是一个“银弹”–它不会轻易解决所有安全问题。Shiro没有解决这些事情:</p>
<ul>
<li>虚拟机级别的考虑：当前Shiro没有考虑虚拟机级别的安全，比如基于访问控制策略的阻止特定的class加载到类加载器中。然而Shiro和现有的JVM安全操作整合起来是不可思议的–只是没有人去为这个项目做这件事罢了。</li>
<li>多阶段认证：Shiro当前不支持‘多阶段’认证，用户可以通过一种机制登录，只能被要求使用不同的机制再次登录。这已经在基于Shiro的应用程序中完成，但应用程序通过应用程序收集所有必需的信息，然后与Shiro进行交互。很可能在未来的版本中会有这种支持。</li>
<li>写域操作：当前所有的域实现支持读操作来获取认证和授权数据用来执行登录和访问控制。写操作，像创建用户，组和角色或者将用户和角色组及权限关联起来都是不支持的。这是因为支持这些操作的数据模型在应用程序中有很大差异，所以在所有Shiro用户上执行“写入”API将是困难的。</li>
</ul>
<h3 id="Upcoming-Features"><a href="#Upcoming-Features" class="headerlink" title="Upcoming Features"></a>Upcoming Features</h3><p>Shiro的社区每天都很活跃，Shiro的特性也在变多。在接下来的版本中你将看到:</p>
<ul>
<li>简洁的web filter机制，允许更多的可插拔的过滤器支持，而不是通过子类。</li>
<li>更多可插拔的默认有利于组合继承的域实现。你将能够插拔查找身份验证和授权数据的组件，而不是要求你对Shiro Realm实现进行子类实现。</li>
<li>强大的OpenID和OAuth（或者都有）客户端支持</li>
<li>验证码支持</li>
<li>100％无状态应用程序（例如许多REST环境）更容易配置。</li>
<li>通过请求/响应协议进行多级认证。</li>
<li>通过AuthorizationRequest进行粗粒度授权。</li>
<li><a href="http://www.antlr.org/" target="_blank" rel="external">ANTLR</a>语法用于安全断言查询（例如（’role（admin）&amp;&amp;（guest ||！group（developer））’）</li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Apache Shiro是一个功能齐全，功能强大且通用的Java安全框架，可用于保护你的应用程序。通过简化应用安全性的四个方面，即认证，授权，会话管理和密码，应用安全性在实际应用中更容易理解和实现。Shiro的简单架构和JavaBeans兼容性允许在几乎任何环境中进行配置和使用。额外的网络支持和辅助功能，如对多线程和测试的支持，整合框架，为应用程序安全性提供可能是你的“一站式”服务。Apache Shiro的开发团队继续前进，改进代码库并支持社区。随着开源代码和商业化的采用，Shiro只会越来越强。</p>
<h3 id="About-the-Author"><a href="#About-the-Author" class="headerlink" title="About the Author"></a>About the Author</h3><p>Les Hazlewood是Shiro PMC主席，Katasoft的联合创始人兼首席技术官，专注于应用程序安全产品和对Apache Shiro的支持。Les拥有10年的Java开发和企业架构师经验，曾在Bloomberg, Delta Airlines, 和 JBoss担任过高级职务。Les一直在积极参与开源开发9年以上，为Spring Framework，Hibernate，JBoss，OpenSpaces以及Apache Shiro的前身JSecurity等项目提交或贡献过代码。Les目前住在加州圣马特奥，并且在不编程的时候练习剑道和研究日语。</p>
<p>查看英文原文： <a href="https://www.infoq.com/articles/apache-shiro" target="_blank" rel="external">Application Security With Apache Shiro</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你为你的应用添加安全措施的时候有没有觉得很受挫？你有没有觉得Java在安全这一块的解决方案用起来很难，让你更加觉得困惑？这篇文章介绍&lt;a href=&quot;http://shiro.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apac
    
    </summary>
    
      <category term="Apache" scheme="http://www.wei-dong.top/categories/Apache/"/>
    
    
      <category term="Apache Shiro" scheme="http://www.wei-dong.top/tags/Apache-Shiro/"/>
    
      <category term="翻译" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Features（Part Ⅱ）</title>
    <link href="http://www.wei-dong.top/2017/08/10/spring-boot-fatures-2/"/>
    <id>http://www.wei-dong.top/2017/08/10/spring-boot-fatures-2/</id>
    <published>2017-08-10T13:58:23.000Z</published>
    <updated>2017-08-10T13:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇继续针对上一篇文章对spring boot 未介绍完的feature进行补充。<br><a id="more"></a> </p>
<h3 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h3><p>用过maven都知道，maven中有个profiles的设置。</p>
<blockquote>
<p>profile一个非常重要的特性就是它可以根据不同的环境来激活，比如说根据操作系统的不同激活不同的profile，也可以根据jdk版本的不同激活不同的profile.<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </div><div class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>profileTest1<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </div><div class="line">              <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>  </div><div class="line">       <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的配置就是当JDK版本为1.5的时候激活profileTest1。<br>spring boot也提供这么一种机制。在特定的环境下使用特定的配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Profile</span>(<span class="string">"production"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的配置就是在production环境下生效。通常在<code>application.properties</code>这个文件下配置<code>spring.profiles.active=xxx</code>属性来指定不同的profile。当然使用命令行也是可以的。</p>
<p>其实这个feature不算什么特性，很一般。</p>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>spring boot 内部的日志是使用的Common Logging，但是也提供很多其他的实现。默认还提供JUL、Log4J和Logback。</p>
<p>日志输出文本的颜色是可以设置的，假如控制台支持ANSI的话，然而我觉得并没卵用。默认情况下，日志只会输出到控制台，不会输出到文件。加入要输出到文件就需要在同样在<code>application.properties</code>文件中配置一下这几个属性了：<code>logging.file</code> <code>logging.path</code>。文件名不写的话默认为<code>spring.log</code>，路径不写的话默认在当前路径下。日志文件到10m的时候就回重新生成一个新的文件。</p>
<p>给日志设置级别就不多提了，都是很老掉牙的东西了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">logging.level.root=WARN</div><div class="line">logging.level.org.springframework.web=DEBUG</div><div class="line">logging.level.org.hibernate=ERROR</div></pre></td></tr></table></figure></p>
<p>自定义日志组件也是比较方便的，每个日志框架都有所不同嘛。spring boot提供这种热插拔式的配置。在配置文件中指定<code>logging.config</code>的值即可。这个属性代表着日志配置文件的位置。不同的日志系统有不同的配置文件。</p>
<ul>
<li><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code>是logback的。</li>
<li><code>log4j2-spring.xml</code>, <code>log4j2.xml</code>是log4j2的。</li>
<li><code>logging.properties</code>是JUL的。<br>日志系统没什么可说的，对我而言，使用默认的就完事儿了。</li>
</ul>
<p>基本上核心feature全部梳理完了。接下来看看Web Applications Features。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>spring boot也适合web开发，使用<code>spring-boot-starter-web</code>模块很快就能搭建一个HTTP应用。<br>使用过Spring MVC的开发者来讲，这个feature一点都不新鲜。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.GET)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;/customers"</span>, method=RequestMethod.GET)</div><div class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;user&#125;"</span>, method=RequestMethod.DELETE)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteUser</span><span class="params">(@PathVariable Long user)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个栗子使用<code>@RestController</code>注解来返回JSON数据。<br>还有很多更详细的内容，可以参见<a href="http://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/htmlsingle/#mvc" target="_blank" rel="external">spring framework 官方文档</a></p>
<h3 id="Working-with-SQL-databases"><a href="#Working-with-SQL-databases" class="headerlink" title="Working with SQL databases"></a>Working with SQL databases</h3><p>spring boot中对数据库的支持可以说是爽翻天。</p>
<p>首先得创建一个数据源，废话不多说：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"app.datasource"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FancyDataSource();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.datasource.url=jdbc:h2:mem:mydb</div><div class="line">app.datasource.username=sa</div><div class="line">app.datasource.pool-size=30</div></pre></td></tr></table></figure>
<p>意思就是这么个意思，配置方式多种多样。不仅仅可以支持外部数据库，内存数据库也是支持的。例如H2、HSQL和Derby，在spring boot中只需要提供一个依赖她就能自动配置，就是这么厉害。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在对外部数据库的连接管理中，spring boot使用的是池化的数据源。对于使用何种池化方式，策略是这样的：Tomcat的连接池&gt;HikariCP&gt;DBCP(不推荐，因为没人去维护了)&gt;DBCP2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spring.datasource.url=jdbc:mysql://localhost/test</div><div class="line">spring.datasource.username=dbuser</div><div class="line">spring.datasource.password=dbpass</div><div class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</div></pre></td></tr></table></figure></p>
<p>其中的url是一定要写的，不然的话spring boot去自动去配置内嵌的数据库了。driver可以不指定，因为可以通过url去判断driver。</p>
<p>说完数据源，再聊聊JdbcTemplate。这个东西在spring boot中用起来是非常爽，直接就能用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仅此而已！</p>
<p>关于spring data和JPA 的介绍也没有多解释，文档说很多细节让我们去<a href="https://spring.io/guides/gs/accessing-data-jpa/" target="_blank" rel="external">这里</a>看看，看来还是比较复杂。</p>
<p>在传统的JPA中entity需要在<code>persistence.xml</code>中定义。但在spring boot中不需要这么麻烦，因为她能帮你扫描到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Entity</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Id</span></div><div class="line">    <span class="meta">@GeneratedValue</span></div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line"></div><div class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> String state;</div><div class="line"></div><div class="line">    <span class="comment">// ... additional members, often include @OneToMany mappings</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// no-args constructor required by JPA spec</span></div><div class="line">        <span class="comment">// this one is protected since it shouldn't be used directly</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.country = country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ... etc</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Spring Data JPA Repositories是一个好东西，JPA查询可以根据你方法的名字来。举个栗子，<code>CityRepository</code>接口定义一个<code>findAllByState(String state)</code>方法，你传一个state条件它就能查出来。</p>
<p>然而这仅仅只是一小部分，文档有句话细思极恐：</p>
<blockquote>
<p>We have barely scratched the surface of Spring Data JPA.</p>
</blockquote>
<p>spring boot对NoSQL也有支持。像MongoBD、Neo4J、Elasticsearch、Solr、Redis、 Gemfire、Cassandra、Couchbase 和LDAP。</p>
<p>Redis:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> StringRedisTemplate template;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.template = template;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用redis除了添加<code>spring-boot-starter-data-redis</code>依赖外，想用的话如上面代码一样简单。</p>
<p>MongoDB：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MongoDbFactory mongo;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDbFactory mongo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mongo = mongo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</div><div class="line">        DB db = mongo.getDb();</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mongodb同样也是如此，假如你的mongoDB采用分片的话，这样指定url就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</div></pre></td></tr></table></figure></p>
<p>如果使用的是2.x的版本，这样去配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.data.mongodb.host=mongoserver</div><div class="line">spring.data.mongodb.port=27017</div></pre></td></tr></table></figure></p>
<p>MongoTemplate用起来更加方便：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mongoTemplate = mongoTemplate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他的文档中也没多去解释，丢了个链接让读者自己去看。所以这里也不多去关注了。需要的时候再整理。</p>
<p>spring boot也提供对JMS的支持，这也算是一个feature吧。</p>
<p>JMS在Java中只定义了一些接口，具体实现还是依赖各个厂商。其中ActiveMQ就是一个JMS的标准实现，spring boot对其有比较好的支持。</p>
<p>同样的，只需要添加<code>spring-boot-starter-activemq</code>依赖，spring boot就能帮你自动去配置，当然少不了最基本的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">spring.activemq.broker-url=tcp://192.168.1.210:9876</div><div class="line">spring.activemq.user=admin</div><div class="line">spring.activemq.password=secret</div></pre></td></tr></table></figure></p>
<p>当然使用连接池也是可以的，添加这个依赖即可：<code>org.apache.activemq:activemq-pool</code>，同时做如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">spring.activemq.pool.enabled=true</div><div class="line">spring.activemq.pool.max-connections=50</div></pre></td></tr></table></figure></p>
<p>至于具体怎么去使用这里不再详细描述，使用到的时候再去<a href="http://docs.spring.io/spring-boot/docs/1.5.6.RELEASE/reference/htmlsingle/#boot-features-jms" target="_blank" rel="external">这里</a>翻翻文档看看。</p>
<h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>对于一个框架来讲，测试一定是少不了的。spring boot提供了很多工具而注解来帮助开发者测试代码。有两个模块需要依赖：<code>spring-boot-test</code>和<code>spring-boot-test-autoconfigure</code>。前者提供基础支持，后者提供自动配置。许多开发者只会选择前者，前者提供JUnit、AssertJ、Hamcrest及其他有用的工具包。</p>
<p>当你添加<code>spring-boot-starter-test</code>依赖时，你会发现很多库被添加进来了：</p>
<ul>
<li>JUnit</li>
<li>Spring Test</li>
<li>AssertJ</li>
<li>Hamcrest</li>
<li>Mockito</li>
<li>JSONassert</li>
<li>JsonPath<br>依赖注入的一个最大的好处就是让单元测试变得更简单。在spring framework的测试框架中，常常使用<code>@ContextConfiguration(classes=…​)</code>这样的配置，或者在你的测试中使用嵌套的<code>@Configuration</code>类。在spring boot中不需要这么麻烦，<code>@*Test</code>会自动去找你的配置。</li>
</ul>
<p>在某些情况下，我们不需要自动去找测试的配置，我们可以自己手动指定配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</div><div class="line"><span class="meta">@SpringBootTest</span></div><div class="line"><span class="meta">@Import</span>(MyTestsConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至于其他内容都没什么可讲的，无非就是一些annotation的使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>spring boot的一些比较有意思的feature基本上都梳理一遍了，当然也有许多没有很具体描述的地方。整个篇幅太长太多，很多细节的地方也没有很注意到，有些表述和文字组织还是非常欠缺，这都是自己对英文版的技术文档拿捏不是很准造成的。我想我整理的东西也只有我自己能看懂了。当然目前只是一个profile，很多坑还需要自己去踩的，只能在以后的工作及学习中慢慢总结，我想没有谁是仅仅通过看了一下文档就能写出漂亮的代码来吧。</p>
<p>接下来spring boot系列内容可能就更全面，具体整理哪些东西以后想到在说。毕竟这次的feature只是试试水。我也希望我对英文技术文档的理解有更加质的提升。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇继续针对上一篇文章对spring boot 未介绍完的feature进行补充。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Framework" scheme="http://www.wei-dong.top/categories/Spring-Framework/"/>
    
    
      <category term="Spring Boot" scheme="http://www.wei-dong.top/tags/Spring-Boot/"/>
    
      <category term="翻译&amp;整理" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91-%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Features（Part I）</title>
    <link href="http://www.wei-dong.top/2017/08/05/spring-boot-fatures/"/>
    <id>http://www.wei-dong.top/2017/08/05/spring-boot-fatures/</id>
    <published>2017-08-05T08:59:23.000Z</published>
    <updated>2017-08-05T09:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在spring boot官方文档中介绍了不少feature，我觉得有必要整理一下，还是挺有意思的。<br><a id="more"></a> </p>
<p>文档中根据功能作出了以下区分：</p>
<ul>
<li>Core Feature： SpringApplication（Spring应用）| Externalized Configuration（外部配置）| Profiles（轮廓）| Logging（日志） </li>
<li>Web Applications： MVC（不解释）| Embedded Containers（内嵌的容器）</li>
<li>Working with data：SQL | NO-SQL</li>
<li>Messaging: JMS（Java消息服务）</li>
<li>Testing: Boot Applications | Utils （测试相关）</li>
<li>Extending: Auto-configuration | @Conditions （拓展）</li>
</ul>
<p>以上的feature用中文翻译起来很不容易理解，这些专业术语用英文表示更让人觉得熟悉。现在就针对某个feature单独去理解。</p>
<h3 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h3><p>这个特性可以说是spring boot的创新。在以往的web程序开发过程中，我们通常将自己的程序部署在tomcat或者weblogic类似的中间件上的，但使用spring boot不需要依耐这样的中间件。使用spring boot启动你的应用就像启动一个简单的程序一样，类似我们刚接触Java写的一个个的main函数一样。它只需要这样的代码就能启动一个web应用了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    SpringApplication.run(MySpringConfiguration.class, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正常启动肯定是没什么可讲的，问题是出了问题就很难受了。没关系，spring boot同样为开发者提供了很好的解决方案。spring boot提供<code>FailureAnalyzers</code>帮助你修复问题。比方说，假如你在8080端口上启动web应用，然而这个端口被占用了，这时候控制台会报出这样的错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">***************************</div><div class="line">APPLICATION FAILED TO START</div><div class="line">***************************</div><div class="line"></div><div class="line">Description:</div><div class="line"></div><div class="line">Embedded servlet container failed to start. Port 8080 was already in use.</div><div class="line"></div><div class="line">Action:</div><div class="line"></div><div class="line">Identify and stop the process that&apos;s listening on port 8080 or configure this application to listen on another port.</div></pre></td></tr></table></figure></p>
<p>通过控制台打印出的错误信息，很容易知道问题出哪里了（英文水平不要太low）。当然这是使用默认的<code>FailureAnalyzers</code>，spring boot 也提供自己定义的<code>FailureAnalyzers</code>。在<code>META-INF/spring.factories</code>这个文件中有这样的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Failure Analyzers</div><div class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</div><div class="line">org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\</div><div class="line">org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer</div></pre></td></tr></table></figure></p>
<p>发现了这个<code>PortInUseFailureAnalyzer</code>类吗？这个就是处理端口绑定失败的Analyzer。我们如果要自己定义一个这样的Analyzer很简单。创建一个类，继承<code>AbstractFailureAnalyzer</code>，其中的泛型可以是任何异常。重写其<code>analyze</code>方法，根据传入的参数进行处理，如果没办法处理那就返回一个<code>null</code>,这时候将由下一个Analyzer去处理。如果可以处理，直接返回一个<code>FailureAnalysis</code>对象即可。这个对象和<code>Execption</code>很类似，无非就是一些错误信息罢了。这个是我定义的一个Analyzer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFailureAnalyzer</span> <span class="keyword">extends</span> <span class="title">AbstractFailureAnalyzer</span>&lt;<span class="title">NullPointerException</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleFailureAnalyzer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out.println(<span class="string">"我是自定义的FailureAnalyzer，我开始搞事情了！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> FailureAnalysis <span class="title">analyze</span><span class="params">(Throwable rootFailure, NullPointerException cause)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"正在搞事情。。。"</span>);</div><div class="line">        System.out.println(<span class="string">"获取这个异常:"</span>);</div><div class="line">        String message = cause.getMessage();</div><div class="line">        System.out.println(message);</div><div class="line">        System.out.println(<span class="string">"事情搞完了，但是不想处理"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义这个类还没结束，还要创建一个<code>META-INF/spring.factories</code>文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</div><div class="line">com.dw.simpledemo.failureanalyzer.SimpleFailureAnalyzer</div></pre></td></tr></table></figure></p>
<p>除了这种方式诊断问题之外，还可以这样去发现问题。可以设置日志的级别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">logging:</div><div class="line">  level:</div><div class="line">    root: WARN</div><div class="line">    org.springframework: DEBUG</div><div class="line">    org.hibernate: ERROR</div></pre></td></tr></table></figure></p>
<p>假如你使用的是Java命令行的方式去启动你的app可以在命令后加这样的参数<code>java -jar myproject-0.0.1-SNAPSHOT.jar --debug</code>，以debug的方式去启动。（我相信这种方式会让你的控制台爆炸，满屏都是日志，2333333。）<br>启动失败的问题分析我觉得不算特别有创新的feature，毕竟一般情况下通过报错也能找到问题出哪里了。</p>
<p>这个feature我觉得算是一个比较有意思的，虽然我觉得没什么屌用，只能算个彩蛋吧23333.<br>在我们点击<code>run</code>的时候控制台会打印一个ASCII的字符画。开始以为这个是spring boot自带的，其实这个也可以自定义的。<br>在类路径下创建一个banner.txt文件，内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$&#123;AnsiColor.BRIGHT_YELLOW&#125;</div><div class="line">////////////////////////////////////////////////////////////////////</div><div class="line">//                          _ooOoo_                               //</div><div class="line">//                         o8888888o                              //</div><div class="line">//                         88&quot; . &quot;88                              //</div><div class="line">//                         (| ^_^ |)                              //</div><div class="line">//                         O\  =  /O                              //</div><div class="line">//                      ____/`---&apos;\____                           //</div><div class="line">//                    .&apos;  \\|     |//  `.                         //</div><div class="line">//                   /  \\|||  :  |||//  \                        //</div><div class="line">//                  /  _||||| -:- |||||-  \                       //</div><div class="line">//                  |   | \\\  -  /// |   |                       //</div><div class="line">//                  | \_|  &apos;&apos;\---/&apos;&apos;  |   |                       //</div><div class="line">//                  \  .-\__  `-`  ___/-. /                       //</div><div class="line">//                ___`. .&apos;  /--.--\  `. . ___                     //</div><div class="line">//              .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.                  //</div><div class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</div><div class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</div><div class="line">//      ========`-.____`-.___\_____/___.-`____.-&apos;========         //</div><div class="line">//                           `=---=&apos;                              //</div><div class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</div><div class="line">//            佛祖保佑       永不宕机     永无BUG                  //</div><div class="line">////////////////////////////////////////////////////////////////////</div></pre></td></tr></table></figure></p>
<p>这样你的app在启动的时候就会打印这样的字符画了。个人觉得除了装b没有任何卵用。自己去定义这些字符画的生成程序也是可以的，<code>org.springframework.boot.Banner</code>这个接口就是定义怎么去实现banner的打印的，具体怎么处理可以看看它的实现类。闲的没事可以去折腾这些玩意儿！当然不想看到这些东西也是可以的。在yml文件中这样配置一下就完事儿了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">    main:</div><div class="line">        banner-mode: &quot;off&quot;</div></pre></td></tr></table></figure></p>
<p>同样的配置写成<code>application.properties</code>也是OK的。<br>然鹅，硬编码也是可以的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(MySpringConfiguration.class);</div><div class="line">    app.setBannerMode(Banner.Mode.OFF);</div><div class="line">    app.run(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来的这个feature就比较实用了。我们用的是spring boot当然少不了核心的spring的特性呀，毕竟都姓spring嘛2333！</p>
<p>我们有时候需要在spring容器启动的时候搞一些事情，spring framework也提供了这样的一种机制去帮助我们完成。它定义了很多事件来抽象出这些操作，比如说<code>ContextRefreshedEvent</code>这个事件就是当容器初始化或者被刷新了会触发。</p>
<p>我们注册一个bean可以通过<code>@Bean</code>去完成，bean的注册需要依赖容器被创建，但是创建之前的一些操作我们没办法通过<code>@Bean</code>来完成。spring boot中可以这样去设置<code>SpringApplication.addListeners(…​)</code>或者<code>SpringApplicationBuilder.listeners(…​)</code>去添加你关心的事件.当然这种方式是使用硬编码完成的，不够敞亮不够spring。可以在<code>META-INF/spring.factories</code>文件中去指定。这是默认配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Application Listeners</div><div class="line">org.springframework.context.ApplicationListener=\</div><div class="line">org.springframework.boot.ClearCachesApplicationListener,\</div><div class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</div><div class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</div><div class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</div><div class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</div><div class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</div><div class="line">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener,\</div><div class="line">org.springframework.boot.logging.ClasspathLoggingApplicationListener,\</div><div class="line">org.springframework.boot.logging.LoggingApplicationListener</div></pre></td></tr></table></figure></p>
<p>同样，自己去按照这样的写法去整一个自己定义的listener也是ok的，这很spring！文档中给了一段话：我们通常很少去用这个application event，但是我们知道他们存在是很有必要的。spring boot 通过他们完成很多任务。其实在做技术的过程中，也是这个道理，很多时候有些东西我们不常用，但是我们必须知道有这么个东西，说不定在什么时候就派上用场了。</p>
<p>这个feature我觉得没太多用处，毕竟我目前接触到spring boot不是很深入。spring boot启动入口是通过<code>main</code>函数，其中有<code>String[] args</code>作为参数传进来。spring boot提供<code>ApplicationArguments</code>接口让我们直接获取传入的参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">"debug"</span>);</div><div class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</div><div class="line">        <span class="comment">// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>个人觉得使用这种方式很low，将参数直接写到配置文件中去，让app启动时候去读配置不完了？</p>
<p>如果你需要在SpringApplication启动前去做点别的事情，spring boot同样能够实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</div><div class="line">        <span class="comment">// Do something...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现<code>ApplicationRunner</code>接口同样也能达到效果。这个接口中的<code>run</code>方法参数就是上面提到的<code>ApplicationArguments</code>用来获取启动参数的。区别就在于一个只能获取<code>String</code>数组类型的参数，一个能获取<code>ApplicationArguments</code>类型的参数。</p>
<p>至此，关于Core Features: SpringApplication 的内容都梳理完了。下一个feature要讲的是Core Features: External Configuration。</p>
<h3 id="Externalized-Configuration"><a href="#Externalized-Configuration" class="headerlink" title="Externalized Configuration"></a>Externalized Configuration</h3><p>说实话，这个词中文翻译真的很难表达它想传达出的意思。作为名词的直译就是外部配置，作为动词翻译过来就是外部化配置。真的让人摸不到头脑。</p>
<p>仔细去读读内容，其实也就是一个关键词：配置。通过配置，可以让你的应用在不同环境中跑同一套代码。可以使用properties文件、YAML文件、environment变量、及命令行参数去使你的参数生效。配置参数可以通过使用<code>@Value</code>注解直接注入到你的bean中。spring boot中的配置属性是遵循一个优先级的：</p>
<ol>
<li>全局配置（当devtools生效的时候 ~/.spring-boot-devtools.properties文件作为全局配置文件）。</li>
<li><code>@TestPropertySource</code>注解配置在你的测试用例中。</li>
<li><code>@SpringBootTest#properties</code>注解属性值被设置在你的测试用例中。</li>
<li>命令行参数。</li>
<li>environment variable(启动时候可以设置的参数，类似于program arguments)或者系统参数。</li>
<li><code>ServletConfig</code>初始化参数。</li>
<li><code>ServletContext</code>初始化参数。</li>
<li><code>java:comp/env</code>JNDI参数。</li>
<li>Java System properties(System.getProperties()).</li>
<li>OS environment variables.</li>
<li>A <code>RandomValuePropertySource</code> that only has properties in random.*.(啥啥啥，说啥呢)</li>
<li>jar包外的<code>application-{profile}.properties</code>配置文件或者YAML文件。</li>
<li>jar包内的…(同上)。</li>
<li>jar包外的<code>application.properties</code>文件或者YAML文件。</li>
<li>jar包内的…(同上)。</li>
<li>在<code>@Configuration</code>注解过的类上的<code>@PropertySource</code>属性（貌似读不通）。</li>
<li>默认属性。<br>一个栗子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>application.properties</code>中有name这个属性就会被自动赋值给name字段。<code>java -jar app.jar --name=&quot;Spring&quot;</code>这种方式name就是从命令行中去读取。</p>
<p>我们的配置文件除了<code>application.properties</code>还有这种形式的：<code>application-{profile}.properties</code>这个profile决定你代码运行的环境。可以是dev、prod等等。具体去加载哪个配置文件取决于<code>spring.profiles.active</code>这个属性到底是什么。与之对应即可。如果有多个<code>application-{profile}.properties</code>文件出现，最后出现的生效。</p>
<p>spring推荐使用YMAL作为配置文件。它是JSON的超集。spring framework提供了2个方便的类加载YMAL文件：<code>YamlPropertiesFactoryBean</code>和<code>YamlMapFactoryBean</code>。前者加载成一个<code>Properties</code>，后者加载成一个<code>Map</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my:</div><div class="line">   servers:</div><div class="line">       - dev.bar.com</div><div class="line">       - foo.bar.com</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"my"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getServers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.servers;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看上去有种很酸爽的感觉。</p>
<p>在一个YMAL文件中也可以指定不同的profile的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server:</div><div class="line">    address: 192.168.1.100</div><div class="line">---</div><div class="line">spring:</div><div class="line">    profiles: development</div><div class="line">server:</div><div class="line">    address: 127.0.0.1</div><div class="line">---</div><div class="line">spring:</div><div class="line">    profiles: production</div><div class="line">server:</div><div class="line">    address: 192.168.1.120</div></pre></td></tr></table></figure></p>
<p><code>server.address</code>属性在不同的profile中是不同的。<code>development</code>被激活了，就使用<code>127.0.0.1</code>.其他类似。都没激活就使用默认的<code>192.168.1.100</code>.<br>然而这种方式有缺点，不能通过<code>@PropertySource</code>注解直接注入到bean属性中。</p>
<p>spring针对<code>@Value(&quot;${property}&quot;)</code>这种方式去注入属性提供一个替换。那就是使用<code>@ConfigurationProperties(&quot;foo&quot;)</code>来放到你要注入的类中。字段名对应即可，即使有那种继承结构也没关系。YMAL本身对这种继承结构支持的很好。</p>
<p>关于Externalized Configuration的梳理也差不多了。各种炫酷屌炸天。</p>
<p>剩下的在以后几篇文章中继续整理。越来越有趣了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在spring boot官方文档中介绍了不少feature，我觉得有必要整理一下，还是挺有意思的。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Framework" scheme="http://www.wei-dong.top/categories/Spring-Framework/"/>
    
    
      <category term="Spring Boot" scheme="http://www.wei-dong.top/tags/Spring-Boot/"/>
    
      <category term="翻译&amp;整理" scheme="http://www.wei-dong.top/tags/%E7%BF%BB%E8%AF%91-%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>动态代理番外篇</title>
    <link href="http://www.wei-dong.top/2017/07/16/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%95%AA%E5%A4%96%E7%AF%87/"/>
    <id>http://www.wei-dong.top/2017/07/16/动态代理番外篇/</id>
    <published>2017-07-16T06:55:23.000Z</published>
    <updated>2017-07-16T06:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中说到动态代理的实现除了JDK还有第三方的实现。现在就来瞧瞧JDK之外的动态代理的实现。<a id="more"></a> </p>
<h2 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h2><p>这个库在Github上有1390颗星星，下面是对Cglib的描述。</p>
<blockquote>
<p>cglib is a powerful, high performance and quality Code Generation Library, It is used to extend JAVA classes and implements interfaces at runtime. </p>
</blockquote>
<p>说到使用这个库的框架，其中大名鼎鼎的Hibernate就用到了，当然还有Spring。 Spring的AOP默认使用JDKProxy，如果被代理的类没有实现接口就使用Cglib去生成动态代理类。</p>
<p>它的出现是为了弥补JDK动态代理中不能对未实现接口的类进行代理。其原理也可想而知了，无非就是动态生成一个子类，这个子类继承了要代理的类，然后去重写父类（需要代理的类）的方法。这样的话，代理类就一定不能是final类型了，需要代理的方法也不能是final。因为Java不允许继承final类，不允许重写final方法。<br>下面通过一个实例来介绍Cglib实现动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 需要被代理的目标类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span>  </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello ,"</span>+ name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"TargetClass&#123;&#125;"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 目标对象拦截器，实现MethodInterceptor</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetIncerceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写方法拦截在方法前和方法后加入业务</div><div class="line">     * <span class="doctag">@param</span> o 为目标对象</div><div class="line">     * <span class="doctag">@param</span> method 为目标方法</div><div class="line">     * <span class="doctag">@param</span> objects 为参数</div><div class="line">     * <span class="doctag">@param</span> methodProxy CGlib方法代理对象 </div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"调用前"</span>);</div><div class="line">        Object result = methodProxy.invokeSuper(o, objects);</div><div class="line">        System.out.println(<span class="string">" 调用后"</span>+result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">        enhancer.setSuperclass(TargetClass.class);</div><div class="line">        enhancer.setCallback(<span class="keyword">new</span> TargetIncerceptor());</div><div class="line">        TargetClass targetClass = (TargetClass) enhancer.create();</div><div class="line"></div><div class="line">        String hello = targetClass.hello(<span class="string">"dw"</span>);</div><div class="line">        System.out.println(hello);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从表面上来看和JDK的使用还是有类似的地方的。Cglib使用<code>Enhancer</code>来去装载父类，将方法拦截器植入到生成的子类字节码中，最后创建对象。Cgilb依赖ASM字节码框架去动态生成字节码，具体生成出来的字节码文件和JDK动态代理生成出来的差别很大，区别就在于Cglib生成的代理类没有使用反射去调用要被代理的方法。从这里就可以看出Cglib在执行效率上要比JDK动态代理要高，毕竟反射效率是很低的。</p>
<h2 id="Byte-Buddy"><a href="#Byte-Buddy" class="headerlink" title="Byte Buddy"></a>Byte Buddy</h2><p>这个类库是最近看一个RPC框架代码的时候发现的。起因是自己想尝试着写一个简单的远程方法调用的样例程序，在Github上找到了一个简单的基于Netty的实现，其中在处理动态代理的时候除了使用JDK的实现还有一个额外的实现，那就是Byte Buddy。然后稍微研究了一番，发现使用这个类库写动态代理确实很方便。</p>
<p>废话不多讲，先简单的看代码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name)</span></span>;</div><div class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name,<span class="keyword">int</span> time)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span>+name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name, <span class="keyword">int</span> time)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> time+<span class="string">" Hello "</span>+name ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"nothing"</span>+i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuddyProxy</span> </span>&#123;</div><div class="line">	<span class="comment">//创建代理对象</span></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz,Object handler)</span></span>&#123;</div><div class="line"></div><div class="line">        Class&lt;? extends T&gt; cls = <span class="keyword">new</span> ByteBuddy()</div><div class="line">                .subclass(clazz)</div><div class="line">                .method(ElementMatchers.isDeclaredBy(clazz))</div><div class="line">                .intercept(MethodDelegation.to(handler))</div><div class="line">                .make()</div><div class="line">                .load(clazz.getClassLoader(), ClassLoadingStrategy.Default.INJECTION)</div><div class="line">                .getLoaded();</div><div class="line"></div><div class="line">        T t = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           t = cls.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ByteBuddyProxy proxy = <span class="keyword">new</span> ByteBuddyProxy();</div><div class="line">        Hello hello = proxy.getInstance(Hello.class, <span class="keyword">new</span> Invoker(HelloImpl.class));</div><div class="line">        hello.sayHi(<span class="number">1</span>);</div><div class="line">        String sayHi = hello.sayHi(<span class="string">"dongwei"</span>,<span class="number">9</span>);</div><div class="line">        System.out.println(sayHi);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//暂时理解为和JDK Proxy中的InvocationHandler一样的东西吧</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.clazz = clazz;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@RuntimeType</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(@Origin Method method, @AllArguments @RuntimeType Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Object result = method.invoke(clazz.newInstance(),args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是一个很简单的小栗子，还有很多复杂的特性没有深入研究。我只能对写这个库的作者表示很崇高的敬佩！</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然除了文章中所介绍的生成动态代理的工具还有很多没有提及，比方说javaassit等。其原理大致类似，无非就是在JVM加载字节码的时候将字节码给替换了或者改掉了，很多都依赖于ASM库，如果对class字节码规范很熟悉的话自己也可以使用ASM来写一个字节码生成工具。<br>从阅读别人写的RPC框架的源码中发现了很多有意思的东西，从其中的动态代理可以了解到字节码生成加载。慢慢才发现写代码真的不是想象中那么简单的，变化的东西太多了，也只有时刻保持着学习的态度也才可能跟得上节奏，才不会被淘汰。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中说到动态代理的实现除了JDK还有第三方的实现。现在就来瞧瞧JDK之外的动态代理的实现。
    
    </summary>
    
      <category term="OPEN SOURCE" scheme="http://www.wei-dong.top/categories/OPEN-SOURCE/"/>
    
    
      <category term="字节码工具" scheme="http://www.wei-dong.top/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>动态代理之JDK实现</title>
    <link href="http://www.wei-dong.top/2017/07/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B9%8BJDK%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.wei-dong.top/2017/07/09/动态代理之JDK实现/</id>
    <published>2017-07-09T02:29:23.000Z</published>
    <updated>2017-07-09T02:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近呢，看到了一个开源的PRC FRAMEWORK，当然不是Dubbo。然后想去了解一下RPC到底是怎么去实现的。于是乎就了解了一番，发现其灵魂在于动态代理和反射。<a id="more"></a> </p>
<h5 id="What’s-Dynamic-Proxy"><a href="#What’s-Dynamic-Proxy" class="headerlink" title="What’s Dynamic Proxy ?"></a>What’s Dynamic Proxy ?</h5><p>在讲什么是动态代理前先得明白什么是代理。在日常生活中的代理其实就是委托的意思。将事情交代给委托对象去做，这就是代理。程序中的代理是什么意思呢？这里更准确的解释应该是一种设计模式–代理模式（Proxy)<br><img src="http://img.my.csdn.net/uploads/201211/29/1354197582_1664.PNG" alt="Proxy"><br>下面给出一个简单的关于代理的Java实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	<span class="comment">//主题接口</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	<span class="comment">//接口实现</span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"the original method!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代理类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </div><div class="line">	</div><div class="line">    <span class="keyword">private</span> Source source;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">super</span>();  </div><div class="line">        <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </div><div class="line">        before();  </div><div class="line">        source.method();  </div><div class="line">        atfer();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"after proxy!"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"before proxy!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用客户端</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Sourceable source = <span class="keyword">new</span> Proxy();  </div><div class="line">        source.method();  </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中代理类中对主题接口进行了增强—在主题方法调用前后调用了<code>before</code>和<code>after</code> 。Spring AOP中的思想正是如此。<br>这就是Java中的代理模式，只不过上面的代码实现是基于硬编码的，也就是所说的<strong>静态代理</strong>。那么区别于静态代理，那就一定有<strong>动态代理了</strong>。<br>通过以上的代码可以看出，静态代理将代码写死，是在编译阶段完成的具体代理类的绑定。但是动态代理不是这么做的，而是在程序运行时完成的这操作。下面使用动态代理方式实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用jdk动态代理实现需要实现接口InvocationHandler</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object targrt;<span class="comment">//代理的真实对象，也就是接口的实现类</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object targrt)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.targrt = targrt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * 该方法负责集中处理动态代理类上的所有方法调用。</div><div class="line">     * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</div><div class="line">     * <span class="doctag">@param</span> proxy 代理类实例</div><div class="line">     * <span class="doctag">@param</span> method 被调用的方法对象</div><div class="line">     * <span class="doctag">@param</span> args 调用参数</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> Throwable</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//这里来处理代理的具体工作</span></div><div class="line">        <span class="comment">//假设在执行前进行一个打印日志的处理</span></div><div class="line">        before();</div><div class="line">        Object result = method.invoke(targrt, args);</div><div class="line">        <span class="comment">//假设执行结束后打印一个执行完成的通知</span></div><div class="line">        atfer();</div><div class="line">        <span class="comment">//将执行结果返回如果有的话</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"after proxy!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"before proxy!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class[] interfaceClass)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</div><div class="line">                                        interfaceClass,<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//客户端</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyCase</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Sourceable s = <span class="keyword">new</span> Source();</div><div class="line"></div><div class="line">        JdkProxy proxy = <span class="keyword">new</span> JdkProxy(s);</div><div class="line"></div><div class="line">        Sourceable hello = (Sourceable) proxy.getProxy(<span class="keyword">new</span> Class[]&#123;Sourceable.class&#125;);</div><div class="line">        </div><div class="line">        hello.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可见，我们对主题对象所有的方法的调用都会变成对<code>invoke</code>方法的调用，而我们可以在这个方法中添加统一的逻辑处理。<br>所以可以看出，动态代理的几个好处：</p>
<ul>
<li>易于维护。相对于静态代理来说，只要在Proxy类中固定好处理逻辑而不用针对每个方法去编写代码了。控制了代码量，便于维护。</li>
<li>使AOP编程更加容易。在Spring的帮助下轻松添加、移除动态代理，且对源代码没有任何影响。</li>
<li>解耦。可以通过参数就能判断具体实现类，不需要事先实例化，更加灵活多变。<h5 id="The-Mechanism-of-Dynamic-Proxy"><a href="#The-Mechanism-of-Dynamic-Proxy" class="headerlink" title="The Mechanism of Dynamic Proxy"></a>The Mechanism of Dynamic Proxy</h5>谈完了什么是动态代理，现在就可以来了解一下动态代理是怎么实现的了。要去知道Jdk动态代理是怎么实现的还得去源码中找。<br>看看<code>Proxy#newProxyInstance</code>的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span></div><div class="line">        <span class="keyword">throws</span> IllegalArgumentException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, interfaces);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 找缓存里有没有Proxy对象，没有就生成一个.</div><div class="line">         */</div><div class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, interfaces);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Invoke its constructor with the designated invocation handler.</div><div class="line">         * 用指定的handler来调用构造方法</div><div class="line">         */</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</div><div class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span> &amp;&amp; ProxyAccessHelper.needsNewInstanceCheck(cl)) &#123;</div><div class="line">                <span class="comment">// create proxy instance with doPrivilege as the proxy class may</span></div><div class="line">                <span class="comment">// implement non-public interfaces that requires a special permission</span></div><div class="line">                <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> newInstance(cons, ih);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> newInstance(cons, ih);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面的代码中不难看出其核心在于获取一个代理类对象。得到类对象后再通过反射去创建代理对象实例。看看<code>getProxyClass0</code>怎么实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Generate a proxy class.  Must call the checkProxyAccess method</div><div class="line">     * to perform permission checks before calling this.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</div><div class="line">                                           Class&lt;?&gt;... interfaces) &#123;</div><div class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></div><div class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></div><div class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></div><div class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>呃…好吧！这个方法是从一个cache对象中去拿Proxy类对象的。所以我们还是不知道代理类对象是怎么产生的。不过这里有一点有点意思，就是代理类实现的接口数不能超过65535个。看到这个数字是否很惊喜或者也有点意外？关于65535我特意去查了一下<a href="https://en.wikipedia.org/wiki/65535_(number" target="_blank" rel="external">Wiki</a>)。这是Java语言机制导致的。当然没有哪个变态去实现这么多个接口吧。<br>既然从cache中去找，那么看看这个cache到底是何方神圣。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * a cache of proxy classes</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</div></pre></td></tr></table></figure></p>
<p>具体到这个cache是怎么实现的就不去纠结了，因为纠结也没用（API文档中没有这个类的解释，因为这个类的修饰是package-private的而不是public）。仔细以看有一个<code>ProxyClassFactory</code>对象作为参数传给这个cache了。这下自貌似有搞头了。看看这个类的名字就很爽—代理类工厂嘛。实际上这是Proxy的一个静态内部类。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">private static final class ProxyClassFactory</div><div class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</div><div class="line">    &#123;</div><div class="line">        // 生成代理类名称的前缀</div><div class="line">        private static final String proxyClassNamePrefix = "$Proxy";</div><div class="line"></div><div class="line">        // 用于生成代理类名字的计数器 </div><div class="line">        private static final AtomicLong nextUniqueNumber = new AtomicLong();</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</div><div class="line">			//各种验证</div><div class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);</div><div class="line">            for (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">                /*</div><div class="line">                 * Verify that the class loader resolves the name of this</div><div class="line">                 * interface to the same Class object.</div><div class="line">                 */</div><div class="line">                Class&lt;?&gt; interfaceClass = null;</div><div class="line">                try &#123;</div><div class="line">                    interfaceClass = Class.forName(intf.getName(), false, loader);</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                &#125;</div><div class="line">                if (interfaceClass != intf) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        intf + " is not visible from class loader");</div><div class="line">                &#125;</div><div class="line">                /*</div><div class="line">                 * Verify that the Class object actually represents an</div><div class="line">                 * interface.</div><div class="line">                 */</div><div class="line">                if (!interfaceClass.isInterface()) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        interfaceClass.getName() + " is not an interface");</div><div class="line">                &#125;</div><div class="line">                /*</div><div class="line">                 * Verify that this interface is not a duplicate.</div><div class="line">                 */</div><div class="line">                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123;</div><div class="line">                    throw new IllegalArgumentException(</div><div class="line">                        "repeated interface: " + interfaceClass.getName());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			//代理类的包名</div><div class="line">            String proxyPkg = null;     // package to define proxy class in</div><div class="line"></div><div class="line">            //对于不是public修饰的接口，代理类的包名和接口包名一致</div><div class="line">            for (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">                int flags = intf.getModifiers();</div><div class="line">                if (!Modifier.isPublic(flags)) &#123;</div><div class="line">                    String name = intf.getName();</div><div class="line">                    int n = name.lastIndexOf('.');</div><div class="line">                    String pkg = ((n == -1) ? "" : name.substring(0, n + 1));</div><div class="line">                    if (proxyPkg == null) &#123;</div><div class="line">                        proxyPkg = pkg;</div><div class="line">                    &#125; else if (!pkg.equals(proxyPkg)) &#123;</div><div class="line">                        throw new IllegalArgumentException(</div><div class="line">                            "non-public interfaces from different packages");</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">			//public修饰的接口 包名统一为com.sun.proxy</div><div class="line">            if (proxyPkg == null) &#123;</div><div class="line">                // if no non-public proxy interfaces, use com.sun.proxy package</div><div class="line">                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /*</div><div class="line">             * Choose a name for the proxy class to generate.</div><div class="line">             */</div><div class="line">            long num = nextUniqueNumber.getAndIncrement();</div><div class="line">            // 默认情况下，代理类的完全限定名为：com.sun.proxy.$Proxy0，com.sun.proxy.$Proxy1……依次递增  </div><div class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</div><div class="line"></div><div class="line">            // 这里才是真正的生成代理类的字节码的地方  </div><div class="line">            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</div><div class="line">                proxyName, interfaces);</div><div class="line">            try &#123;</div><div class="line">	            // 根据二进制字节码返回相应的Class实例  </div><div class="line">                return defineClass0(loader, proxyName,</div><div class="line">                                    proxyClassFile, 0, proxyClassFile.length);</div><div class="line">            &#125; catch (ClassFormatError e) &#123;</div><div class="line">                /*</div><div class="line">                 * A ClassFormatError here means that (barring bugs in the</div><div class="line">                 * proxy class generation code) there was some other</div><div class="line">                 * invalid aspect of the arguments supplied to the proxy</div><div class="line">                 * class creation (such as virtual machine limitations</div><div class="line">                 * exceeded).</div><div class="line">                 */</div><div class="line">                throw new IllegalArgumentException(e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>唉，感觉看了半天发现又被绕进去了。没办法，继续看看<code>ProxyGenerator</code>这个类怎么去实现的。这个是Jdk私有的，但是可以反编译查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class[] var1) &#123;</div><div class="line">        ProxyGenerator var2 = <span class="keyword">new</span> ProxyGenerator(var0, var1);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var3 = var2.generateClassFile();</div><div class="line">        <span class="comment">// 这里根据参数配置，决定是否把生成的字节码（.class文件）保存到本地磁盘，我们可以通过把相应的class文件保存到本地，再反编译来看看具体的实现，这样更直观  </span></div><div class="line">        <span class="keyword">if</span>(saveGeneratedFiles) &#123;</div><div class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        FileOutputStream var1 = <span class="keyword">new</span> FileOutputStream(ProxyGenerator.dotToSlash(var0) + <span class="string">".class"</span>);</div><div class="line">                        var1.write(var3);</div><div class="line">                        var1.close();</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var2);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> var3;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中，这个参数的定义是酱紫的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>))).booleanValue();</div></pre></td></tr></table></figure></p>
<p>所以我们可以设置sun.misc.ProxyGenerator.saveGeneratedFiles这个系统属性为true来把生成的class保存到本地文件来查看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div></pre></td></tr></table></figure></p>
<p>加上这段代码后执行<code>main</code>会报这样的错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.lang.InternalError: I/O exception saving generated file: java.io.FileNotFoundException: com/sun/proxy/$Proxy0.class (No such file or directory)</div><div class="line">	at sun.misc.ProxyGenerator$1.run(ProxyGenerator.java:336)</div><div class="line">	at sun.misc.ProxyGenerator$1.run(ProxyGenerator.java:327)</div><div class="line">	at java.security.AccessController.doPrivileged(Native Method)</div><div class="line">	at sun.misc.ProxyGenerator.generateProxyClass(ProxyGenerator.java:326)</div><div class="line">	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:671)</div><div class="line">	at java.lang.reflect.Proxy$ProxyClassFactory.apply(Proxy.java:591)</div><div class="line">	at java.lang.reflect.WeakCache$Factory.get(WeakCache.java:244)</div><div class="line">	at java.lang.reflect.WeakCache.get(WeakCache.java:141)</div><div class="line">	at java.lang.reflect.Proxy.getProxyClass0(Proxy.java:454)</div><div class="line">	at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:736)</div><div class="line">	at com.dw.test.JdkProxy.getProxy(JdkProxy.java:45)</div><div class="line">	at com.dw.test.JdkProxyCase.main(JdkProxyCase.java:19)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</div><div class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:606)</div><div class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</div></pre></td></tr></table></figure></p>
<p>解决办法是在工程根路径下创建com/sun/proxy目录，并创建一个$Proxy0.class文件，才能够正常运行并保存class文件内容。<br>看看反编译后的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Hello</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</div><div class="line">        <span class="keyword">super</span>(var1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</div><div class="line">            <span class="keyword">throw</span> var3;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="comment">//调用父类的handler的invoke方法 实际上就是调用我们实现InvocationHandler接口的类的invoke 我们的逻辑在这里处理</span></div><div class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</div><div class="line">            <span class="keyword">throw</span> var3;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</div><div class="line">            <span class="keyword">throw</span> var2;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</div><div class="line">            m3 = Class.forName(<span class="string">"com.dw.service_api.Hello"</span>).getMethod(<span class="string">"sayHello"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</div><div class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>从生成出来的这个类中可以看到</p>
<ol>
<li>这个类继承自<code>Proxy</code>实现了代理接口。所以JDK动态代理只能对接口进行代理，而不能对实现类进行代理。这是Java语言不能多继承导致的。</li>
<li>构造方法的参数是<code>InvocationHandler</code>。这个参数是由我们调用<code>Proxy#newProxyInstance</code>方法传进去的。</li>
<li>重写了Object类的<code>equals</code>、<code>hashCode</code>、<code>toString</code>，它们都只是简单的调用了<code>InvocationHandler</code>的<code>invoke</code>方法，即可以对其进行特殊的操作，也就是说JDK的动态代理还可以代理上述三个方法。<br>从这里可以联想到Spring AOP的机制和这个原理其实是一样的，可能实现会比这个复杂的多。<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5></li>
<li>使用JDK实现动态代理需要实现<code>InvacationHandler</code>接口，使用<code>Proxy#newProxyInstacne</code>返回代理对象。</li>
<li>JDK动态代理的机制是通过在程序运行时动态地去生成字节码文件，然后加载到内存生成实例。</li>
<li>JDK动态代理只能对接口进行代理，不能对实现类代理。因为Java语言不支持多继承。要想对实现类进行代理可以使用Cglib来实现。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近呢，看到了一个开源的PRC FRAMEWORK，当然不是Dubbo。然后想去了解一下RPC到底是怎么去实现的。于是乎就了解了一番，发现其灵魂在于动态代理和反射。
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.wei-dong.top/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.wei-dong.top/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>自定义Spring Schema</title>
    <link href="http://www.wei-dong.top/2017/07/01/spring%20schema/"/>
    <id>http://www.wei-dong.top/2017/07/01/spring schema/</id>
    <published>2017-07-01T14:18:23.000Z</published>
    <updated>2017-07-01T14:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="What’s-schema"><a href="#What’s-schema" class="headerlink" title="What’s schema"></a>What’s schema</h5><p>schema中文翻译是概要、计划、图表。这里的schema指的是xml schema，也就是对xml的约束。在xml schema之前，对xml进行约束的是DTD。现在xml schema占据了主流。其中spring framework中xml配置文件就是使用的是xml schema，后缀名为xsd。<br><a id="more"></a> </p>
<h5 id="How-to-define-a-xml-schema"><a href="#How-to-define-a-xml-schema" class="headerlink" title="How to define a xml schema"></a>How to define a xml schema</h5><p>在spring framework中的applicationContext.xml文件中见到最多的就是<code>&lt;bean&gt;</code>标签。有时候想自己也整一个标签满足自己的需求（装逼or真的是需要自己实现）那就得自己去按照spring的标准去实现了，就好比JDK中的SPI机制，要按照JDK的规范去做。Spring是怎么要求的呢？<br>以maven工程为例，在resources目录下的META_INF下需要自己定义一个.xsd文件。这里我定义了一个以dongwei为名的dongwei.xsd文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">"http://www.dongwei.com/schema/dongwei"</span></span></div><div class="line">            <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></div><div class="line">            <span class="attr">xmlns:tool</span>=<span class="string">"http://www.springframework.org/schema/tool"</span></div><div class="line">            <span class="attr">xmlns:beans</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">            <span class="attr">targetNamespace</span>=<span class="string">"http://www.dongwei.com/schema/dongwei"</span>&gt;</div><div class="line">	<span class="comment">&lt;!-- 这里import有好几个schema 可同时去约束被约束的xml --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.w3.org/XML/1998/namespace"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/tool"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">xsd:import</span> <span class="attr">namespace</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">"beans:identifiedType"</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">							<span class="tag">&lt;<span class="name">xsd:documentation</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">xsd:documentation</span>&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">xsd:annotation</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">xsd:attribute</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></div><div class="line">			<span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面的xsd文件就定义了一个约束。接下来还需要在resources/META_INF下新建两个文件<code>spring.handlers</code>和<code>spring.schemas</code> 内容分别是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.dongwei.com/schema/dongwei=com.hnisi.springscheme.schema.DongweiNamespaceHandler</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http\://www.dongwei.com/schema/dongwei/dongwei.xsd=META-INF/dongwei.xsd</div></pre></td></tr></table></figure>
<p>handlers的内容可以是多条，表示对这个标签的处理器。schema表示的是xsd的文件位置，在url不能访问的时候（断网）程序可以去本地找schema。</p>
<h5 id="schema-handlers"><a href="#schema-handlers" class="headerlink" title="schema handlers"></a>schema handlers</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DongweiNamespaceHandler</span>  <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		registerBeanDefinitionParser(<span class="string">"user"</span>, <span class="keyword">new</span> UserBeanDefinitionParser());		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义的handler就是酱紫，需实现父类的<code>init</code>方法。他去调用了<code>registerBeanDefinitionParser</code>去注册标签。第一个参数是标签名，第二个是对这个标签的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanDefinitionParser</span> <span class="keyword">extends</span>  <span class="title">AbstractSingleBeanDefinitionParser</span>  </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</div><div class="line">		String id = element.getAttribute(<span class="string">"id"</span>);</div><div class="line">		String name = element.getAttribute(<span class="string">"name"</span>);</div><div class="line">		</div><div class="line">		builder.addPropertyValue(<span class="string">"id"</span>, id);</div><div class="line">		builder.addPropertyValue(<span class="string">"name"</span>, name);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</div><div class="line">		<span class="keyword">return</span> User.class;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个解析器重写了父类的<code>doParse</code>和<code>getBeanClass</code>  其中<code>doParse</code>处理的就是xsd中定义的属性。<br>当然，也不能少了我们要定义的标签bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">	 <span class="keyword">private</span> String id;</div><div class="line">	 <span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">	 </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上这就是一个bean，和在applicationContext.xml中配置的<code>&lt;bean&gt;</code>是一个意思。这样定义标签去处理个人觉得是为了更加灵活，可以在xml文件中去配置bean的属性，想改就改。</p>
<h5 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use"></a>How to use</h5><p>再来看看applicationContext.xml中怎么使用<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </div><div class="line">    xmlns:dongwei="http://www.dongwei.com/schema/dongwei"</div><div class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans </div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    </div><div class="line">    http://www.dongwei.com/schema/dongwei</div><div class="line">    http://www.dongwei.com/schema/dongwei/dongwei.xsd"&gt;</div><div class="line">    </div><div class="line">    &lt;dongwei:user id="eric" name="123"/&gt;</div><div class="line">    </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>这里的dongwei是namespace。本质上来讲这就是一个bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringSchema</span> </span>&#123;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchame</span><span class="params">()</span></span>&#123;</div><div class="line">		ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</div><div class="line">		User bean = context.getBean(User.class);</div><div class="line">		System.out.println(bean);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Last-summary"><a href="#Last-summary" class="headerlink" title="Last summary"></a>Last summary</h5><p>这是我看到SOA框架的时候发现配置文件中有很多类似<code>&lt;mango:registry protocol=&quot;zookeeper&quot; address=&quot;localhost:2181&quot; connect-timeout=&quot;5000&quot; /&gt;</code>的东西，突然觉得好奇然后去了解了一下。不仅第三方框架中有这样的自定义标签，spring framework也有：<code>&lt;context:annotation-config/&gt;</code> 这和我们最常使用的<code>&lt;bean&gt;</code>长得还是有点不一样的。然后去看了看怎么去自定义一个这样的东西。这只是一个最简单的实现，实际上功能健全的实现是很复杂的。也可以想象spring framework想得还是很周到的，水也很深。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;What’s-schema&quot;&gt;&lt;a href=&quot;#What’s-schema&quot; class=&quot;headerlink&quot; title=&quot;What’s schema&quot;&gt;&lt;/a&gt;What’s schema&lt;/h5&gt;&lt;p&gt;schema中文翻译是概要、计划、图表。这里的schema指的是xml schema，也就是对xml的约束。在xml schema之前，对xml进行约束的是DTD。现在xml schema占据了主流。其中spring framework中xml配置文件就是使用的是xml schema，后缀名为xsd。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Framework" scheme="http://www.wei-dong.top/categories/Spring-Framework/"/>
    
    
      <category term="Spring" scheme="http://www.wei-dong.top/tags/Spring/"/>
    
      <category term="XML" scheme="http://www.wei-dong.top/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>JUC系列之BlockingQueue</title>
    <link href="http://www.wei-dong.top/2017/07/01/juc_LinkedBlockingQueue/"/>
    <id>http://www.wei-dong.top/2017/07/01/juc_LinkedBlockingQueue/</id>
    <published>2017-07-01T14:16:23.000Z</published>
    <updated>2017-07-01T14:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>JUC是jdk1.5之后一强大的工具包。其中对JAVA的并发做了很好的支持。仔细阅读源码你会发现很多代码的作者是<a href="https://en.wikipedia.org/wiki/Doug_Lea" target="_blank" rel="external">Doug Lea</a>。所以现在开始细细琢磨这位大神的鬼斧神工。<br><a id="more"></a> </p>
<h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个类继承了接口Queue，Queue继承了Collection接口，他们都是亲戚。亲戚关系很庞大，后台很硬。直接实现这个接口的类没多少个：</p>
<ul>
<li>ArrayBlockingQueue </li>
<li>DelayQueue</li>
<li>LinkedBlockingDeque</li>
<li>LinkedBlockingQueue</li>
<li>LinkedTransferQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4>那就拿最简单的实现开刀。顾名思义，这个Queue是基于链表的。看看源码文档是怎么去描述的：<blockquote>
<p>An optionally-bounded blocking queue based on linked nodes. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.<br>这是一个边界可选的基于链表的阻塞队列。这个队列按照先进先出的规则阻止元素。头节点在队列中的时间最长，尾节点在队列时间最短。新添加的元素会被放到尾部，取元素将在队列的头部取。基于链表的队列的吞吐量通常要比基于数组的高，但是在高并发场景下性能没有那么可观。<br>The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to Integer.MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.<br>可选的容量参数是为了防止队列数量膨胀，假设没有去指定这个参数那么将指定为int的最大值。在不超过容量的前提下节点也会在每次插入的时候动态的创建。 </p>
</blockquote>
</li>
</ul>
<p>先看看这个类的内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        E item;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * One of:</div><div class="line">         * - the real successor Node</div><div class="line">         * - this Node, meaning the successor is head.next</div><div class="line">         * - null, meaning there is no successor (this is the last node)</div><div class="line">         */</div><div class="line">        Node&lt;E&gt; next;</div><div class="line"></div><div class="line">        Node(E x) &#123; item = x; &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//省略实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个node内部类以及一个itr的实现，非常简单。在JAVA集合中经常看到内部实现Itr的，见怪不怪了。<br>接下来就开始正餐了，对几个核心方法进行梳理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        E x;</div><div class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">        <span class="comment">//count记录当前队列的元素数量</span></div><div class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">        takeLock.lockInterruptibly();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	        <span class="comment">//当当前元素的数量为0的时候线程阻塞 直到接到通知队列有元素了才继续执行</span></div><div class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</div><div class="line">                notEmpty.await();</div><div class="line">            &#125;</div><div class="line">            x = dequeue();</div><div class="line">            <span class="comment">//头节点出队了 元素数量减去1 返回值为减1前的值 如果队列元素为1出队后队列没元素了c依旧为1</span></div><div class="line">            c = count.getAndDecrement();</div><div class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">	            <span class="comment">//如果队列中还有元素 那么通知阻塞的线程可以取了</span></div><div class="line">                notEmpty.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            takeLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (c == capacity)</div><div class="line">	        <span class="comment">//这个判断很有意思，想了好久。</span></div><div class="line">	        <span class="comment">//这种情况什么时候发生呢？当向队列中添加元素 队列容量有限比如说10个 我添加了20个 那么线程会阻塞掉，线程被阻塞了必须由别的线程来唤醒不能自己唤醒自己。当某个线程执行take的时候，第一次进来这个方法出队了一个元素 这时候c的值依旧是10（返回的是旧值）那么就执行这个操作了：将入队的阻塞线程唤醒 这时候剩下的10个元素可以继续往队列中送了（只能再送一个，因为满了依旧会阻塞）。原则只有一个：满了就通知。这个画面就容易想到了：我出一个你才能进一个，不存在我先出2个你再补2个进来的，必须是轮换的来，一人一下。</span></div><div class="line">            signalNotFull();</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>自己写了个小示例程序来控制出队和入队，写出来方便理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueCase</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">3</span>);</div><div class="line"></div><div class="line">        Thread put = <span class="keyword">new</span> Thread(<span class="keyword">new</span> F(queue));</div><div class="line">        put.start();</div><div class="line"></div><div class="line">        Thread take = <span class="keyword">new</span> Thread(<span class="keyword">new</span> T(queue));</div><div class="line">        take.start();</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">F</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    queue.put(<span class="string">""</span>+i);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        BlockingQueue&lt;String&gt; queue;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.queue = queue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                System.out.println(<span class="string">"请输入要取出的数量："</span>);</div><div class="line">                <span class="keyword">int</span> t = scanner.nextInt();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        String take = queue.take();</div><div class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"取出了元素："</span>+take);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个小DEMO中有2个线程，分别去对阻塞队列存元素和取元素。阻塞队列容量我只给了3个，在存元素的线程中给了10个元素让它去入队，那么在存到第四个的时候这个线程就阻塞了，直到其他线程被唤醒。而出队线程呢会接受一个数，这个数代表着从队列中要出的元素数量。当输入为10 ，则队列中元素全部被打印出来了。这个过程这样描述：线程的执行是没有先后的（一般情况），因为出队线程中有接受控制台输入，会被阻塞。入队线程一定会执行到将10个元素中的3个放入队列（塞满了，容量只有3），这时候两个线程都被阻塞掉了。当控制台接受输入了，出队线程执行到<code>take</code>方法，进行出队操作，执行到<code>if (c == capacity)</code>的时候唤醒入队线程可以继续执行。也就是说每次去调用<code>take</code>方法出队的时候都会去检查队列有没有满，满了就通知被阻塞的线程可以往队列中添加元素了（也只有队列满了才会被阻塞掉）。<br>在看看入队的方法<code>put</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></div><div class="line">        <span class="comment">// holding count negative to indicate failure unless set.</span></div><div class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node(e);</div><div class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">        putLock.lockInterruptibly();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * Note that count is used in wait guard even though it is</div><div class="line">             * not protected by lock. This works because count can</div><div class="line">             * only decrease at this point (all other puts are shut</div><div class="line">             * out by lock), and we (or some other waiting put) are</div><div class="line">             * signalled if it ever changes from capacity. Similarly</div><div class="line">             * for all other uses of count in other wait guards.</div><div class="line">             */</div><div class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">                notFull.await();</div><div class="line">            &#125;</div><div class="line">            enqueue(node);</div><div class="line">            c = count.getAndIncrement();</div><div class="line">            <span class="comment">//如果入队一个元素队列还有位置的话唤醒被阻塞的线程可以往队列中添加元素了</span></div><div class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            putLock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//只有第一次put的时候才会执行这段代码 队列初始化的时候没有元素 count为0 第一次执行put虽然加1了但是返回的是旧值0 这时候队列中有一个元素 通知因为队列为空的出队线程可以取元素了</span></div><div class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">            signalNotEmpty();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其中还有很多其他的出队入队方法类似<code>offer</code> <code>peek</code>等就不一一说明了，其中的原理都是一样的。只不过有些方法不是阻塞的，出队的时候队空了就返回false或者null或者抛异常，入队同理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，关于JUC中的<code>BlockingQueue</code>的一个实现 <code>LinkedBlockingQueue</code>主要内容就到此为止，其中很多JUC的东西还是很值得去深入琢磨的。比方说<code>ReentrantLock</code>。对于并发编程这一块，还有很多东西需要去学习的。我想说这里面水太深了，这个行业真的是要求无时无刻去学习！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JUC是jdk1.5之后一强大的工具包。其中对JAVA的并发做了很好的支持。仔细阅读源码你会发现很多代码的作者是&lt;a href=&quot;https://en.wikipedia.org/wiki/Doug_Lea&quot;&gt;Doug Lea&lt;/a&gt;。所以现在开始细细琢磨这位大神的鬼斧神工。&lt;br&gt;
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.wei-dong.top/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.wei-dong.top/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JUC之CyclicBarrier</title>
    <link href="http://www.wei-dong.top/2017/07/01/juc_CyclicBarrier/"/>
    <id>http://www.wei-dong.top/2017/07/01/juc_CyclicBarrier/</id>
    <published>2017-07-01T14:14:41.000Z</published>
    <updated>2017-07-01T14:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>从这个名字来理解这个东西叫做循环栅栏。也许这样翻译很生硬，但是具体什么意思大概可以很清楚地明白了。</p>
<blockquote>
<p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.<br><a id="more"></a><br>JDK文档的解释是这样的：CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。<br>看个DEMO先：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest1 &#123;</div><div class="line"></div><div class="line">    private static int SIZE = 5;</div><div class="line">    private static CyclicBarrier cb;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        cb = new CyclicBarrier(SIZE);</div><div class="line"></div><div class="line">        // 新建5个任务</div><div class="line">        for(int i=0; i&lt;SIZE; i++)</div><div class="line">            new InnerThread().start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class InnerThread extends Thread&#123;</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot; wait for CyclicBarrier.&quot;);</div><div class="line"></div><div class="line">                // 将cb的参与者数量加1</div><div class="line">                cb.await();</div><div class="line"></div><div class="line">                // cb的参与者数量等于5时，才继续往后执行</div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot; continued.&quot;);</div><div class="line">            &#125; catch (BrokenBarrierException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>执行结果：<br><code>Thread-1 wait for CyclicBarrier.
Thread-2 wait for CyclicBarrier.
Thread-3 wait for CyclicBarrier.
Thread-4 wait for CyclicBarrier.
Thread-0 wait for CyclicBarrier.
Thread-0 continued.
Thread-4 continued.
Thread-2 continued.
Thread-3 continued.
Thread-1 continued.</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从这个名字来理解这个东西叫做循环栅栏。也许这样翻译很生硬，但是具体什么意思大概可以很清楚地明白了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.&lt;br&gt;
    
    </summary>
    
      <category term="JDK SOURCE" scheme="http://www.wei-dong.top/categories/JDK-SOURCE/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="JDK" scheme="http://www.wei-dong.top/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>XMPP Server Vysper （Ⅰ）</title>
    <link href="http://www.wei-dong.top/2017/05/20/xmpp-vysper-1-md/"/>
    <id>http://www.wei-dong.top/2017/05/20/xmpp-vysper-1-md/</id>
    <published>2017-05-20T10:40:04.000Z</published>
    <updated>2017-05-20T10:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在嘀嗒清单里列出了许多计划。有阅读计划，有学习计划，还有其他的计划。其中阅读计划里就包括应用层协议，类似HTTP协议，MQTT，XMPP等。阅读协议最重要的目的就是理解设计者设计的初衷和思想。个人认为这些思想远远比实现的手段有趣。很崇拜那些定制协议的人，以及定制标准的那些巨头，例如Google等。<a id="more"></a>去看那些草案，RFC文档是一件很枯燥的事情，拿一个标准实现对着文档来分析可以让这个过程变得有趣的多。之前读过FTP的协议，看着看着就看不下去了。虽然没多少内容，但是要去读下去实在是索然无味。于是拿了一个标准实现去分析，FtpServer就是一个很简单的入门。现在开始去了解XMPP，于是拿了一个开源server Vysper来学习。 </p>
<h1 id="XMPP"><a href="#XMPP" class="headerlink" title="XMPP"></a>XMPP</h1><p>第一个x代表的是Extensible，m代表的是Messageing，第一个p是Presence。这个协议的前生是Jabber，具体的没有去研究。这个协议是基于XML的，也就是通过XML格式去传输数据。其实我觉得，应用层的协议无非两种传输方式，基于文本和基于二进制。本质上来说都是基于二进制：对于计算机而言所有的数据全是0101，没什么毛病。HTTP就是基于文本，普通人都能去阅读HTTP里的数据。而XMPP是基于XML，也就是基于文本。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于一个陌生的协议，又没耐心去看RFC文档（主要是看不懂英文），怎么去了解这个协议是怎么工作的呢？我的理解就是自己去抓包看内容。类比HTTP可以通过浏览器去查看请求头以及各种属性，同样的XMPP一样也可以通过抓包分析其指令及数据格式。首先去APACHE将Vysper下载下来（dist和src）然后自己本地将服务器跑起来。找几个XMPP客户端相互通信通过抓包工具来将XMPP协议的过滤出来，对每条请求和响应具体分析。ok，整个思路就是这样了。抓包工具使用wireshark很方便。客户端有很多，pc上使用spark（win），aduim（mac）；手机上使用bruno。openfire也是一个很不错的服务器，提供web管理页面，使用起来很方便。</p>
<h1 id="Vysper"><a href="#Vysper" class="headerlink" title="Vysper"></a>Vysper</h1><p>Vysper的发音和Whisper是一样的，是悄悄话的意思。在apache的vysper官方文档中它实现的标准是 RFC3920（现在的标准是RFC6120，具体可见<a href="http://wiki.jabbercn.org/RFC6120" target="_blank" rel="external">RFC6120</a>）和 RFC3921（只实现了80%）。其他的都是些拓展协议了。根据文档介绍，vysper的结构分为三部分：<a href="http://mina.apache.org/vysper-project/xml_processing.html" target="_blank" rel="external">XML Processing</a>、<a href="http://mina.apache.org/vysper-project/stanza_processing_layer.html" target="_blank" rel="external">Stanza Processing</a>和<a href="http://mina.apache.org/vysper-project/user_mgmt.html" target="_blank" rel="external">User Management</a>.<br>目前最新的版本是0.7，打开下载的源码，其对应的模块有这几个部分：dist、examples、nbxml、server和speccompliance。其中server下又有好几个模块。</p>
<h2 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h2><p>通过名字可以看出来是用来打包发布的。因为vysper是用maven管理的，这个模块将其他的模块引入进来，通过配置生成启动脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.0&lt;/version&gt;</div><div class="line">        &lt;configuration&gt;</div><div class="line">          &lt;includeConfigurationDirectoryInClasspath&gt;true&lt;/includeConfigurationDirectoryInClasspath&gt;</div><div class="line">          &lt;configurationDirectory&gt;config&lt;/configurationDirectory&gt;</div><div class="line">          &lt;target&gt;$&#123;project.build.directory&#125;/appassembler&lt;/target&gt;</div><div class="line">          &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt;</div><div class="line">		  &lt;repositoryName&gt;lib&lt;/repositoryName&gt;</div><div class="line">          &lt;environmentSetupFileName&gt;setenv&lt;/environmentSetupFileName&gt;</div><div class="line">          &lt;!-- Generate bin scripts for windows and unix per default --&gt;</div><div class="line">          &lt;platforms&gt;</div><div class="line">            &lt;platform&gt;windows&lt;/platform&gt;</div><div class="line">            &lt;platform&gt;unix&lt;/platform&gt;</div><div class="line">          &lt;/platforms&gt;</div><div class="line">          &lt;programs&gt;</div><div class="line">            &lt;program&gt;</div><div class="line">              &lt;mainClass&gt;org.apache.vysper.spring.ServerMain&lt;/mainClass&gt;</div><div class="line">              &lt;!-- call it only run because appassemble will add .bat by default on windows --&gt;              </div><div class="line">              &lt;name&gt;run&lt;/name&gt;</div><div class="line">              &lt;!-- Only generate windows bat script for this application --&gt;</div><div class="line">              &lt;platforms&gt;</div><div class="line">                &lt;platform&gt;windows&lt;/platform&gt;</div><div class="line">              &lt;/platforms&gt;</div><div class="line">            &lt;/program&gt;</div><div class="line">            &lt;program&gt;</div><div class="line">              &lt;mainClass&gt;org.apache.vysper.spring.ServerMain&lt;/mainClass&gt;</div><div class="line">              &lt;name&gt;run.sh&lt;/name&gt;</div><div class="line">              &lt;!-- Only generate unix shell script for this application --&gt;</div><div class="line">              &lt;platforms&gt;</div><div class="line">             &lt;platform&gt;unix&lt;/platform&gt;</div><div class="line">              &lt;/platforms&gt;</div><div class="line">            &lt;/program&gt;</div><div class="line">          &lt;/programs&gt;</div><div class="line">        &lt;/configuration&gt;</div><div class="line">        &lt;executions&gt;</div><div class="line">          &lt;execution&gt;</div><div class="line">          &lt;id&gt;make-appassemble&lt;/id&gt;</div><div class="line">            &lt;phase&gt;package&lt;/phase&gt;</div><div class="line">            &lt;goals&gt;</div><div class="line">              &lt;goal&gt;assemble&lt;/goal&gt;</div><div class="line">            &lt;/goals&gt;</div><div class="line">          &lt;/execution&gt;</div><div class="line">        &lt;/executions&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure></p>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><p>这个模块下有两个子模块：embedded-war和pubsub-client.分别是用作嵌入到web容器里和gui客户端的栗子。简言之就是将编译好的server-core拿来调用了一把而已。可以通过jetty或者tomcat启动它都是没问题的。而pubsub-client这个模块则是一个gui的程序，通过pom的配置看到了有smack的引用，具体的后续会慢慢研究。</p>
<h2 id="nbxml"><a href="#nbxml" class="headerlink" title="nbxml"></a>nbxml</h2><p>这个模块很奇怪，名字叫做nbxml。我想这个项目不是外国人写的吗，为何叫牛逼xml。真的是这样吗？并不是的。全名叫做Non-blocking XML，非阻塞的xml解析器。无非就是实现了org.xml.sax 的一些接口而已。自定义了一套解析规则。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>这个模块下有很多子模块。这也是vysper的核心模块了。</p>
<h3 id="admin-config"><a href="#admin-config" class="headerlink" title="admin-config"></a>admin-config</h3><p>这个模块是一个web应用，和openfire的web管理是一样的。其中使用到了velocity和springmvc</p>
<h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p>这个模块最重要的就是对xmpp协议的实现了。当然最重要的还是离不开mina，毕竟是mina的子项目。</p>
<h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p>这个模块也包含很多子模块，每个模块都是对xmpp拓展协议的实现，比如bosh，mcu等。我发现使用maven分模块来管理这种方式真的很聪明。</p>
<h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><p>顾名思义，这个模块是用来存储的。其中有个jcr和hbase。不禁让我想到了hadoop。没错其中真的还引入了hadoop的包。我理解的是这个模块用于文档存储的。具体是存储什么我觉得大概是用户信息，联系人等。openfire使用的是mysql数据库来管理的。具体怎么实现的后续会继续分析。</p>
<h2 id="speccompliance"><a href="#speccompliance" class="headerlink" title="speccompliance"></a>speccompliance</h2><p>这个模块很神秘，我看pom文件中只配置了一个jdk的jar包，这个jar包在1.8中是没有的。当初编译源码的时候还遇到了一点坑，将jdk换为1.7才编译通过。说什么使用了apt的api。具体的是干嘛的可见<a href="http://www.javacui.com/Theory/367.html" target="_blank" rel="external">JDK工具 APT</a>。简单理解就是可以帮我们少写代码。</p>
<h1 id="结尾语"><a href="#结尾语" class="headerlink" title="结尾语"></a>结尾语</h1><p>本文简要介绍了XMPP协议以及如何去学习和分析一个协议如何实现的。通过开源项目Vysper来学习XMPP是一个不错的途径。同时也简单地将Vysper的结构概述了一遍。接下来将会通过分析和调试源代码以及结合阅读RFC文档的方式来学习XMPP协议。<img src="http://7xsfwn.com1.z0.glb.clouddn.com/%E5%87%A4%E5%87%B0%E8%8A%B1.jpg" alt="凤凰花"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;在嘀嗒清单里列出了许多计划。有阅读计划，有学习计划，还有其他的计划。其中阅读计划里就包括应用层协议，类似HTTP协议，MQTT，XMPP等。阅读协议最重要的目的就是理解设计者设计的初衷和思想。个人认为这些思想远远比实现的手段有趣。很崇拜那些定制协议的人，以及定制标准的那些巨头，例如Google等。
    
    </summary>
    
      <category term="Apache Open Project" scheme="http://www.wei-dong.top/categories/Apache-Open-Project/"/>
    
    
      <category term="源码解读" scheme="http://www.wei-dong.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Apache" scheme="http://www.wei-dong.top/tags/Apache/"/>
    
  </entry>
  
</feed>
