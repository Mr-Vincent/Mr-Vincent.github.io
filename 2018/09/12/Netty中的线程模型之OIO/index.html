<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="以梦为马 不负韶华">
    

    <!--Author-->
    
        <meta name="author" content="Mr-Vincent">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Netty中的线程模型之OIO"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="以梦为马 不负韶华" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="DongWei&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Netty中的线程模型之OIO - DongWei&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../../../../css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">DongWei's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="../../../../index.html">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="../../../../archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/Mr-Vincent">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('https://images.unsplash.com/photo-1517503733723-8ea1cf616798?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=9c80b35bc18dea5bfad8db2b17d347cb&auto=format&fit=crop&w=1500&q=80')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Netty中的线程模型之OIO</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-09-12
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/源码解读/">#源码解读</a> <a href="/tags/Netty/">#Netty</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/一起读源码/">一起读源码</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>和高性能NIO相比，个人认为OIO的实现相对要简单一点，选择这个难度稍微低一点的实现来肯对目前的菜鸡我而言更现实。</p>
<p>本质上而言，eventloopgroup就是线程池。</p>
<p><img src="http://7xsfwn.com1.z0.glb.clouddn.com/OioEventLoopGroup.png" alt="image"></p>
<p>Netty针对JDK的实现做了进一步的加强。</p>
<p>对于OIO的第一反应是「阻塞」，「性能差」，「耗资源」。事实上确实如此，但为什么还要写一篇文章（笔记）来对它进行描述呢？在之前，我以为Netty并没有提供OIO的实现，天真的认为Netty仅仅是对NIO进行了封装。直到某一天使用到了OIO，想将OIO的线程模型和Netty中的实现类似：一个线程负责连接，别的线程负责IO。想了许久没有下文，机缘巧合看到了Netty的文档，其中有对OIO的封装，恰好和我心中想的一模一样，而且对外提供的API不变。这种抽象设计让我想深入其中，看看到底是如何做到的。我想借鉴其中的设计来实现一个比较简单对OIO的封装。</p>
<blockquote>
<p>EventLoopGroup which is used to handle OIO Channel’s. Each Channel will be handled by its own EventLoop to not block others.</p>
</blockquote>
<p>文档中的解释很简单，EventLoopGroup用来处理连接，每个连接由它自己的EventLoop处理。</p>
<p>这段解释不禁联想到了针对OIO的编程：每个连接由新开的线程处理，有多少个连接就有多少个线程。这里的Channel就是连接的抽象，EventLoop可以理解为线程。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">OioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(maxChannels, threadFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ThreadPerChannelEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(maxChannels, <span class="keyword">new</span> ThreadPerTaskExecutor(threadFactory), args);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">        threadFactory.newThread(command).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器中两个参数，maxChannels为最大连接数。注意，这个是比较讲究的，在Netty线程模型中有boss和worker线程之分。如果只指定一个，也就是boss就是worker那么这个值如果为1那么任何客户端无法连进来，如果为2则只允许1个客户端连进来，依次类推。默认为0，表示允许无限多客户端接入（理论上）。当有worker的时候，boss的maxChannels指定多少无所谓，worker中的maxChannels值为多少就意味着允许多少客户端接入，同理0代表无限多。第二个参数为线程工厂，默认使用的是JDK的默认实现：Executors.defaultThreadFactory()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ThreadPerChannelEventLoopGroup</span><span class="params">(<span class="keyword">int</span> maxChannels, Executor executor, Object... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (maxChannels &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</div><div class="line">                <span class="string">"maxChannels: %d (expected: &gt;= 0)"</span>, maxChannels));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"executor"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</div><div class="line">        childArgs = EmptyArrays.EMPTY_OBJECTS;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        childArgs = args.clone();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.maxChannels = maxChannels;</div><div class="line">    <span class="keyword">this</span>.executor = executor;</div><div class="line"></div><div class="line">    tooManyChannels = ThrowableUtil.unknownStackTrace(</div><div class="line">            <span class="keyword">new</span> ChannelException(<span class="string">"too many channels (max: "</span> + maxChannels + <span class="string">')'</span>),</div><div class="line">            ThreadPerChannelEventLoopGroup.class, <span class="string">"nextChild()"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的一些成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerChannelEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">AbstractEventExecutorGroup</span> <span class="keyword">implements</span> <span class="title">EventLoopGroup</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] childArgs;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxChannels;</div><div class="line">    <span class="comment">// 任务执行器</span></div><div class="line">    <span class="keyword">final</span> Executor executor;</div><div class="line">    <span class="comment">// 活跃的线程集合</span></div><div class="line">    <span class="keyword">final</span> Set&lt;EventLoop&gt; activeChildren =</div><div class="line">            Collections.newSetFromMap(PlatformDependent.&lt;EventLoop, Boolean&gt;newConcurrentHashMap());</div><div class="line">    <span class="comment">// 空闲的线程集合</span></div><div class="line">    <span class="keyword">final</span> Queue&lt;EventLoop&gt; idleChildren = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;EventLoop&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelException tooManyChannels;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shuttingDown;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Promise&lt;?&gt; terminationFuture = <span class="keyword">new</span> DefaultPromise&lt;Void&gt;(GlobalEventExecutor.INSTANCE);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureListener&lt;Object&gt; childTerminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="comment">// Inefficient, but works.</span></div><div class="line">            <span class="keyword">if</span> (isTerminated()) &#123;</div><div class="line">                terminationFuture.trySuccess(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>EventLoopGroup的初始化就这样结束了。但是要探索其中的工作机制还得从一个Server 的启动开始。</p>
<h3 id="ServerBootstrap的启动"><a href="#ServerBootstrap的启动" class="headerlink" title="ServerBootstrap的启动"></a>ServerBootstrap的启动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></div><div class="line">        b.group(bossGroup, workerGroup)</div><div class="line">         .channel(OioServerSocketChannel.class) <span class="comment">// (3)</span></div><div class="line">         .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></div><div class="line">             <span class="meta">@Override</span></div><div class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                 ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</div><div class="line">             &#125;</div><div class="line">         &#125;)</div><div class="line">         .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></div><div class="line">         .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></div><div class="line">    </div><div class="line">        <span class="comment">// Bind and start to accept incoming connections.</span></div><div class="line">        ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></div><div class="line">    </div><div class="line">        <span class="comment">// Wait until the server socket is closed.</span></div><div class="line">        <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></div><div class="line">        <span class="comment">// shut down your server.</span></div><div class="line">        f.channel().closeFuture().sync();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        workerGroup.shutdownGracefully();</div><div class="line">        bossGroup.shutdownGracefully();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最核心的是bind方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    validate();</div><div class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> doBind(localAddress);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">	 <span class="comment">// 核心是regFuture的获取，有了这个后面一切都好说</span></div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> regFuture;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</div><div class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></div><div class="line">        ChannelPromise promise = channel.newPromise();</div><div class="line">        doBind0(regFuture, channel, localAddress, promise);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></div><div class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</div><div class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Throwable cause = future.cause();</div><div class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></div><div class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></div><div class="line">                    promise.setFailure(cause);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></div><div class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></div><div class="line">                    promise.registered();</div><div class="line"></div><div class="line">                    doBind0(regFuture, channel, localAddress, promise);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</div><div class="line">    Channel channel = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    	 <span class="comment">// 实例化OioServerSocketChannel</span></div><div class="line">        channel = channelFactory.newChannel();</div><div class="line">        init(channel);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException("too many open files"))</span></div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 核心是这段逻辑config().group()返回的就是我们设置的boss：OioEventLoopGroup</span></div><div class="line">    ChannelFuture regFuture = config().group().register(channel);</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</div><div class="line">            channel.close();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            channel.unsafe().closeForcibly();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> regFuture;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>忽略掉无关的逻辑（实在是很复杂），关键点到了这个OioEventLoopGroup的register方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channel"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        EventLoop l = nextChild();</div><div class="line">        <span class="comment">// 将channel包装了一下--&gt; DefaultChannelPromise</span></div><div class="line">        <span class="keyword">return</span> l.register(<span class="keyword">new</span> DefaultChannelPromise(channel, l));</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailedChannelFuture(channel, GlobalEventExecutor.INSTANCE, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个Channel就是OioServerSocketChannel，对应在OIO原生API中就是ServerSocket。根据代码的字面意可以这样解释：将OioServerSocketChannel注册到EventLoopGroup。</p>
<p>最终是通过EventLoop去注册的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> EventLoop <span class="title">nextChild</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shuttingDown) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"shutting down"</span>);</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 从空闲队列中取EventLoop</span></div><div class="line">    EventLoop loop = idleChildren.poll();</div><div class="line">    <span class="keyword">if</span> (loop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (maxChannels &gt; <span class="number">0</span> &amp;&amp; activeChildren.size() &gt;= maxChannels) &#123;</div><div class="line">            <span class="keyword">throw</span> tooManyChannels;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没有就新建一个 参数没用</span></div><div class="line">        loop = newChild(childArgs);</div><div class="line">        loop.terminationFuture().addListener(childTerminationListener);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 新建的放到活跃队列中</span></div><div class="line">    activeChildren.add(loop);</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 新建的一个EventLoop为ThreadPerChannelEventLoop实例，参数为EventLoopGroup 也就是说这个EventLoop说由哪个group产生的</span></div><div class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(@SuppressWarnings(<span class="string">"UnusedParameters"</span>)</span> Object... args) <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPerChannelEventLoop(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么一来，真正的注册逻辑就交给了ThreadPerChannelEventLoop去实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPerChannelEventLoop</span><span class="params">(ThreadPerChannelEventLoopGroup parent)</span> </span>&#123;</div><div class="line">	 <span class="comment">// 注意 这里的parent.executor为ThreadPerTaskExecutor实例</span></div><div class="line">    <span class="keyword">super</span>(parent, parent.executor, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">this</span>.parent = parent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.register(promise).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</div><div class="line">                ch = future.channel();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                deregister();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 父类的</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</div><div class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>终于要看到希望了，这一层一层的调用实在很繁琐，会把人看晕，建议多看几遍就不晕了😂。</p>
<p>promise.channel()返回的就是我们设置的OioServerSocketChannel。而unsafe方法则是继承自它的「太爷爷」。<br>其具体实现则是由它「爷爷」来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> AbstractUnsafe <span class="title">newUnsafe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultOioUnsafe();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这是它的一个内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultOioUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractUnsafe</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> SocketAddress remoteAddress,</div><div class="line">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">            doConnect(remoteAddress, localAddress);</div><div class="line"></div><div class="line">            <span class="comment">// Get the state as trySuccess() may trigger an ChannelFutureListener that will close the Channel.</span></div><div class="line">            <span class="comment">// We still need to ensure we call fireChannelActive() in this case.</span></div><div class="line">            <span class="keyword">boolean</span> active = isActive();</div><div class="line"></div><div class="line">            safeSetSuccess(promise);</div><div class="line">            <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</div><div class="line">                pipeline().fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            safeSetFailure(promise, annotateConnectException(t, remoteAddress));</div><div class="line">            closeIfClosed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然快看到希望的曙光了，但是眼前却依旧是一片黑暗。😫！！！亲爱的register你到底在哪里？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AbstractUnsafe 也是内部类 tmd netty真会折腾</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</div><div class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</div><div class="line">        promise.setFailure(</div><div class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</div><div class="line">	 <span class="comment">// 关键点 其他不管 这里一定是最后一步了</span></div><div class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</div><div class="line">        register0(promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        	  <span class="comment">// 这里大有玄机</span></div><div class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    register0(promise);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</div><div class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</div><div class="line">            closeForcibly();</div><div class="line">            closeFuture.setClosed();</div><div class="line">            safeSetFailure(promise, t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这段代码看不懂 先放这个地方 看懂了再来解读</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></div><div class="line">        <span class="comment">// call was outside of the eventLoop</span></div><div class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</div><div class="line">        <span class="comment">// OIO版本中什么都不做</span></div><div class="line">        doRegister();</div><div class="line">        neverRegistered = <span class="keyword">false</span>;</div><div class="line">        registered = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></div><div class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></div><div class="line">        pipeline.invokeHandlerAddedIfNeeded();</div><div class="line"></div><div class="line">        safeSetSuccess(promise);</div><div class="line">        pipeline.fireChannelRegistered();</div><div class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></div><div class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></div><div class="line">        <span class="keyword">if</span> (isActive()) &#123;</div><div class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</div><div class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></div><div class="line">                <span class="comment">// again so that we process inbound data.</span></div><div class="line">                <span class="comment">//</span></div><div class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></div><div class="line">                beginRead();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></div><div class="line">        closeForcibly();</div><div class="line">        closeFuture.setClosed();</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>eventLoop.execute方法中不仅仅只执行一个Runnable就完了，因为Netty这个狗逼没有使用默认实现 而是自己实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SingleThreadEventExecutor的实现</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</div><div class="line">    <span class="comment">// 这个task就是register0的具体逻辑 这个逻辑暂时不管（因为看不懂😂）</span></div><div class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</div><div class="line">    	  <span class="comment">// 放到队列中</span></div><div class="line">        addTask(task);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    	 <span class="comment">// 终于露出马脚了 开线程了吧</span></div><div class="line">        startThread();</div><div class="line">        addTask(task);</div><div class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class="line">            reject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class="line">        wakeup(inEventLoop);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 开个线程都玩这么花</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</div><div class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                doStartThread();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</div><div class="line">                STATE_UPDATER.set(<span class="keyword">this</span>, ST_NOT_STARTED);</div><div class="line">                PlatformDependent.throwException(cause);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 这个executor就是ThreadPerTaskExecutor </span></div><div class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            thread = Thread.currentThread();</div><div class="line">            <span class="keyword">if</span> (interrupted) &#123;</div><div class="line">                thread.interrupt();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</div><div class="line">            updateLastExecutionTime();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            		<span class="comment">// 这个狗逼玩的是真花 还去调别人的run 实际上是ThreadPerChannelEventLoop的实现</span></div><div class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</div><div class="line">                success = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            	<span class="comment">// 太多 不看了          </span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ThreadPerChannelEventLoop</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	 <span class="comment">// 死循环</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">    	 <span class="comment">// 这里的task就是AbstractUnsafe#register0的逻辑 当然也有可能是其他的</span></div><div class="line">        Runnable task = takeTask();</div><div class="line">        <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</div><div class="line">            task.run();</div><div class="line">            updateLastExecutionTime();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Channel ch = <span class="keyword">this</span>.ch;</div><div class="line">        <span class="keyword">if</span> (isShuttingDown()) &#123;</div><div class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</div><div class="line">                ch.unsafe().close(ch.unsafe().voidPromise());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (confirmShutdown()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Handle deregistration</span></div><div class="line">                <span class="keyword">if</span> (!ch.isRegistered()) &#123;</div><div class="line">                    runAllTasks();</div><div class="line">                    deregister();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整了这么多，依旧没有搞明白这个register到底在做什么。但是明白了一件事：找到了启动入口。</p>
<h3 id="注册逻辑"><a href="#注册逻辑" class="headerlink" title="注册逻辑"></a>注册逻辑</h3><p>在原生OIO网络编程中，实现一个服务器需要做这几个步骤：</p>
<ul>
<li>创建ServerSocket对象绑定监听端口。</li>
<li>通过accept()方法监听客户端的请求。</li>
<li>建立连接后，通过输入输出流读取客户端发送的请求信息。</li>
<li>通过输出流向客户端发送请求信息。</li>
<li>关闭相关资源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ServerSocket server=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        server=<span class="keyword">new</span> ServerSocket(<span class="number">5209</span>);</div><div class="line">        <span class="comment">//b)指定绑定的端口，并监听此端口。</span></div><div class="line">        System.out.println(<span class="string">"服务器启动成功"</span>);</div><div class="line">        <span class="comment">//创建一个ServerSocket在端口5209监听客户请求</span></div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"没有启动监听："</span>+e);</div><div class="line">            <span class="comment">//出错，打印出错信息</span></div><div class="line">    &#125;</div><div class="line">    Socket socket=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        socket=server.accept();</div><div class="line">        <span class="comment">//2、调用accept()方法开始监听，等待客户端的连接 </span></div><div class="line">        <span class="comment">//使用accept()阻塞等待客户请求，有客户</span></div><div class="line">        <span class="comment">//请求到来则产生一个Socket对象，并继续执行</span></div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">        System.out.println(<span class="string">"Error."</span>+e);</div><div class="line">        <span class="comment">//出错，打印出错信息</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在Netty中的实现基本如此，只不过代码结构比较复杂罢了。这段代码在Netty中的的实现在OioServerSocketChannel中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    socket.bind(localAddress, config.getBacklog());</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (socket.isClosed()) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Socket s = socket.accept();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            buf.add(<span class="keyword">new</span> OioSocketChannel(<span class="keyword">this</span>, s));</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, t);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                s.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</div><div class="line">                logger.warn(<span class="string">"Failed to close a socket."</span>, t2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</div><div class="line">        <span class="comment">// Expected</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先绑定端口，再接受连接。这个接受连接是伪非阻塞的。因为用于连接的线程只有一个，没有客户端连进来的时候不能将其阻塞调。客户端连进来了就将这个「连接」交给别的线程处理，每个连接对应一个线程。这样就做到了连接和io处理不冲突。</p>
<p>当然，最后的执行肯定是到这一步，但是具体的执行调用过程可称得上困难重重。仔细回头看这个register0的处理逻辑，发现好像仅仅启动了一个线程，用于不断从队列中取任务执行的死循环而已。似乎没有直接表现出像绑定端口，接受连接的迹象。不能慌，这个老b隐藏得很深。回到最开始的地方，这个仅仅是register，姑且就到这里，先继续往下看，看到底又有什么新发现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</div><div class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</div><div class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> regFuture;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</div><div class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></div><div class="line">        ChannelPromise promise = channel.newPromise();</div><div class="line">        doBind0(regFuture, channel, localAddress, promise);</div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// 省略。。。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>initAndRegister方法经历千山万水终于启动了一个线程，目的就是返回一个ChannelFuture，先不管这个ChannelFuture到底是什么鬼，先将其理解为JDK中的Future的增强实现。一旦这个Future完成了，调用doBind0:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</div><div class="line">            <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise) &#123;</div><div class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></div><div class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.</span></div><div class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</div><div class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                promise.setFailure(regFuture.cause());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吧，这个鬼又向队列中添加了一个任务。这个任务核心就是去绑定。想都不用想，这个绑定一定是AbstractChannel中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"><span class="comment">// pipeline的bind有是其默认实现类中的子类TailContext中的实现</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="comment">// 省略。。。</span></div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeBind(localAddress, promise);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeBind(localAddress, promise);</div><div class="line">            &#125;</div><div class="line">        &#125;, promise, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后的bind是最终的核心逻辑。先找OutboundContext：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        ctx = ctx.prev;</div><div class="line">    &#125; <span class="keyword">while</span> (!ctx.outbound);</div><div class="line">    <span class="keyword">return</span> ctx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，调用这个方法的是tail，关于pipeline的结构有必要了解一下。<img src="https://segmentfault.com/img/bVEPxn?w=2387&amp;h=584" alt="image"></p>
<p>我们在这个Server初始化的时候添加了handler，比如LoggingHandler等。这些handler都会被添加到tail和head之间。即使你不添加任何handler，netty也会把自己内部的handler添加进去。handler又分为in和out，分别代表入站和出站。这段代码就是找出站的(只有out的才有bind方法)，一直向head方向找（废话，自己都是tail了只能往前找，后面没有了）。找到一个就算数，直接返回这个context。接着就是调用invokeBind方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyOutboundHandlerException(t, promise);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bind(localAddress, promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终的bind方法在if分支中。具体的执行逻辑为实现了out的handler，例如LoggingHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (logger.isEnabled(internalLevel)) &#123;</div><div class="line">        logger.log(internalLevel, format(ctx, <span class="string">"BIND"</span>, localAddress));</div><div class="line">    &#125;</div><div class="line">    ctx.bind(localAddress, promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然这个handler仅仅只是来打印log的，完事之后又交给父类去执行。而父类依然是那段。因为之前是找到第一个实现out的handler就算数，这里又回到了这个pipeline中，继续往前找，最终会找到head（head不仅是out而且还是in，就是这么屌）。最终调用的是headcontext中的bind，而它的bind却是使用的是unsafe的bind：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></div><div class="line">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</div><div class="line">        <span class="keyword">throws</span> Exception &#123;</div><div class="line">    unsafe.bind(localAddress, promise);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/576</span></div><div class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</div><div class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</div><div class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</div><div class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</div><div class="line">        <span class="comment">// Warn a user about the fact that a non-root user can't receive a</span></div><div class="line">        <span class="comment">// broadcast packet on *nix if the socket is bound on non-wildcard address.</span></div><div class="line">        logger.warn(</div><div class="line">                <span class="string">"A non-root user can't receive a broadcast packet if the socket "</span> +</div><div class="line">                <span class="string">"is not bound to a wildcard address; binding to a non-wildcard "</span> +</div><div class="line">                <span class="string">"address ("</span> + localAddress + <span class="string">") anyway as requested."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这个逻辑是有意思的 返回值为 !socket.isClosed()&amp;&amp; socket.isBound()</span></div><div class="line">    <span class="comment">// 没关且绑定了才为true 这里一定为false 因为肯定没绑定</span></div><div class="line">    <span class="keyword">boolean</span> wasActive = isActive();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    	 <span class="comment">// 看到这行代码就够了 其他不管</span></div><div class="line">        doBind(localAddress);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        safeSetFailure(promise, t);</div><div class="line">        closeIfClosed();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	 <span class="comment">// 绑定完了isActive()肯定为true</span></div><div class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</div><div class="line">        <span class="comment">// 这段代码也得看</span></div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    safeSetSuccess(promise);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到doBind就知道怎么回事了，这就是之前所说的OioServerSocketChannel的doBind。终于完成了第一步：绑定端口。<br>接下来就是监听客户端连接，在invokeLater中将其实现了，一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeLater</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        eventLoop().execute(task);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line">        logger.warn(<span class="string">"Can't invoke task later as EventLoop rejected it"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，依旧把这个任务放到线程中去执行了。这个任务到底是什么，很重要。代码中只给了一段<code>pipeline.fireChannelActive()</code>.看看具体实现吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    AbstractChannelHandlerContext.invokeChannelActive(head);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// context为head 又交给了EventExecutor去执行</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeChannelActive();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                next.invokeChannelActive();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用的是head的实现</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ChannelInboundHandler) handler()).channelActive(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            notifyHandlerException(t);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fireChannelActive();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// head的channelActive 这里的套路和之前的一样，先调用父类的 继续找pipeline中的handler只不过方向相反（从head到tail） 依次类推 如果某个handler不去调用ctx了，那么事件就到此为止不会传递下去了</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ctx.fireChannelActive();</div><div class="line">	 <span class="comment">// 这段代码是重点</span></div><div class="line">    readIfIsAutoRead();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 父类的fireChannelActive</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</div><div class="line">    invokeChannelActive(findContextInbound());</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终，一定一定是要做我们在OIO原生编程中的第二步了：接受连接了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</div><div class="line">        channel.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// OioSocketChannel的read 实际上是父类的</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    pipeline.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 调用的是pipeline的read</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    tail.read();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// tail的read</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</div><div class="line">    EventExecutor executor = next.executor();</div><div class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</div><div class="line">        next.invokeRead();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Runnable task = next.invokeReadTask;</div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">            next.invokeReadTask = task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    next.invokeRead();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        executor.execute(task);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这里我又打脸了，还有这么多层的调用！但是不要慌，因为逻辑是类似的。都是在pipeline这条链上找handler来调用，爱调不调的思想。这里的顺序是从tail到head。如果这个链中有哪个不长眼的没有将事件传递下去，那么最终就到不了head。正常情况下是一定要到head的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">    unsafe.beginRead();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 什么都得考unsafe</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertEventLoop();</div><div class="line">    <span class="keyword">if</span> (!isActive()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        doBeginRead();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</div><div class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                pipeline.fireExceptionCaught(e);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        close(voidPromise());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 最终还是将其丢给了eventLoop去执行 readTask是核心</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (readPending) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    readPending = <span class="keyword">true</span>;</div><div class="line">    eventLoop().execute(readTask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个readTask先将其定义好了，没有直接使用匿名内部类。一股清流啊！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable readTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        doRead();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个doRead有2个实现AbstractOioByteChannel和AbstractOioMessageChannel看名字都能知道区别，一个是读字节一个是读对象。最大的区别是OioByteStreamChannel是OioSocketChannel的父类而AbstractOioMessageChannel是OioServerSocketChannel的父类。这里使用的实现不用说也知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 太多省略不看</span></div><div class="line">    <span class="keyword">final</span> ChannelConfig config = config();</div><div class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</div><div class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class="line">    allocHandle.reset(config);</div><div class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</div><div class="line">    Throwable exception = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// Perform a read. 关键点</span></div><div class="line">            <span class="keyword">int</span> localRead = doReadMessages(readBuf);</div><div class="line">            <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</div><div class="line">                closed = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            allocHandle.incMessagesRead(localRead);</div><div class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        exception = t;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不看</span></div><div class="line">    <span class="comment">// 这里还省略了一个关键代码 一直想不明白的一个问题是这段代码是怎么能够一只run下去的</span></div><div class="line">    <span class="comment">// 因为eventloop中有个死循环，取的是任务队列中的任务去执行的，取的方式是take，也就是取出来就移除掉</span></div><div class="line">    <span class="comment">// 而下面这段代码则是将其继续加到任务队列中，只要没读到数据就继续将这个task添加到任务队列 这样就能一直死循环下去</span></div><div class="line">    <span class="comment">// Reading 0 bytes could mean there is a SocketTimeout and no data was actually read, so we</span></div><div class="line">    <span class="comment">// should execute read() again because no data may have been read.</span></div><div class="line">    read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终这个doReadMessages就是OioServerSocketChannel的实现。将监听客户端连接也放到了任务队列中，让线程去轮询。至于怎么去把消息读出来以及这个过程是怎样的，这是以后的事情。因为这次基本上将整个netty的核心组件都接触到了。接下来的源码解读会稍微轻松点。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Netty真屌，不接受反驳😂！</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    
    <hr />
    <h3>留言:</h3>
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>



                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/Mr-Vincent" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2021 Mr-Vincent<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->

<script type="text/javascript">
    var disqus_shortname = 'wei-dong';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



</body>

</html>