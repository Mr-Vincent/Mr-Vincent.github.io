<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="以梦为马 不负韶华">
    

    <!--Author-->
    
        <meta name="author" content="Mr-Vincent">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="浅析JDK中的定时器Timer实现"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="以梦为马 不负韶华" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="DongWei&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>浅析JDK中的定时器Timer实现 - DongWei&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">DongWei's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/Mr-Vincent">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/images/bg.jpeg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>浅析JDK中的定时器Timer实现</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-04-21
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/源码解读/">#源码解读</a> <a href="/tags/JDK/">#JDK</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/JDK-SOURCE/">JDK SOURCE</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>在jdk中处理定时任务工具类中有2种：Timer和ScheduledExecutorService。前者是在java.util包中，从1.3版本开始，属于比较老的工具类了。而ScheduledExecutorService属于java.util.concurrent包，作者是老爷子Doug Lea，1.5版本开始才有。虽然现在大多使用ScheduledExecutorService，但是我觉得很有必要对其“同宗”Timer的实现进行解读。</p>
<h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>官方文档中的解释是这样的：</p>
<blockquote>
<p>A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.</p>
</blockquote>
<p>线程的工具，用于在后台线程中安排将来执行的任务。 可以安排一次性执行任务，或定期重复执行任务。</p>
<blockquote>
<p>This class is thread-safe: multiple threads can share a single Timer object without the need for external synchronization.<br>This class does not offer real-time guarantees: it schedules tasks using the Object.wait(long) method.<br>Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn’t require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer.</p>
</blockquote>
<p>这个类是线程安全的，但不能保证是实时的，因为使用的是wait方法来调度任务。文档还说了建议使用JUC下的ScheduledThreadPoolExecutor（ScheduledExecutorService的实现）类来处理定时任务，这个类提供的功能更多，参数更灵活，而且是多线程的。当线程池size指定为一那就和Timer一个样了。</p>
<p>下面通过一个demo来展示一下相关api的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkTimerDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="string">"timer-demo"</span>);</div><div class="line">        MyTask[] tasks = <span class="keyword">new</span> MyTask[<span class="number">20</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</div><div class="line">            tasks[i] = <span class="keyword">new</span> MyTask(i);</div><div class="line">            System.out.println(<span class="string">"time no "</span> + i + <span class="string">" task start at "</span> + <span class="keyword">new</span> Date());</div><div class="line">            timer.schedule(tasks[i], <span class="number">2</span> * <span class="number">1000</span>, <span class="number">3</span> * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"timer started at: "</span> + <span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> timeNo;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> timeNo)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.timeNo = timeNo;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果任务出现异常不被捕获，其他任务不会被执行</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (timeNo == <span class="number">8</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"time no "</span> + timeNo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个demo展示一个Timer的弊端。当任务中出现未被捕获的异常，接下来的任务都不会被执行，定时器crash掉。这个demo中定义了20个task交给timer调度，timer启动2秒后开始执行任务，每隔3秒执行一次。接下来就跟着demo一步一步看看其中的实现原理。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>首先看看构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name, <span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.setDaemon(isDaemon);</div><div class="line">    thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器的参数代表着timer的名字和这个timer是否是后台运行的（timer本质上是一个线程）。一旦实例化就将这个线程给启动了。这个线程是核心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</div></pre></td></tr></table></figure>
<p>可以看到这个成员属性TimerThread内部维护着一个queue。这个queue上什么稍后再讲。</p>
<p>实例化结束后就得调用它的schedule方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</div><div class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</div><div class="line">    sched(task, System.currentTimeMillis()+delay, -period);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 核心的是这段逻辑</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Constrain value of period sufficiently to prevent numeric</span></div><div class="line">    <span class="comment">// overflow while still being effectively infinitely large.</span></div><div class="line">    <span class="comment">// 防止溢出 如果周期比最大值的一半还大 那就将其除以2 道理何在？</span></div><div class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</div><div class="line">        period &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">            <span class="comment">// 如果任务状态不为新创建的 直接抛异常</span></div><div class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Task already scheduled or cancelled"</span>);</div><div class="line">            <span class="comment">// 设置任务下次执行时间 执行周期 以及 状态</span></div><div class="line">            task.nextExecutionTime = time;</div><div class="line">            task.period = period;</div><div class="line">            task.state = TimerTask.SCHEDULED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		  <span class="comment">// 任务实际上是放在队列中 并不是直接执行的 </span></div><div class="line">        queue.add(task);</div><div class="line">        <span class="comment">// 为什么需要queue.getMin() == task时才调用notify方法呢？</span></div><div class="line">        <span class="keyword">if</span> (queue.getMin() == task)</div><div class="line">            queue.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看似简单，但也是有点门道的。在设置任务属性的时候采用加锁，避免并发下把不同任务的执行周期等参数搞混乱了。添加任务到队列中也使用了加锁，实际上是针对add方法加的锁。保证add任务不出乱（这个队列不是安全的队列）。最后有个判断，为什么需要queue.getMin() == task时才调用notify方法呢？因为只有新加入的task是所有Task中要被最早执行的task时，才会需要打断TimeThread的等待状态。举个例子，当前队列中有两个task，分别是A（3分钟后到时间）、B（5分钟后到时间），此时TimerThread正在等待A的时间到来，所以会调用queue.wait(3min)，这个时候，队列中新增一个任务C（1分钟后到时），如果不打断queue.wait(3min)，那当wait(3min)自然结束时，C任务已经过期了… 但是如果新加入的C任务是需要在4分钟后执行，那就没必要打断wait(3min)的状态，因为就算wait(3min)自然结束时，C也还没到时间.</p>
<h5 id="任务是什么"><a href="#任务是什么" class="headerlink" title="任务是什么"></a>任务是什么</h5><p>说了这么久，还没弄清楚这个任务是个什么玩意？按照直觉说到任务第一想到就是Runnable对象，但是也有其他情况下不是这样的。然而这个任务确实是个Runnable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">// 对象锁</span></div><div class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line">   </div><div class="line">    <span class="comment">// 任务状态 新建 已调度 已执行 已取消</span></div><div class="line">    <span class="comment">// 默认是新建</span></div><div class="line">    <span class="keyword">int</span> state = VIRGIN;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRGIN = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULED   = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTED    = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">3</span>;</div><div class="line">	 <span class="comment">// 下次执行的时间</span></div><div class="line">    <span class="keyword">long</span> nextExecutionTime;</div><div class="line">	 <span class="comment">// 周期</span></div><div class="line">    <span class="keyword">long</span> period = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TimerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">boolean</span> result = (state == SCHEDULED);</div><div class="line">            state = CANCELLED;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">scheduledExecutionTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">return</span> (period &lt; <span class="number">0</span> ? nextExecutionTime + period</div><div class="line">                               : nextExecutionTime - period);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TimeTask对Runnable进行简单封装。暴露出抽象的run方法让用户的具体实现类去完成。同时提供了取消任务的方法。和JUC中不同的是这里状态的转化非常简单，没有JUC中动不动就用CAS的骚操作。老版本的代码就是好理解些。</p>
<h5 id="任务的调度（定时器的核心）"><a href="#任务的调度（定时器的核心）" class="headerlink" title="任务的调度（定时器的核心）"></a>任务的调度（定时器的核心）</h5><p>既然都知道任务是什么了，接下来看看队列中的任务是怎么被取出来和执行的。首先得看看这个线程是个什么样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">// 标记这个线程是不是要被挂起</span></div><div class="line">    <span class="keyword">boolean</span> newTasksMayBeScheduled = <span class="keyword">true</span>;</div><div class="line">	 <span class="comment">// 维护一个队列 用于存放任务的队列</span></div><div class="line">    <span class="keyword">private</span> TaskQueue queue;</div><div class="line"></div><div class="line">    TimerThread(TaskQueue queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mainLoop();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></div><div class="line">            <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">                queue.clear();  <span class="comment">// Eliminate obsolete references</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 具体执行核心逻辑 开死循环跑</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimerTask task;</div><div class="line">                <span class="keyword">boolean</span> taskFired;</div><div class="line">                <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                    <span class="comment">// Wait for queue to become non-empty</span></div><div class="line">                    <span class="comment">// 如果队列中没有任务，而且定时器没有被取消（默认为true，只有将timer取消cancel方法调用的时候将其置为false，还有一个地方） 就得将这个线程挂起 不然就造成了死循环 cpu直接上100%</span></div><div class="line">                    <span class="comment">// 而唤起的地方只有cancel方法和threadReaper</span></div><div class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</div><div class="line">                        queue.wait();</div><div class="line">                    <span class="comment">// 任务队列空了 定时器取消了 跳出循环 线程结束</span></div><div class="line">                    <span class="keyword">if</span> (queue.isEmpty())</div><div class="line">                        <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></div><div class="line"></div><div class="line">                    <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></div><div class="line">                    <span class="keyword">long</span> currentTime, executionTime;</div><div class="line">                    <span class="comment">// 从队列中取出最delay时间最小的任务 得最早执行的任务</span></div><div class="line">                    task = queue.getMin();</div><div class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">                    	 <span class="comment">// 任务取消了，将其移出队列 继续取下一个</span></div><div class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</div><div class="line">                            queue.removeMin();</div><div class="line">                            <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// currentTimeMillis()返回以毫秒为单位的当前时间，返回的是当前时间与1970 年 1 月 1 日午夜之间的时间差</span></div><div class="line">                        currentTime = System.currentTimeMillis();</div><div class="line">                        executionTime = task.nextExecutionTime;</div><div class="line">                        <span class="comment">// 如果给定的到期时间小于当前时间（1970-01-01到现在的差值）说明任务到期了 需要被执行 把taskFired置为true</span></div><div class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</div><div class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></div><div class="line">                            	  <span class="comment">// 不是周期执行的任务 直接从队列中移除掉 将任务状态置为已执行</span></div><div class="line">                                queue.removeMin();</div><div class="line">                                task.state = TimerTask.EXECUTED;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></div><div class="line">                                <span class="comment">// 是周期任务 重新计算下次执行的时间 即当前时间+间隔时间为下次任务执行的时间</span></div><div class="line">                                <span class="comment">// 这里是➖因为之前传进来的是一个负值</span></div><div class="line">                                queue.rescheduleMin(</div><div class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</div><div class="line">                                                : executionTime + task.period);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果没到期 就等一个delay长的时间</span></div><div class="line">                    <span class="comment">// executionTime  = System.currentTimeMillis()+delay</span></div><div class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></div><div class="line">                        queue.wait(executionTime - currentTime);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 任务启动 执行业务逻辑</span></div><div class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></div><div class="line">                    task.run();</div><div class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="小疑惑"><a href="#小疑惑" class="headerlink" title="小疑惑"></a>小疑惑</h5><p>整个定时器的核心逻辑在代码注释中都一一解释了。其中一个细节：变量newTasksMayBeScheduled用来做什么的。<br>首先得看看它的值被置为false的情形在哪些地方出现。</p>
<ul>
<li>Timer#cancel方法</li>
<li>TimerThread的mainloop执行完了finally块中</li>
<li>Timer的成员属性threadReaper的finalize方法中</li>
</ul>
<p>前两者都不必多解释，值得注意的是最后一种情况。这种写法我还是第一次见，还不明白其中的玄机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This object causes the timer's task execution thread to exit</div><div class="line"> * gracefully when there are no live references to the Timer object and no</div><div class="line"> * tasks in the timer queue.  It is used in preference to a finalizer on</div><div class="line"> * Timer as such a finalizer would be susceptible to a subclass's</div><div class="line"> * finalizer forgetting to call it.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object threadReaper = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">            thread.newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">            queue.notify(); <span class="comment">// In case queue is empty.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当queue为空，并且没人调用add或cancel方法时，TimerThread永远都不会stop，那么还有别的可能吗？</p>
<p>上述的做法就提供了另外的思路。当队列中没有任务的时候，TimerThread会wait，如果不手动调用cancel这个线程一直会挂起。聪明的jdk就提供了上述的方法。当在GC的时候会触发finalize方法调用，那什么时候会触发GC呢？当Timer对象没有被任何对象引用的时候如果有GC那么这段代码被调用：newTasksMayBeScheduled置为false同时将挂起的TimerThread唤醒，这时候mainloop死循环就跳出了，TimerThread线程结束！</p>
<p>具体验证可以使用Jprofile这个工具。事实上确实可行。但是通过这段代码让我联想到一个这个定时器的弊端：没做到像ExecutorService能够等到任务全部执行完成后再将其关闭。手动关闭只能通过cancel这种粗暴的方式,还好jdk工程师提供这样一个“后门”，交给jvm来管理。这也不失为一种补救措施，但是对于之后的JUC而言，这种做法显得有点“小儿科”了。但是对于学习者而言，这种代码组织显得更容易读懂，设计思想很容易呈现在我们面前。时代不断进步，总会有好的设计来取代老的旧的东西。并不是意味着老的旧的真正被取代，而是以另外一种价值呈现在我们后来人面前。通过比较，我们可能会更加理解什么是好的设计。</p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>整个Timer定时任务的核心逻辑就梳理完了。其中有一些细节被忽略掉了，比如这个任务队列queue的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * This class represents a timer task queue: a priority queue of TimerTasks,</div><div class="line"> * ordered on nextExecutionTime.  Each Timer object has one of these, which it</div><div class="line"> * shares with its TimerThread.  Internally this class uses a heap, which</div><div class="line"> * offers log(n) performance for the add, removeMin and rescheduleMin</div><div class="line"> * operations, and constant time performance for the getMin operation.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护一个长度为128的数组</span></div><div class="line">    <span class="keyword">private</span> TimerTask[] queue = <span class="keyword">new</span> TimerTask[<span class="number">128</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 队列长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Adds a new task to the priority queue.</div><div class="line">     * 当前队列长度为最大长度-1的时候就进行扩容 新队列长度为当前2倍</div><div class="line">     * 为什么要在最大长度-1的时候扩容呢？因为不提前扩容当前的元素加不进去😂</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TimerTask task)</span> </span>&#123;</div><div class="line">        <span class="comment">// Grow backing store if necessary</span></div><div class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> == queue.length)</div><div class="line">            queue = Arrays.copyOf(queue, <span class="number">2</span>*queue.length);</div><div class="line"></div><div class="line">        queue[++size] = task;</div><div class="line">        fixUp(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function">TimerTask <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下标从1开始取</span></div><div class="line">    <span class="function">TimerTask <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 移除第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra reference to prevent memory leak</span></div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickRemove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> i &lt;= size;</div><div class="line"></div><div class="line">        queue[i] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra ref to prevent memory leak</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 改第一个元素的到期时间属性</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rescheduleMin</span><span class="params">(<span class="keyword">long</span> newTime)</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>].nextExecutionTime = newTime;</div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Null out task references to prevent memory leak</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=size; i++)</div><div class="line">            queue[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) assuming the heap</div><div class="line">     * satisfies the invariant except possibly for the leaf-node indexed by k</div><div class="line">     * (which may have a nextExecutionTime less than its parent's).</div><div class="line">     *</div><div class="line">     * This method functions by "promoting" queue[k] up the hierarchy</div><div class="line">     * (by swapping it with its parent) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is greater than or equal to that of its parent.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> j = k &gt;&gt; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the subtree</div><div class="line">     * rooted at k, which is assumed to satisfy the heap invariant except</div><div class="line">     * possibly for node k itself (which may have a nextExecutionTime greater</div><div class="line">     * than its children's).</div><div class="line">     *</div><div class="line">     * This method functions by "demoting" queue[k] down the hierarchy</div><div class="line">     * (by swapping it with its smaller child) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is less than or equal to those of its children.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">while</span> ((j = k &lt;&lt; <span class="number">1</span>) &lt;= size &amp;&amp; j &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (j &lt; size &amp;&amp;</div><div class="line">                queue[j].nextExecutionTime &gt; queue[j+<span class="number">1</span>].nextExecutionTime)</div><div class="line">                j++; <span class="comment">// j indexes smallest kid</span></div><div class="line">            <span class="keyword">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the entire tree,</div><div class="line">     * assuming nothing about the order of the elements prior to the call.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</div><div class="line">            fixDown(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个队列是一个优先队列，以task的到期时间来排序，时间越小越靠前。这个队列是用堆结构实现的（废话，优先队列本身就是堆），实际上堆本质上就是完全二叉树。对于add remove操作的复杂度为log(n)。最核心的操作就是fixDown fixUp。堆也分为大根堆和小根堆，这是一个小根堆，最小的放到最上面，也就是下标为1的位置（只是Timer中的实现将下标为0的位置给弃用了）。每次添加元素都得调整堆结构，同理移除的时候也得这样做。</p>
<p>本文中的<a href="https://github.com/Mr-Vincent/simple-rpc/blob/a570c16128062b14ac0f0fa75e769d76060d3ad2/simple-example/src/main/java/top/weidong/example/netty/nettyinpractice/timer/JdkTimerDemo.java#L95-L94" target="_blank" rel="external">demo</a>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>源码读起来没那么难受，仔细推敲还是很有意思的。</li>
<li>相比老爷子Doug Lea的骚代码，这种中规中矩的写法看起来更让人容易理解。</li>
<li>建议使用ScheduledExecutorService，毕竟Timer的适用场景很局限。</li>
</ul>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    
    <hr />
    <h3>留言:</h3>
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>



                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/Mr-Vincent" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2019 Mr-Vincent<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->

<script type="text/javascript">
    var disqus_shortname = 'wei-dong';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



</body>

</html>