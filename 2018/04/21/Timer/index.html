<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="以梦为马 不负韶华"><title>浅析JDK中的定时器Timer实现 | DongWei's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅析JDK中的定时器Timer实现</h1><a id="logo" href="/.">DongWei's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅析JDK中的定时器Timer实现</h1><div class="post-meta">Apr 21, 2018<span> | </span><span class="category"><a href="/categories/JDK-SOURCE/">JDK SOURCE</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>在jdk中处理定时任务工具类中有2种：Timer和ScheduledExecutorService。前者是在java.util包中，从1.3版本开始，属于比较老的工具类了。而ScheduledExecutorService属于java.util.concurrent包，作者是大名鼎鼎的Doug Lea，1.5版本开始才有。熟好熟坏不言而喻。当然根据不同的场景两者的适用度也不同。下面就针对老版本的定时任务工具类Timer进行源码探索之旅。</p>
<p>官方文档中的解释是这样的：</p>
<blockquote>
<p>A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals.</p>
</blockquote>
<p>线程的工具，用于在后台线程中安排将来执行的任务。 可以安排一次性执行任务，或定期重复执行任务。</p>
<blockquote>
<p>This class is thread-safe: multiple threads can share a single Timer object without the need for external synchronization.<br>This class does not offer real-time guarantees: it schedules tasks using the Object.wait(long) method.<br>Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn’t require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer.</p>
</blockquote>
<p>这个类是线程安全的，这个定时器不能保证是实时的，因为使用的是wait方法来调度任务。文档还说了建议使用JUC下的ScheduledThreadPoolExecutor（ScheduledExecutorService的实现）类来处理定时任务，这个类提供的功能更多，参数更灵活，而且是多线程的。当线程池指定为1那就和Timer一个样了。</p>
<p>下面通过一个demo来展示一下相关api的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkTimerDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="string">"timer-demo"</span>);</div><div class="line">        MyTask[] tasks = <span class="keyword">new</span> MyTask[<span class="number">20</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</div><div class="line">            tasks[i] = <span class="keyword">new</span> MyTask(i);</div><div class="line">            System.out.println(<span class="string">"time no "</span> + i + <span class="string">" task start at "</span> + <span class="keyword">new</span> Date());</div><div class="line">            timer.schedule(tasks[i], <span class="number">2</span> * <span class="number">1000</span>, <span class="number">3</span> * <span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"timer started at: "</span> + <span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> timeNo;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> timeNo)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.timeNo = timeNo;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果任务出现异常不被捕获，其他任务不会被执行</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (timeNo == <span class="number">8</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"boom"</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"time no "</span> + timeNo);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个demo展示一个Timer的弊端。当任务中出现未被捕获的异常，接下来的任务都不会被执行，定时器crash掉。这个demo中定义了20个task交给timer调度，timer启动2秒后开始执行任务，每隔3秒执行一次。这个demo展示了最简单的Timer api的使用。接下来就跟着demo一步一步看看其中的实现原理。</p>
<p>首先看看构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name, <span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</div><div class="line">    thread.setName(name);</div><div class="line">    thread.setDaemon(isDaemon);</div><div class="line">    thread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器的参数代表着timer的名字和这个timer是否是后台运行的（timer本质上上一个线程）。一旦实例化就将这个线程给启动了。这个线程是核心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</div></pre></td></tr></table></figure>
<p>可以看到这个TimerThread内部维护着一个queue。这个queue上什么呆会再说。</p>
<p>实例化结束后就得调用它的schedule方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</div><div class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</div><div class="line">    sched(task, System.currentTimeMillis()+delay, -period);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 核心的是这段逻辑</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Constrain value of period sufficiently to prevent numeric</span></div><div class="line">    <span class="comment">// overflow while still being effectively infinitely large.</span></div><div class="line">    <span class="comment">// 防止溢出 如果周期比最大值的一半还大 那就将其除以2 道理何在？</span></div><div class="line">    <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</div><div class="line">        period &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">        <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">            <span class="comment">// 如果任务状态不为新创建的 直接抛异常</span></div><div class="line">            <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    <span class="string">"Task already scheduled or cancelled"</span>);</div><div class="line">            <span class="comment">// 设置任务下次执行时间 执行周期 以及 状态</span></div><div class="line">            task.nextExecutionTime = time;</div><div class="line">            task.period = period;</div><div class="line">            task.state = TimerTask.SCHEDULED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">		  <span class="comment">// 任务实际上是放在队列中 并不是直接执行的 </span></div><div class="line">        queue.add(task);</div><div class="line">        <span class="comment">// 为什么需要queue.getMin() == task时才调用notify方法呢？</span></div><div class="line">        <span class="keyword">if</span> (queue.getMin() == task)</div><div class="line">            queue.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码看似简单，但也是有点门道的。在设置任务属性的时候采用加锁，避免并发下把不同任务的执行周期等参数搞混乱了。添加任务到队列中也使用了加锁，实际上是针对add方法加的锁。保证add任务不出乱（这个队列不是安全的队列）。最后有个判断，为什么需要queue.getMin() == task时才调用notify方法呢？因为只有新加入的task是所有Task中要被最早执行的task时，才会需要打断TimeThread的等待状态。举个例子，当前队列中有两个task，分别是A（3分钟后到时间）、B（5分钟后到时间），此时TimerThread正在等待A的时间到来，所以会调用queue.wait(3min)，这个时候，队列中新增一个任务C（1分钟后到时），如果不打断queue.wait(3min)，那当wait(3min)自然结束时，C任务已经过期了… 但是如果新加入的C任务是需要在4分钟后执行，那就没必要打断wait(3min)的状态，因为就算wait(3min)自然结束时，C也还没到时间.</p>
<p>说了这么久，还没弄清楚这个任务是个什么玩意？按照直觉说到任务第一想到就是Runnable对象，但是也有其他情况下不是这样的。然而这个任务确实是个Runnable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">// 对象锁</span></div><div class="line">    <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line">   </div><div class="line">    <span class="comment">// 任务状态 新建 已调度 已执行 已取消</span></div><div class="line">    <span class="comment">// 默认是新建</span></div><div class="line">    <span class="keyword">int</span> state = VIRGIN;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRGIN = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULED   = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTED    = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">3</span>;</div><div class="line">	 <span class="comment">// 下次执行的时间</span></div><div class="line">    <span class="keyword">long</span> nextExecutionTime;</div><div class="line">	 <span class="comment">// 周期</span></div><div class="line">    <span class="keyword">long</span> period = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TimerTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">boolean</span> result = (state == SCHEDULED);</div><div class="line">            state = CANCELLED;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">scheduledExecutionTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="keyword">return</span> (period &lt; <span class="number">0</span> ? nextExecutionTime + period</div><div class="line">                               : nextExecutionTime - period);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TimeTask对Runnable进行简单封装。暴露出抽象的run方法让具体实现类去完成。同时提供了取消任务的方法。和JUC中不同的是这里状态的转化非常简单，没有JUC中动不动就用CAS的骚操作。老版本的代码就是好理解些，但是性能上可能稍微差那么点。</p>
<p>既然任务都放到队列中了，接下来看看队列中的任务是怎么被取出来和执行的。首先得看看这个线程是个什么样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">// 标记这个线程是不是要被挂起</span></div><div class="line">    <span class="keyword">boolean</span> newTasksMayBeScheduled = <span class="keyword">true</span>;</div><div class="line">	 <span class="comment">// 维护一个队列 用于存放任务的队列</span></div><div class="line">    <span class="keyword">private</span> TaskQueue queue;</div><div class="line"></div><div class="line">    TimerThread(TaskQueue queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mainLoop();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></div><div class="line">            <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">                queue.clear();  <span class="comment">// Eliminate obsolete references</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 具体执行核心逻辑 开死循环跑</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                TimerTask task;</div><div class="line">                <span class="keyword">boolean</span> taskFired;</div><div class="line">                <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">                    <span class="comment">// Wait for queue to become non-empty</span></div><div class="line">                    <span class="comment">// 如果队列中没有任务，而且定时器没有被取消（默认为true，只有将timer取消cancel方法调用的时候将其置为false，还有一个地方） 就得将这个线程挂起 不然就造成了死循环 cpu直接上100%</span></div><div class="line">                    <span class="comment">// 而唤起的地方只有cancel方法和threadReaper</span></div><div class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</div><div class="line">                        queue.wait();</div><div class="line">                    <span class="comment">// 任务队列空了 定时器取消了 跳出循环 线程结束</span></div><div class="line">                    <span class="keyword">if</span> (queue.isEmpty())</div><div class="line">                        <span class="keyword">break</span>; <span class="comment">// Queue is empty and will forever remain; die</span></div><div class="line"></div><div class="line">                    <span class="comment">// Queue nonempty; look at first evt and do the right thing</span></div><div class="line">                    <span class="keyword">long</span> currentTime, executionTime;</div><div class="line">                    <span class="comment">// 从队列中取出最delay时间最小的任务 得最早执行的任务</span></div><div class="line">                    task = queue.getMin();</div><div class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">                    	 <span class="comment">// 任务取消了，将其移出队列 继续取下一个</span></div><div class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</div><div class="line">                            queue.removeMin();</div><div class="line">                            <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// currentTimeMillis()返回以毫秒为单位的当前时间，返回的是当前时间与1970 年 1 月 1 日午夜之间的时间差</span></div><div class="line">                        currentTime = System.currentTimeMillis();</div><div class="line">                        executionTime = task.nextExecutionTime;</div><div class="line">                        <span class="comment">// 如果给定的到期时间小于当前时间（1970-01-01到现在的差值）说明任务到期了 需要被执行 把taskFired置为true</span></div><div class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</div><div class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></div><div class="line">                            	  <span class="comment">// 不是周期执行的任务 直接从队列中移除掉 将任务状态置为已执行</span></div><div class="line">                                queue.removeMin();</div><div class="line">                                task.state = TimerTask.EXECUTED;</div><div class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></div><div class="line">                                <span class="comment">// 是周期任务 重新计算下次执行的时间 即当前时间+间隔时间为下次任务执行的时间</span></div><div class="line">                                <span class="comment">// 这里是➖因为之前传进来的是一个负值</span></div><div class="line">                                queue.rescheduleMin(</div><div class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime   - task.period</div><div class="line">                                                : executionTime + task.period);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果没到期 就等一个delay长的时间</span></div><div class="line">                    <span class="comment">// executionTime  = System.currentTimeMillis()+delay</span></div><div class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></div><div class="line">                        queue.wait(executionTime - currentTime);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 任务启动 执行业务逻辑</span></div><div class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// Task fired; run it, holding no locks</span></div><div class="line">                    task.run();</div><div class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个定时器的核心就解释完了。其中一个细节，newTasksMayBeScheduled的值被置为false的情况在哪些地方出现。</p>
<ul>
<li>Timer#cancel方法</li>
<li>TimerThread的mainloop执行完了finally块中</li>
<li>Timer的成员属性threadReaper的finalize方法中</li>
</ul>
<p>前两者都不必多解释，值得注意的是最后一种情况。这种写法我还是第一次见，还不明白其中的玄机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This object causes the timer's task execution thread to exit</div><div class="line"> * gracefully when there are no live references to the Timer object and no</div><div class="line"> * tasks in the timer queue.  It is used in preference to a finalizer on</div><div class="line"> * Timer as such a finalizer would be susceptible to a subclass's</div><div class="line"> * finalizer forgetting to call it.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object threadReaper = <span class="keyword">new</span> Object() &#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">            thread.newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">            queue.notify(); <span class="comment">// In case queue is empty.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当queue为空，并且没人调用add或cancel方法时，TimerThread永远都不会stop，那么还有别的可能吗？</p>
<p>上述的做法就提供了另外的思路。当队列中没有任务的时候，TimerThread会wait，如果不手动调用cancel这个线程一直会挂起。聪明的jdk就提供了上述的方法。当在GC的时候会触发finalize方法调用，那什么时候会触发GC呢？当Timer对象没有被任何对象引用的时候如果有GC那么这段代码被调用：newTasksMayBeScheduled置为false同时将挂起的TimerThread唤醒，这时候mainloop死循环就跳出了，TimerThread线程结束！</p>
<p>具体验证可以使用Jprofile这个工具。事实上确实可行。但是通过这段代码让我联想到一个这个定时器的弊端：没做到像ExecutorService能够等到任务全部执行完成后再将其关闭。手动关闭只能通过cancel这种粗暴的方式,还好jdk工程师提供这样一个“后门”，交给jvm来管理。这也不失为一种补救措施，但是对于之后的JUC而言，这种做法显得有点小儿科了。但是对于学习者而言，这种代码组织显得更容易读懂，设计思想很容易呈现在我们面前。时代不断进步，总会有好的设计来取代老的旧的东西。并不是意味着老的旧的真正被取代，而是以另外一种价值呈现在我们后来人面前。通过比较，我们可能会更加理解什么是好的设计。</p>
<p>整个Timer定时任务的核心逻辑就梳理完了。其中有一些细节被忽略掉了，比如这个任务队列queue的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * This class represents a timer task queue: a priority queue of TimerTasks,</div><div class="line"> * ordered on nextExecutionTime.  Each Timer object has one of these, which it</div><div class="line"> * shares with its TimerThread.  Internally this class uses a heap, which</div><div class="line"> * offers log(n) performance for the add, removeMin and rescheduleMin</div><div class="line"> * operations, and constant time performance for the getMin operation.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</div><div class="line">    <span class="comment">// 维护一个长度为128的数组</span></div><div class="line">    <span class="keyword">private</span> TimerTask[] queue = <span class="keyword">new</span> TimerTask[<span class="number">128</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 队列长度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Adds a new task to the priority queue.</div><div class="line">     * 当前队列长度为最大长度-1的时候就进行扩容 新队列长度为当前2倍</div><div class="line">     * 为什么要在最大长度-1的时候扩容呢？因为不提前扩容当前的元素加不进去😂</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TimerTask task)</span> </span>&#123;</div><div class="line">        <span class="comment">// Grow backing store if necessary</span></div><div class="line">        <span class="keyword">if</span> (size + <span class="number">1</span> == queue.length)</div><div class="line">            queue = Arrays.copyOf(queue, <span class="number">2</span>*queue.length);</div><div class="line"></div><div class="line">        queue[++size] = task;</div><div class="line">        fixUp(size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function">TimerTask <span class="title">getMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下标从1开始取</span></div><div class="line">    <span class="function">TimerTask <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> queue[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 移除第一个元素 到期时间最近的</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra reference to prevent memory leak</span></div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickRemove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> i &lt;= size;</div><div class="line"></div><div class="line">        queue[i] = queue[size];</div><div class="line">        queue[size--] = <span class="keyword">null</span>;  <span class="comment">// Drop extra ref to prevent memory leak</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 改第一个元素的到期时间属性</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rescheduleMin</span><span class="params">(<span class="keyword">long</span> newTime)</span> </span>&#123;</div><div class="line">        queue[<span class="number">1</span>].nextExecutionTime = newTime;</div><div class="line">        fixDown(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Null out task references to prevent memory leak</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=size; i++)</div><div class="line">            queue[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) assuming the heap</div><div class="line">     * satisfies the invariant except possibly for the leaf-node indexed by k</div><div class="line">     * (which may have a nextExecutionTime less than its parent's).</div><div class="line">     *</div><div class="line">     * This method functions by "promoting" queue[k] up the hierarchy</div><div class="line">     * (by swapping it with its parent) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is greater than or equal to that of its parent.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">int</span> j = k &gt;&gt; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the subtree</div><div class="line">     * rooted at k, which is assumed to satisfy the heap invariant except</div><div class="line">     * possibly for node k itself (which may have a nextExecutionTime greater</div><div class="line">     * than its children's).</div><div class="line">     *</div><div class="line">     * This method functions by "demoting" queue[k] down the hierarchy</div><div class="line">     * (by swapping it with its smaller child) repeatedly until queue[k]'s</div><div class="line">     * nextExecutionTime is less than or equal to those of its children.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">while</span> ((j = k &lt;&lt; <span class="number">1</span>) &lt;= size &amp;&amp; j &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (j &lt; size &amp;&amp;</div><div class="line">                queue[j].nextExecutionTime &gt; queue[j+<span class="number">1</span>].nextExecutionTime)</div><div class="line">                j++; <span class="comment">// j indexes smallest kid</span></div><div class="line">            <span class="keyword">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</div><div class="line">            k = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Establishes the heap invariant (described above) in the entire tree,</div><div class="line">     * assuming nothing about the order of the elements prior to the call.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</div><div class="line">            fixDown(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个队列是一个优先级队列，task的到期时间来排序，时间越小越靠前。这个队列是用堆结构实现的，实际上堆本质上就是完全二叉树。对于add remove操作的复杂度为log(n)。最核心的操作就是fixDown fixUp 无非就是对二叉树的操作。这是一个小堆，最小的放到最上面，也就是下标为1的位置。每次添加元素都得调整堆结构，同理移除的时候也得这样做。相比于时间轮定时器这种操作显得有点笨重。</p>
<p>针对Timer的<a href="https://github.com/Mr-Vincent/simple-rpc/blob/a570c16128062b14ac0f0fa75e769d76060d3ad2/simple-example/src/main/java/top/weidong/example/netty/nettyinpractice/timer/JdkTimerDemo.java#L95-L94" target="_blank" rel="external">demo</a>在github上有记录。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>源码读起来没那么难受，仔细推敲还是很有意思的。</li>
<li>相比大牛Doug Lea的骚代码，这种中规中矩的写法看起来更让人容易理解。</li>
<li>多看源码，都是设计思想。现在随随便便一个1000+行的源码看起来丝毫不费力，我觉得这就是“锻炼”的结果。</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.mr-dongw.site/2018/04/21/Timer/" data-id="cjg94jgnq0000bz4osicmuodc" class="article-share-link">分享</a><div class="tags"><a href="/tags/源码解读/">源码解读</a><a href="/tags/JDK/">JDK</a></div><div class="post-nav"><a href="/2017/12/31/my 2017/" class="next">写给2017</a></div><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2137815"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.mr-dongw.site"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Apache/">Apache</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Apache-Open-Project/">Apache Open Project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK-SOURCE/">JDK SOURCE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPEN-SOURCE/">OPEN SOURCE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Framework/">Spring Framework</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat-笔记/">Tomcat 笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/beyound-coding/">beyound coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/想法/">想法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/翻译-整理/" style="font-size: 15px;">翻译&整理</a> <a href="/tags/Apache-Shiro/" style="font-size: 15px;">Apache Shiro</a> <a href="/tags/源码解读/" style="font-size: 15px;">源码解读</a> <a href="/tags/Apache/" style="font-size: 15px;">Apache</a> <a href="/tags/所想/" style="font-size: 15px;">所想</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/XML/" style="font-size: 15px;">XML</a> <a href="/tags/字节码工具/" style="font-size: 15px;">字节码工具</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/生活，扯淡/" style="font-size: 15px;">生活，扯淡</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/21/Timer/">浅析JDK中的定时器Timer实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/my 2017/">写给2017</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/《How Tomcat Works》读书笔记/">《How Tomcat Works》读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/26/Securing Web Applications with Apache Shiro[译]/">Securing Web Applications with Apache Shiro[译]</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/Java Authorization Guide with Apache Shiro[译]/">Java Authorization Guide with Apache Shiro[译]</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/Application Security With Apache Shiro[译]/">Application Security With Apache Shiro[译]</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/spring-boot-fatures-2/">Spring Boot Features（Part Ⅱ）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/spring-boot-fatures/">Spring Boot Features（Part I）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/动态代理番外篇/">动态代理番外篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/09/动态代理之JDK实现/">动态代理之JDK实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.wangtianyi.top" title="王屌" target="_blank">王屌</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">DongWei's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>